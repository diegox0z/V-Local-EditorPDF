// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"../node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"../node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../node_modules/node-libs-browser/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../node_modules/base64-js/index.js","ieee754":"../node_modules/ieee754/index.js","isarray":"../node_modules/isarray/index.js","buffer":"../node_modules/node-libs-browser/node_modules/buffer/index.js"}],"../node_modules/pdfjs-dist/build/pdf.js":[function(require,module,exports) {
var define;
var process = require("process");
var Buffer = require("buffer").Buffer;
function _superPropGet(t, o, e, r) { var p = _get3(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get3() { return _get3 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get3.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n2 = 0, F = function F() {}; return { s: F, n: function n() { return _n2 >= r.length ? { done: !0 } : { done: !1, value: r[_n2++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && (typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object') module.exports = root.pdfjsLib = factory();else if (typeof define === 'function' && define.amd) define("pdfjs-dist/build/pdf", [], function () {
    return root.pdfjsLib = factory();
  });else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') exports["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();else root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
})(globalThis, function () {
  return /******/function () {
    // webpackBootstrap
    /******/
    "use strict";

    /******/
    var __webpack_modules__ = [
      /* 0 */
    , (/* 1 */
    /***/function (__unused_webpack_module, exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationReplyType = exports.AnnotationPrefix = exports.AnnotationMode = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
      exports.assert = assert;
      exports.bytesToString = bytesToString;
      exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
      exports.getModificationDate = getModificationDate;
      exports.getUuid = getUuid;
      exports.getVerbosityLevel = getVerbosityLevel;
      exports.info = info;
      exports.isArrayBuffer = isArrayBuffer;
      exports.isArrayEqual = isArrayEqual;
      exports.isNodeJS = void 0;
      exports.normalizeUnicode = normalizeUnicode;
      exports.objectFromMap = objectFromMap;
      exports.objectSize = objectSize;
      exports.setVerbosityLevel = setVerbosityLevel;
      exports.shadow = shadow;
      exports.string32 = string32;
      exports.stringToBytes = stringToBytes;
      exports.stringToPDFString = stringToPDFString;
      exports.stringToUTF8String = stringToUTF8String;
      exports.unreachable = unreachable;
      exports.utf8StringToString = utf8StringToString;
      exports.warn = warn;
      var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
      exports.isNodeJS = isNodeJS;
      var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
      exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
      var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
      exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
      var MAX_IMAGE_SIZE_TO_CACHE = 10e6;
      exports.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
      var LINE_FACTOR = 1.35;
      exports.LINE_FACTOR = LINE_FACTOR;
      var LINE_DESCENT_FACTOR = 0.35;
      exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
      var BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
      exports.BASELINE_FACTOR = BASELINE_FACTOR;
      var RenderingIntentFlag = {
        ANY: 0x01,
        DISPLAY: 0x02,
        PRINT: 0x04,
        SAVE: 0x08,
        ANNOTATIONS_FORMS: 0x10,
        ANNOTATIONS_STORAGE: 0x20,
        ANNOTATIONS_DISABLE: 0x40,
        OPLIST: 0x100
      };
      exports.RenderingIntentFlag = RenderingIntentFlag;
      var AnnotationMode = {
        DISABLE: 0,
        ENABLE: 1,
        ENABLE_FORMS: 2,
        ENABLE_STORAGE: 3
      };
      exports.AnnotationMode = AnnotationMode;
      var AnnotationEditorPrefix = "pdfjs_internal_editor_";
      exports.AnnotationEditorPrefix = AnnotationEditorPrefix;
      var AnnotationEditorType = {
        DISABLE: -1,
        NONE: 0,
        FREETEXT: 3,
        STAMP: 13,
        INK: 15
      };
      exports.AnnotationEditorType = AnnotationEditorType;
      var AnnotationEditorParamsType = {
        RESIZE: 1,
        CREATE: 2,
        FREETEXT_SIZE: 11,
        FREETEXT_COLOR: 12,
        FREETEXT_OPACITY: 13,
        INK_COLOR: 21,
        INK_THICKNESS: 22,
        INK_OPACITY: 23
      };
      exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
      var PermissionFlag = {
        PRINT: 0x04,
        MODIFY_CONTENTS: 0x08,
        COPY: 0x10,
        MODIFY_ANNOTATIONS: 0x20,
        FILL_INTERACTIVE_FORMS: 0x100,
        COPY_FOR_ACCESSIBILITY: 0x200,
        ASSEMBLE: 0x400,
        PRINT_HIGH_QUALITY: 0x800
      };
      exports.PermissionFlag = PermissionFlag;
      var TextRenderingMode = {
        FILL: 0,
        STROKE: 1,
        FILL_STROKE: 2,
        INVISIBLE: 3,
        FILL_ADD_TO_PATH: 4,
        STROKE_ADD_TO_PATH: 5,
        FILL_STROKE_ADD_TO_PATH: 6,
        ADD_TO_PATH: 7,
        FILL_STROKE_MASK: 3,
        ADD_TO_PATH_FLAG: 4
      };
      exports.TextRenderingMode = TextRenderingMode;
      var ImageKind = {
        GRAYSCALE_1BPP: 1,
        RGB_24BPP: 2,
        RGBA_32BPP: 3
      };
      exports.ImageKind = ImageKind;
      var AnnotationType = {
        TEXT: 1,
        LINK: 2,
        FREETEXT: 3,
        LINE: 4,
        SQUARE: 5,
        CIRCLE: 6,
        POLYGON: 7,
        POLYLINE: 8,
        HIGHLIGHT: 9,
        UNDERLINE: 10,
        SQUIGGLY: 11,
        STRIKEOUT: 12,
        STAMP: 13,
        CARET: 14,
        INK: 15,
        POPUP: 16,
        FILEATTACHMENT: 17,
        SOUND: 18,
        MOVIE: 19,
        WIDGET: 20,
        SCREEN: 21,
        PRINTERMARK: 22,
        TRAPNET: 23,
        WATERMARK: 24,
        THREED: 25,
        REDACT: 26
      };
      exports.AnnotationType = AnnotationType;
      var AnnotationReplyType = {
        GROUP: "Group",
        REPLY: "R"
      };
      exports.AnnotationReplyType = AnnotationReplyType;
      var AnnotationFlag = {
        INVISIBLE: 0x01,
        HIDDEN: 0x02,
        PRINT: 0x04,
        NOZOOM: 0x08,
        NOROTATE: 0x10,
        NOVIEW: 0x20,
        READONLY: 0x40,
        LOCKED: 0x80,
        TOGGLENOVIEW: 0x100,
        LOCKEDCONTENTS: 0x200
      };
      exports.AnnotationFlag = AnnotationFlag;
      var AnnotationFieldFlag = {
        READONLY: 0x0000001,
        REQUIRED: 0x0000002,
        NOEXPORT: 0x0000004,
        MULTILINE: 0x0001000,
        PASSWORD: 0x0002000,
        NOTOGGLETOOFF: 0x0004000,
        RADIO: 0x0008000,
        PUSHBUTTON: 0x0010000,
        COMBO: 0x0020000,
        EDIT: 0x0040000,
        SORT: 0x0080000,
        FILESELECT: 0x0100000,
        MULTISELECT: 0x0200000,
        DONOTSPELLCHECK: 0x0400000,
        DONOTSCROLL: 0x0800000,
        COMB: 0x1000000,
        RICHTEXT: 0x2000000,
        RADIOSINUNISON: 0x2000000,
        COMMITONSELCHANGE: 0x4000000
      };
      exports.AnnotationFieldFlag = AnnotationFieldFlag;
      var AnnotationBorderStyleType = {
        SOLID: 1,
        DASHED: 2,
        BEVELED: 3,
        INSET: 4,
        UNDERLINE: 5
      };
      exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
      var AnnotationActionEventType = {
        E: "Mouse Enter",
        X: "Mouse Exit",
        D: "Mouse Down",
        U: "Mouse Up",
        Fo: "Focus",
        Bl: "Blur",
        PO: "PageOpen",
        PC: "PageClose",
        PV: "PageVisible",
        PI: "PageInvisible",
        K: "Keystroke",
        F: "Format",
        V: "Validate",
        C: "Calculate"
      };
      exports.AnnotationActionEventType = AnnotationActionEventType;
      var DocumentActionEventType = {
        WC: "WillClose",
        WS: "WillSave",
        DS: "DidSave",
        WP: "WillPrint",
        DP: "DidPrint"
      };
      exports.DocumentActionEventType = DocumentActionEventType;
      var PageActionEventType = {
        O: "PageOpen",
        C: "PageClose"
      };
      exports.PageActionEventType = PageActionEventType;
      var VerbosityLevel = {
        ERRORS: 0,
        WARNINGS: 1,
        INFOS: 5
      };
      exports.VerbosityLevel = VerbosityLevel;
      var CMapCompressionType = {
        NONE: 0,
        BINARY: 1
      };
      exports.CMapCompressionType = CMapCompressionType;
      var OPS = {
        dependency: 1,
        setLineWidth: 2,
        setLineCap: 3,
        setLineJoin: 4,
        setMiterLimit: 5,
        setDash: 6,
        setRenderingIntent: 7,
        setFlatness: 8,
        setGState: 9,
        save: 10,
        restore: 11,
        transform: 12,
        moveTo: 13,
        lineTo: 14,
        curveTo: 15,
        curveTo2: 16,
        curveTo3: 17,
        closePath: 18,
        rectangle: 19,
        stroke: 20,
        closeStroke: 21,
        fill: 22,
        eoFill: 23,
        fillStroke: 24,
        eoFillStroke: 25,
        closeFillStroke: 26,
        closeEOFillStroke: 27,
        endPath: 28,
        clip: 29,
        eoClip: 30,
        beginText: 31,
        endText: 32,
        setCharSpacing: 33,
        setWordSpacing: 34,
        setHScale: 35,
        setLeading: 36,
        setFont: 37,
        setTextRenderingMode: 38,
        setTextRise: 39,
        moveText: 40,
        setLeadingMoveText: 41,
        setTextMatrix: 42,
        nextLine: 43,
        showText: 44,
        showSpacedText: 45,
        nextLineShowText: 46,
        nextLineSetSpacingShowText: 47,
        setCharWidth: 48,
        setCharWidthAndBounds: 49,
        setStrokeColorSpace: 50,
        setFillColorSpace: 51,
        setStrokeColor: 52,
        setStrokeColorN: 53,
        setFillColor: 54,
        setFillColorN: 55,
        setStrokeGray: 56,
        setFillGray: 57,
        setStrokeRGBColor: 58,
        setFillRGBColor: 59,
        setStrokeCMYKColor: 60,
        setFillCMYKColor: 61,
        shadingFill: 62,
        beginInlineImage: 63,
        beginImageData: 64,
        endInlineImage: 65,
        paintXObject: 66,
        markPoint: 67,
        markPointProps: 68,
        beginMarkedContent: 69,
        beginMarkedContentProps: 70,
        endMarkedContent: 71,
        beginCompat: 72,
        endCompat: 73,
        paintFormXObjectBegin: 74,
        paintFormXObjectEnd: 75,
        beginGroup: 76,
        endGroup: 77,
        beginAnnotation: 80,
        endAnnotation: 81,
        paintImageMaskXObject: 83,
        paintImageMaskXObjectGroup: 84,
        paintImageXObject: 85,
        paintInlineImageXObject: 86,
        paintInlineImageXObjectGroup: 87,
        paintImageXObjectRepeat: 88,
        paintImageMaskXObjectRepeat: 89,
        paintSolidColorImageMask: 90,
        constructPath: 91
      };
      exports.OPS = OPS;
      var PasswordResponses = {
        NEED_PASSWORD: 1,
        INCORRECT_PASSWORD: 2
      };
      exports.PasswordResponses = PasswordResponses;
      var verbosity = VerbosityLevel.WARNINGS;
      function setVerbosityLevel(level) {
        if (Number.isInteger(level)) {
          verbosity = level;
        }
      }
      function getVerbosityLevel() {
        return verbosity;
      }
      function info(msg) {
        if (verbosity >= VerbosityLevel.INFOS) {
          console.log("Info: ".concat(msg));
        }
      }
      function warn(msg) {
        if (verbosity >= VerbosityLevel.WARNINGS) {
          console.log("Warning: ".concat(msg));
        }
      }
      function unreachable(msg) {
        throw new Error(msg);
      }
      function assert(cond, msg) {
        if (!cond) {
          unreachable(msg);
        }
      }
      function _isValidProtocol(url) {
        switch (url === null || url === void 0 ? void 0 : url.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return true;
          default:
            return false;
        }
      }
      function createValidAbsoluteUrl(url) {
        var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!url) {
          return null;
        }
        try {
          if (options && typeof url === "string") {
            if (options.addDefaultProtocol && url.startsWith("www.")) {
              var dots = url.match(/\./g);
              if ((dots === null || dots === void 0 ? void 0 : dots.length) >= 2) {
                url = "http://".concat(url);
              }
            }
            if (options.tryConvertEncoding) {
              try {
                url = stringToUTF8String(url);
              } catch (_unused) {}
            }
          }
          var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
          if (_isValidProtocol(absoluteUrl)) {
            return absoluteUrl;
          }
        } catch (_unused2) {}
        return null;
      }
      function shadow(obj, prop, value) {
        var nonSerializable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        Object.defineProperty(obj, prop, {
          value: value,
          enumerable: !nonSerializable,
          configurable: true,
          writable: false
        });
        return value;
      }
      var BaseException = function BaseExceptionClosure() {
        function BaseException(message, name) {
          if (this.constructor === BaseException) {
            unreachable("Cannot initialize BaseException.");
          }
          this.message = message;
          this.name = name;
        }
        BaseException.prototype = new Error();
        BaseException.constructor = BaseException;
        return BaseException;
      }();
      exports.BaseException = BaseException;
      var PasswordException = /*#__PURE__*/function (_BaseException) {
        function PasswordException(msg, code) {
          var _this;
          _classCallCheck(this, PasswordException);
          _this = _callSuper(this, PasswordException, [msg, "PasswordException"]);
          _this.code = code;
          return _this;
        }
        _inherits(PasswordException, _BaseException);
        return _createClass(PasswordException);
      }(BaseException);
      exports.PasswordException = PasswordException;
      var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {
        function UnknownErrorException(msg, details) {
          var _this2;
          _classCallCheck(this, UnknownErrorException);
          _this2 = _callSuper(this, UnknownErrorException, [msg, "UnknownErrorException"]);
          _this2.details = details;
          return _this2;
        }
        _inherits(UnknownErrorException, _BaseException2);
        return _createClass(UnknownErrorException);
      }(BaseException);
      exports.UnknownErrorException = UnknownErrorException;
      var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {
        function InvalidPDFException(msg) {
          _classCallCheck(this, InvalidPDFException);
          return _callSuper(this, InvalidPDFException, [msg, "InvalidPDFException"]);
        }
        _inherits(InvalidPDFException, _BaseException3);
        return _createClass(InvalidPDFException);
      }(BaseException);
      exports.InvalidPDFException = InvalidPDFException;
      var MissingPDFException = /*#__PURE__*/function (_BaseException4) {
        function MissingPDFException(msg) {
          _classCallCheck(this, MissingPDFException);
          return _callSuper(this, MissingPDFException, [msg, "MissingPDFException"]);
        }
        _inherits(MissingPDFException, _BaseException4);
        return _createClass(MissingPDFException);
      }(BaseException);
      exports.MissingPDFException = MissingPDFException;
      var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {
        function UnexpectedResponseException(msg, status) {
          var _this3;
          _classCallCheck(this, UnexpectedResponseException);
          _this3 = _callSuper(this, UnexpectedResponseException, [msg, "UnexpectedResponseException"]);
          _this3.status = status;
          return _this3;
        }
        _inherits(UnexpectedResponseException, _BaseException5);
        return _createClass(UnexpectedResponseException);
      }(BaseException);
      exports.UnexpectedResponseException = UnexpectedResponseException;
      var FormatError = /*#__PURE__*/function (_BaseException6) {
        function FormatError(msg) {
          _classCallCheck(this, FormatError);
          return _callSuper(this, FormatError, [msg, "FormatError"]);
        }
        _inherits(FormatError, _BaseException6);
        return _createClass(FormatError);
      }(BaseException);
      exports.FormatError = FormatError;
      var AbortException = /*#__PURE__*/function (_BaseException7) {
        function AbortException(msg) {
          _classCallCheck(this, AbortException);
          return _callSuper(this, AbortException, [msg, "AbortException"]);
        }
        _inherits(AbortException, _BaseException7);
        return _createClass(AbortException);
      }(BaseException);
      exports.AbortException = AbortException;
      function bytesToString(bytes) {
        if (_typeof(bytes) !== "object" || (bytes === null || bytes === void 0 ? void 0 : bytes.length) === undefined) {
          unreachable("Invalid argument for bytesToString");
        }
        var length = bytes.length;
        var MAX_ARGUMENT_COUNT = 8192;
        if (length < MAX_ARGUMENT_COUNT) {
          return String.fromCharCode.apply(null, bytes);
        }
        var strBuf = [];
        for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
          var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
          var chunk = bytes.subarray(i, chunkEnd);
          strBuf.push(String.fromCharCode.apply(null, chunk));
        }
        return strBuf.join("");
      }
      function stringToBytes(str) {
        if (typeof str !== "string") {
          unreachable("Invalid argument for stringToBytes");
        }
        var length = str.length;
        var bytes = new Uint8Array(length);
        for (var i = 0; i < length; ++i) {
          bytes[i] = str.charCodeAt(i) & 0xff;
        }
        return bytes;
      }
      function string32(value) {
        return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
      }
      function objectSize(obj) {
        return Object.keys(obj).length;
      }
      function objectFromMap(map) {
        var obj = Object.create(null);
        var _iterator = _createForOfIteratorHelper(map),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];
            obj[key] = value;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return obj;
      }
      function isLittleEndian() {
        var buffer8 = new Uint8Array(4);
        buffer8[0] = 1;
        var view32 = new Uint32Array(buffer8.buffer, 0, 1);
        return view32[0] === 1;
      }
      function isEvalSupported() {
        try {
          new Function("");
          return true;
        } catch (_unused3) {
          return false;
        }
      }
      var FeatureTest = /*#__PURE__*/function () {
        function FeatureTest() {
          _classCallCheck(this, FeatureTest);
        }
        return _createClass(FeatureTest, null, [{
          key: "isLittleEndian",
          get: function get() {
            return shadow(this, "isLittleEndian", isLittleEndian());
          }
        }, {
          key: "isEvalSupported",
          get: function get() {
            return shadow(this, "isEvalSupported", isEvalSupported());
          }
        }, {
          key: "isOffscreenCanvasSupported",
          get: function get() {
            return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
          }
        }, {
          key: "platform",
          get: function get() {
            if (typeof navigator === "undefined") {
              return shadow(this, "platform", {
                isWin: false,
                isMac: false
              });
            }
            return shadow(this, "platform", {
              isWin: navigator.platform.includes("Win"),
              isMac: navigator.platform.includes("Mac")
            });
          }
        }, {
          key: "isCSSRoundSupported",
          get: function get() {
            var _globalThis$CSS, _globalThis$CSS$suppo;
            return shadow(this, "isCSSRoundSupported", (_globalThis$CSS = globalThis.CSS) === null || _globalThis$CSS === void 0 || (_globalThis$CSS$suppo = _globalThis$CSS.supports) === null || _globalThis$CSS$suppo === void 0 ? void 0 : _globalThis$CSS$suppo.call(_globalThis$CSS, "width: round(1.5px, 1px)"));
          }
        }]);
      }();
      exports.FeatureTest = FeatureTest;
      var hexNumbers = _toConsumableArray(Array(256).keys()).map(function (n) {
        return n.toString(16).padStart(2, "0");
      });
      var Util = /*#__PURE__*/function () {
        function Util() {
          _classCallCheck(this, Util);
        }
        return _createClass(Util, null, [{
          key: "makeHexColor",
          value: function makeHexColor(r, g, b) {
            return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
          }
        }, {
          key: "scaleMinMax",
          value: function scaleMinMax(transform, minMax) {
            var temp;
            if (transform[0]) {
              if (transform[0] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[1];
                minMax[1] = temp;
              }
              minMax[0] *= transform[0];
              minMax[1] *= transform[0];
              if (transform[3] < 0) {
                temp = minMax[2];
                minMax[2] = minMax[3];
                minMax[3] = temp;
              }
              minMax[2] *= transform[3];
              minMax[3] *= transform[3];
            } else {
              temp = minMax[0];
              minMax[0] = minMax[2];
              minMax[2] = temp;
              temp = minMax[1];
              minMax[1] = minMax[3];
              minMax[3] = temp;
              if (transform[1] < 0) {
                temp = minMax[2];
                minMax[2] = minMax[3];
                minMax[3] = temp;
              }
              minMax[2] *= transform[1];
              minMax[3] *= transform[1];
              if (transform[2] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[1];
                minMax[1] = temp;
              }
              minMax[0] *= transform[2];
              minMax[1] *= transform[2];
            }
            minMax[0] += transform[4];
            minMax[1] += transform[4];
            minMax[2] += transform[5];
            minMax[3] += transform[5];
          }
        }, {
          key: "transform",
          value: function transform(m1, m2) {
            return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
          }
        }, {
          key: "applyTransform",
          value: function applyTransform(p, m) {
            var xt = p[0] * m[0] + p[1] * m[2] + m[4];
            var yt = p[0] * m[1] + p[1] * m[3] + m[5];
            return [xt, yt];
          }
        }, {
          key: "applyInverseTransform",
          value: function applyInverseTransform(p, m) {
            var d = m[0] * m[3] - m[1] * m[2];
            var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
            var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
            return [xt, yt];
          }
        }, {
          key: "getAxialAlignedBoundingBox",
          value: function getAxialAlignedBoundingBox(r, m) {
            var p1 = this.applyTransform(r, m);
            var p2 = this.applyTransform(r.slice(2, 4), m);
            var p3 = this.applyTransform([r[0], r[3]], m);
            var p4 = this.applyTransform([r[2], r[1]], m);
            return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
          }
        }, {
          key: "inverseTransform",
          value: function inverseTransform(m) {
            var d = m[0] * m[3] - m[1] * m[2];
            return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
          }
        }, {
          key: "singularValueDecompose2dScale",
          value: function singularValueDecompose2dScale(m) {
            var transpose = [m[0], m[2], m[1], m[3]];
            var a = m[0] * transpose[0] + m[1] * transpose[2];
            var b = m[0] * transpose[1] + m[1] * transpose[3];
            var c = m[2] * transpose[0] + m[3] * transpose[2];
            var d = m[2] * transpose[1] + m[3] * transpose[3];
            var first = (a + d) / 2;
            var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;
            var sx = first + second || 1;
            var sy = first - second || 1;
            return [Math.sqrt(sx), Math.sqrt(sy)];
          }
        }, {
          key: "normalizeRect",
          value: function normalizeRect(rect) {
            var r = rect.slice(0);
            if (rect[0] > rect[2]) {
              r[0] = rect[2];
              r[2] = rect[0];
            }
            if (rect[1] > rect[3]) {
              r[1] = rect[3];
              r[3] = rect[1];
            }
            return r;
          }
        }, {
          key: "intersect",
          value: function intersect(rect1, rect2) {
            var xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
            var xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
            if (xLow > xHigh) {
              return null;
            }
            var yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
            var yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
            if (yLow > yHigh) {
              return null;
            }
            return [xLow, yLow, xHigh, yHigh];
          }
        }, {
          key: "bezierBoundingBox",
          value: function bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
            var tvalues = [],
              bounds = [[], []];
            var a, b, c, t, t1, t2, b2ac, sqrtb2ac;
            for (var i = 0; i < 2; ++i) {
              if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
              } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
              }
              if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                  continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                  tvalues.push(t);
                }
                continue;
              }
              b2ac = b * b - 4 * c * a;
              sqrtb2ac = Math.sqrt(b2ac);
              if (b2ac < 0) {
                continue;
              }
              t1 = (-b + sqrtb2ac) / (2 * a);
              if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
              }
              t2 = (-b - sqrtb2ac) / (2 * a);
              if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
              }
            }
            var j = tvalues.length,
              mt;
            var jlen = j;
            while (j--) {
              t = tvalues[j];
              mt = 1 - t;
              bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
              bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            }
            bounds[0][jlen] = x0;
            bounds[1][jlen] = y0;
            bounds[0][jlen + 1] = x3;
            bounds[1][jlen + 1] = y3;
            bounds[0].length = bounds[1].length = jlen + 2;
            return [Math.min.apply(Math, _toConsumableArray(bounds[0])), Math.min.apply(Math, _toConsumableArray(bounds[1])), Math.max.apply(Math, _toConsumableArray(bounds[0])), Math.max.apply(Math, _toConsumableArray(bounds[1]))];
          }
        }]);
      }();
      exports.Util = Util;
      var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];
      function stringToPDFString(str) {
        if (str[0] >= "\xEF") {
          var encoding;
          if (str[0] === "\xFE" && str[1] === "\xFF") {
            encoding = "utf-16be";
          } else if (str[0] === "\xFF" && str[1] === "\xFE") {
            encoding = "utf-16le";
          } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
            encoding = "utf-8";
          }
          if (encoding) {
            try {
              var decoder = new TextDecoder(encoding, {
                fatal: true
              });
              var buffer = stringToBytes(str);
              return decoder.decode(buffer);
            } catch (ex) {
              warn("stringToPDFString: \"".concat(ex, "\"."));
            }
          }
        }
        var strBuf = [];
        for (var i = 0, ii = str.length; i < ii; i++) {
          var code = PDFStringTranslateTable[str.charCodeAt(i)];
          strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
        }
        return strBuf.join("");
      }
      function stringToUTF8String(str) {
        return decodeURIComponent(escape(str));
      }
      function utf8StringToString(str) {
        return unescape(encodeURIComponent(str));
      }
      function isArrayBuffer(v) {
        return _typeof(v) === "object" && (v === null || v === void 0 ? void 0 : v.byteLength) !== undefined;
      }
      function isArrayEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) {
          return false;
        }
        for (var i = 0, ii = arr1.length; i < ii; i++) {
          if (arr1[i] !== arr2[i]) {
            return false;
          }
        }
        return true;
      }
      function getModificationDate() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
        return buffer.join("");
      }
      var _settled = /*#__PURE__*/new WeakMap();
      var PromiseCapability = /*#__PURE__*/function () {
        function PromiseCapability() {
          var _this4 = this;
          _classCallCheck(this, PromiseCapability);
          _classPrivateFieldInitSpec(this, _settled, false);
          this.promise = new Promise(function (resolve, reject) {
            _this4.resolve = function (data) {
              _classPrivateFieldSet(_settled, _this4, true);
              resolve(data);
            };
            _this4.reject = function (reason) {
              _classPrivateFieldSet(_settled, _this4, true);
              reject(reason);
            };
          });
        }
        return _createClass(PromiseCapability, [{
          key: "settled",
          get: function get() {
            return _classPrivateFieldGet(_settled, this);
          }
        }]);
      }();
      exports.PromiseCapability = PromiseCapability;
      var NormalizeRegex = null;
      var NormalizationMap = null;
      function normalizeUnicode(str) {
        if (!NormalizeRegex) {
          NormalizeRegex = /([\xA0\xB5\u037E\u0EB3\u2000-\u200A\u202F\u2126\uFB00-\uFB04\uFB06\uFB20-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBA1\uFBA4-\uFBA9\uFBAE-\uFBB1\uFBD3-\uFBDC\uFBDE-\uFBE7\uFBEA-\uFBF8\uFBFC\uFBFD\uFC00-\uFC5D\uFC64-\uFCF1\uFCF5-\uFD3D\uFD88\uFDF4\uFDFA\uFDFB\uFE71\uFE77\uFE79\uFE7B\uFE7D]+)|(\uFB05+)/g;
          NormalizationMap = new Map([["ﬅ", "ſt"]]);
        }
        return str.replaceAll(NormalizeRegex, function (_, p1, p2) {
          return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
        });
      }
      function getUuid() {
        var _crypto, _crypto2;
        if (typeof crypto !== "undefined" && typeof ((_crypto = crypto) === null || _crypto === void 0 ? void 0 : _crypto.randomUUID) === "function") {
          return crypto.randomUUID();
        }
        var buf = new Uint8Array(32);
        if (typeof crypto !== "undefined" && typeof ((_crypto2 = crypto) === null || _crypto2 === void 0 ? void 0 : _crypto2.getRandomValues) === "function") {
          crypto.getRandomValues(buf);
        } else {
          for (var i = 0; i < 32; i++) {
            buf[i] = Math.floor(Math.random() * 255);
          }
        }
        return bytesToString(buf);
      }
      var AnnotationPrefix = "pdfjs_internal_id_";
      exports.AnnotationPrefix = AnnotationPrefix;

      /***/
    }), (/* 2 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
      Object.defineProperty(exports, "SVGGraphics", {
        enumerable: true,
        get: function get() {
          return _displaySvg.SVGGraphics;
        }
      });
      exports.build = void 0;
      exports.getDocument = getDocument;
      exports.version = void 0;
      var _util = __w_pdfjs_require__(1);
      var _annotation_storage = __w_pdfjs_require__(3);
      var _display_utils = __w_pdfjs_require__(6);
      var _font_loader = __w_pdfjs_require__(9);
      var _displayNode_utils = __w_pdfjs_require__(10);
      var _canvas = __w_pdfjs_require__(11);
      var _worker_options = __w_pdfjs_require__(14);
      var _message_handler = __w_pdfjs_require__(15);
      var _metadata = __w_pdfjs_require__(16);
      var _optional_content_config = __w_pdfjs_require__(17);
      var _transport_stream = __w_pdfjs_require__(18);
      var _displayFetch_stream = __w_pdfjs_require__(19);
      var _displayNetwork = __w_pdfjs_require__(22);
      var _displayNode_stream = __w_pdfjs_require__(23);
      var _displaySvg = __w_pdfjs_require__(24);
      var _xfa_text = __w_pdfjs_require__(25);
      var DEFAULT_RANGE_CHUNK_SIZE = 65536;
      var RENDERING_CANCELLED_TIMEOUT = 100;
      var DELAYED_CLEANUP_TIMEOUT = 5000;
      var DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
      exports.DefaultCanvasFactory = DefaultCanvasFactory;
      var DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
      exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
      var DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
      exports.DefaultFilterFactory = DefaultFilterFactory;
      var DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
      exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
      function getDocument(src) {
        var _src$password, _src$length;
        if (typeof src === "string" || src instanceof URL) {
          src = {
            url: src
          };
        } else if ((0, _util.isArrayBuffer)(src)) {
          src = {
            data: src
          };
        }
        if (_typeof(src) !== "object") {
          throw new Error("Invalid parameter in getDocument, need parameter object.");
        }
        if (!src.url && !src.data && !src.range) {
          throw new Error("Invalid parameter object: need either .data, .range or .url");
        }
        var task = new PDFDocumentLoadingTask();
        var docId = task.docId;
        var url = src.url ? getUrlProp(src.url) : null;
        var data = src.data ? getDataProp(src.data) : null;
        var httpHeaders = src.httpHeaders || null;
        var withCredentials = src.withCredentials === true;
        var password = (_src$password = src.password) !== null && _src$password !== void 0 ? _src$password : null;
        var rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
        var rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
        var worker = src.worker instanceof PDFWorker ? src.worker : null;
        var verbosity = src.verbosity;
        var docBaseUrl = typeof src.docBaseUrl === "string" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;
        var cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
        var cMapPacked = src.cMapPacked !== false;
        var CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
        var standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
        var StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
        var ignoreErrors = src.stopAtErrors !== true;
        var maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
        var isEvalSupported = src.isEvalSupported !== false;
        var isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;
        var canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
        var disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : _util.isNodeJS;
        var fontExtraProperties = src.fontExtraProperties === true;
        var enableXfa = src.enableXfa === true;
        var ownerDocument = src.ownerDocument || globalThis.document;
        var disableRange = src.disableRange === true;
        var disableStream = src.disableStream === true;
        var disableAutoFetch = src.disableAutoFetch === true;
        var pdfBug = src.pdfBug === true;
        var length = rangeTransport ? rangeTransport.length : (_src$length = src.length) !== null && _src$length !== void 0 ? _src$length : NaN;
        var useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;
        var useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);
        var canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
          ownerDocument: ownerDocument
        });
        var filterFactory = src.filterFactory || new DefaultFilterFactory({
          docId: docId,
          ownerDocument: ownerDocument
        });
        var styleElement = null;
        (0, _util.setVerbosityLevel)(verbosity);
        var transportFactory = {
          canvasFactory: canvasFactory,
          filterFactory: filterFactory
        };
        if (!useWorkerFetch) {
          transportFactory.cMapReaderFactory = new CMapReaderFactory({
            baseUrl: cMapUrl,
            isCompressed: cMapPacked
          });
          transportFactory.standardFontDataFactory = new StandardFontDataFactory({
            baseUrl: standardFontDataUrl
          });
        }
        if (!worker) {
          var workerParams = {
            verbosity: verbosity,
            port: _worker_options.GlobalWorkerOptions.workerPort
          };
          worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
          task._worker = worker;
        }
        var fetchDocParams = {
          docId: docId,
          apiVersion: '3.11.174',
          data: data,
          password: password,
          disableAutoFetch: disableAutoFetch,
          rangeChunkSize: rangeChunkSize,
          length: length,
          docBaseUrl: docBaseUrl,
          enableXfa: enableXfa,
          evaluatorOptions: {
            maxImageSize: maxImageSize,
            disableFontFace: disableFontFace,
            ignoreErrors: ignoreErrors,
            isEvalSupported: isEvalSupported,
            isOffscreenCanvasSupported: isOffscreenCanvasSupported,
            canvasMaxAreaInBytes: canvasMaxAreaInBytes,
            fontExtraProperties: fontExtraProperties,
            useSystemFonts: useSystemFonts,
            cMapUrl: useWorkerFetch ? cMapUrl : null,
            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
          }
        };
        var transportParams = {
          ignoreErrors: ignoreErrors,
          isEvalSupported: isEvalSupported,
          disableFontFace: disableFontFace,
          fontExtraProperties: fontExtraProperties,
          enableXfa: enableXfa,
          ownerDocument: ownerDocument,
          disableAutoFetch: disableAutoFetch,
          pdfBug: pdfBug,
          styleElement: styleElement
        };
        worker.promise.then(function () {
          if (task.destroyed) {
            throw new Error("Loading aborted");
          }
          var workerIdPromise = _fetchDocument(worker, fetchDocParams);
          var networkStreamPromise = new Promise(function (resolve) {
            var networkStream;
            if (rangeTransport) {
              networkStream = new _transport_stream.PDFDataTransportStream({
                length: length,
                initialData: rangeTransport.initialData,
                progressiveDone: rangeTransport.progressiveDone,
                contentDispositionFilename: rangeTransport.contentDispositionFilename,
                disableRange: disableRange,
                disableStream: disableStream
              }, rangeTransport);
            } else if (!data) {
              var createPDFNetworkStream = function createPDFNetworkStream(params) {
                if (_util.isNodeJS) {
                  return new _displayNode_stream.PDFNodeStream(params);
                }
                return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);
              };
              networkStream = createPDFNetworkStream({
                url: url,
                length: length,
                httpHeaders: httpHeaders,
                withCredentials: withCredentials,
                rangeChunkSize: rangeChunkSize,
                disableRange: disableRange,
                disableStream: disableStream
              });
            }
            resolve(networkStream);
          });
          return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              workerId = _ref2[0],
              networkStream = _ref2[1];
            if (task.destroyed) {
              throw new Error("Loading aborted");
            }
            var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
            var transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
            task._transport = transport;
            messageHandler.send("Ready", null);
          });
        }).catch(task._capability.reject);
        return task;
      }
      function _fetchDocument(_x, _x2) {
        return _fetchDocument2.apply(this, arguments);
      }
      function _fetchDocument2() {
        _fetchDocument2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(worker, source) {
          var workerId;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                if (!worker.destroyed) {
                  _context6.next = 2;
                  break;
                }
                throw new Error("Worker was destroyed");
              case 2:
                _context6.next = 4;
                return worker.messageHandler.sendWithPromise("GetDocRequest", source, source.data ? [source.data.buffer] : null);
              case 4:
                workerId = _context6.sent;
                if (!worker.destroyed) {
                  _context6.next = 7;
                  break;
                }
                throw new Error("Worker was destroyed");
              case 7:
                return _context6.abrupt("return", workerId);
              case 8:
              case "end":
                return _context6.stop();
            }
          }, _callee6);
        }));
        return _fetchDocument2.apply(this, arguments);
      }
      function getUrlProp(val) {
        if (val instanceof URL) {
          return val.href;
        }
        try {
          return new URL(val, window.location).href;
        } catch (_unused4) {
          if (_util.isNodeJS && typeof val === "string") {
            return val;
          }
        }
        throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");
      }
      function getDataProp(val) {
        if (_util.isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
          throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
        }
        if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
          return val;
        }
        if (typeof val === "string") {
          return (0, _util.stringToBytes)(val);
        }
        if (_typeof(val) === "object" && !isNaN(val === null || val === void 0 ? void 0 : val.length) || (0, _util.isArrayBuffer)(val)) {
          return new Uint8Array(val);
        }
        throw new Error("Invalid PDF binary data: either TypedArray, " + "string, or array-like object is expected in the data property.");
      }
      var PDFDocumentLoadingTask = /*#__PURE__*/function () {
        function PDFDocumentLoadingTask() {
          var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;
          _classCallCheck(this, PDFDocumentLoadingTask);
          this._capability = new _util.PromiseCapability();
          this._transport = null;
          this._worker = null;
          this.docId = "d".concat((_docId._ = (_PDFDocumentLoadingTa = _docId._, _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa), _PDFDocumentLoadingTa2));
          this.destroyed = false;
          this.onPassword = null;
          this.onProgress = null;
        }
        return _createClass(PDFDocumentLoadingTask, [{
          key: "promise",
          get: function get() {
            return this._capability.promise;
          }
        }, {
          key: "destroy",
          value: function () {
            var _destroy = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              var _this$_worker, _this$_transport, _this$_worker2;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    this.destroyed = true;
                    _context.prev = 1;
                    if ((_this$_worker = this._worker) !== null && _this$_worker !== void 0 && _this$_worker.port) {
                      this._worker._pendingDestroy = true;
                    }
                    _context.next = 5;
                    return (_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();
                  case 5:
                    _context.next = 11;
                    break;
                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](1);
                    if ((_this$_worker2 = this._worker) !== null && _this$_worker2 !== void 0 && _this$_worker2.port) {
                      delete this._worker._pendingDestroy;
                    }
                    throw _context.t0;
                  case 11:
                    this._transport = null;
                    if (this._worker) {
                      this._worker.destroy();
                      this._worker = null;
                    }
                  case 13:
                  case "end":
                    return _context.stop();
                }
              }, _callee, this, [[1, 7]]);
            }));
            function destroy() {
              return _destroy.apply(this, arguments);
            }
            return destroy;
          }()
        }]);
      }();
      var _docId = {
        _: 0
      };
      exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
      var PDFDataRangeTransport = /*#__PURE__*/function () {
        function PDFDataRangeTransport(length, initialData) {
          var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          _classCallCheck(this, PDFDataRangeTransport);
          this.length = length;
          this.initialData = initialData;
          this.progressiveDone = progressiveDone;
          this.contentDispositionFilename = contentDispositionFilename;
          this._rangeListeners = [];
          this._progressListeners = [];
          this._progressiveReadListeners = [];
          this._progressiveDoneListeners = [];
          this._readyCapability = new _util.PromiseCapability();
        }
        return _createClass(PDFDataRangeTransport, [{
          key: "addRangeListener",
          value: function addRangeListener(listener) {
            this._rangeListeners.push(listener);
          }
        }, {
          key: "addProgressListener",
          value: function addProgressListener(listener) {
            this._progressListeners.push(listener);
          }
        }, {
          key: "addProgressiveReadListener",
          value: function addProgressiveReadListener(listener) {
            this._progressiveReadListeners.push(listener);
          }
        }, {
          key: "addProgressiveDoneListener",
          value: function addProgressiveDoneListener(listener) {
            this._progressiveDoneListeners.push(listener);
          }
        }, {
          key: "onDataRange",
          value: function onDataRange(begin, chunk) {
            var _iterator2 = _createForOfIteratorHelper(this._rangeListeners),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var listener = _step2.value;
                listener(begin, chunk);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }, {
          key: "onDataProgress",
          value: function onDataProgress(loaded, total) {
            var _this5 = this;
            this._readyCapability.promise.then(function () {
              var _iterator3 = _createForOfIteratorHelper(_this5._progressListeners),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var listener = _step3.value;
                  listener(loaded, total);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            });
          }
        }, {
          key: "onDataProgressiveRead",
          value: function onDataProgressiveRead(chunk) {
            var _this6 = this;
            this._readyCapability.promise.then(function () {
              var _iterator4 = _createForOfIteratorHelper(_this6._progressiveReadListeners),
                _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var listener = _step4.value;
                  listener(chunk);
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            });
          }
        }, {
          key: "onDataProgressiveDone",
          value: function onDataProgressiveDone() {
            var _this7 = this;
            this._readyCapability.promise.then(function () {
              var _iterator5 = _createForOfIteratorHelper(_this7._progressiveDoneListeners),
                _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var listener = _step5.value;
                  listener();
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            });
          }
        }, {
          key: "transportReady",
          value: function transportReady() {
            this._readyCapability.resolve();
          }
        }, {
          key: "requestDataRange",
          value: function requestDataRange(begin, end) {
            (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
          }
        }, {
          key: "abort",
          value: function abort() {}
        }]);
      }();
      exports.PDFDataRangeTransport = PDFDataRangeTransport;
      var PDFDocumentProxy = /*#__PURE__*/function () {
        function PDFDocumentProxy(pdfInfo, transport) {
          var _this8 = this;
          _classCallCheck(this, PDFDocumentProxy);
          this._pdfInfo = pdfInfo;
          this._transport = transport;
          Object.defineProperty(this, "getJavaScript", {
            value: function value() {
              (0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, " + "please use `PDFDocumentProxy.getJSActions` instead.");
              return _this8.getJSActions().then(function (js) {
                if (!js) {
                  return js;
                }
                var jsArr = [];
                for (var name in js) {
                  jsArr.push.apply(jsArr, _toConsumableArray(js[name]));
                }
                return jsArr;
              });
            }
          });
        }
        return _createClass(PDFDocumentProxy, [{
          key: "annotationStorage",
          get: function get() {
            return this._transport.annotationStorage;
          }
        }, {
          key: "filterFactory",
          get: function get() {
            return this._transport.filterFactory;
          }
        }, {
          key: "numPages",
          get: function get() {
            return this._pdfInfo.numPages;
          }
        }, {
          key: "fingerprints",
          get: function get() {
            return this._pdfInfo.fingerprints;
          }
        }, {
          key: "isPureXfa",
          get: function get() {
            return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
          }
        }, {
          key: "allXfaHtml",
          get: function get() {
            return this._transport._htmlForXfa;
          }
        }, {
          key: "getPage",
          value: function getPage(pageNumber) {
            return this._transport.getPage(pageNumber);
          }
        }, {
          key: "getPageIndex",
          value: function getPageIndex(ref) {
            return this._transport.getPageIndex(ref);
          }
        }, {
          key: "getDestinations",
          value: function getDestinations() {
            return this._transport.getDestinations();
          }
        }, {
          key: "getDestination",
          value: function getDestination(id) {
            return this._transport.getDestination(id);
          }
        }, {
          key: "getPageLabels",
          value: function getPageLabels() {
            return this._transport.getPageLabels();
          }
        }, {
          key: "getPageLayout",
          value: function getPageLayout() {
            return this._transport.getPageLayout();
          }
        }, {
          key: "getPageMode",
          value: function getPageMode() {
            return this._transport.getPageMode();
          }
        }, {
          key: "getViewerPreferences",
          value: function getViewerPreferences() {
            return this._transport.getViewerPreferences();
          }
        }, {
          key: "getOpenAction",
          value: function getOpenAction() {
            return this._transport.getOpenAction();
          }
        }, {
          key: "getAttachments",
          value: function getAttachments() {
            return this._transport.getAttachments();
          }
        }, {
          key: "getJSActions",
          value: function getJSActions() {
            return this._transport.getDocJSActions();
          }
        }, {
          key: "getOutline",
          value: function getOutline() {
            return this._transport.getOutline();
          }
        }, {
          key: "getOptionalContentConfig",
          value: function getOptionalContentConfig() {
            return this._transport.getOptionalContentConfig();
          }
        }, {
          key: "getPermissions",
          value: function getPermissions() {
            return this._transport.getPermissions();
          }
        }, {
          key: "getMetadata",
          value: function getMetadata() {
            return this._transport.getMetadata();
          }
        }, {
          key: "getMarkInfo",
          value: function getMarkInfo() {
            return this._transport.getMarkInfo();
          }
        }, {
          key: "getData",
          value: function getData() {
            return this._transport.getData();
          }
        }, {
          key: "saveDocument",
          value: function saveDocument() {
            return this._transport.saveDocument();
          }
        }, {
          key: "getDownloadInfo",
          value: function getDownloadInfo() {
            return this._transport.downloadInfoCapability.promise;
          }
        }, {
          key: "cleanup",
          value: function cleanup() {
            var keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            return this.loadingTask.destroy();
          }
        }, {
          key: "loadingParams",
          get: function get() {
            return this._transport.loadingParams;
          }
        }, {
          key: "loadingTask",
          get: function get() {
            return this._transport.loadingTask;
          }
        }, {
          key: "getFieldObjects",
          value: function getFieldObjects() {
            return this._transport.getFieldObjects();
          }
        }, {
          key: "hasJSActions",
          value: function hasJSActions() {
            return this._transport.hasJSActions();
          }
        }, {
          key: "getCalculationOrderIds",
          value: function getCalculationOrderIds() {
            return this._transport.getCalculationOrderIds();
          }
        }]);
      }();
      exports.PDFDocumentProxy = PDFDocumentProxy;
      var _delayedCleanupTimeout = /*#__PURE__*/new WeakMap();
      var _pendingCleanup = /*#__PURE__*/new WeakMap();
      var _PDFPageProxy_brand = /*#__PURE__*/new WeakSet();
      var PDFPageProxy = /*#__PURE__*/function () {
        function PDFPageProxy(pageIndex, pageInfo, transport) {
          var pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          _classCallCheck(this, PDFPageProxy);
          _classPrivateMethodInitSpec(this, _PDFPageProxy_brand);
          _classPrivateFieldInitSpec(this, _delayedCleanupTimeout, null);
          _classPrivateFieldInitSpec(this, _pendingCleanup, false);
          this._pageIndex = pageIndex;
          this._pageInfo = pageInfo;
          this._transport = transport;
          this._stats = pdfBug ? new _display_utils.StatTimer() : null;
          this._pdfBug = pdfBug;
          this.commonObjs = transport.commonObjs;
          this.objs = new PDFObjects();
          this._maybeCleanupAfterRender = false;
          this._intentStates = new Map();
          this.destroyed = false;
        }
        return _createClass(PDFPageProxy, [{
          key: "pageNumber",
          get: function get() {
            return this._pageIndex + 1;
          }
        }, {
          key: "rotate",
          get: function get() {
            return this._pageInfo.rotate;
          }
        }, {
          key: "ref",
          get: function get() {
            return this._pageInfo.ref;
          }
        }, {
          key: "userUnit",
          get: function get() {
            return this._pageInfo.userUnit;
          }
        }, {
          key: "view",
          get: function get() {
            return this._pageInfo.view;
          }
        }, {
          key: "getViewport",
          value: function getViewport() {
            var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              scale = _ref3.scale,
              _ref3$rotation = _ref3.rotation,
              rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation,
              _ref3$offsetX = _ref3.offsetX,
              offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,
              _ref3$offsetY = _ref3.offsetY,
              offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,
              _ref3$dontFlip = _ref3.dontFlip,
              dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;
            return new _display_utils.PageViewport({
              viewBox: this.view,
              scale: scale,
              rotation: rotation,
              offsetX: offsetX,
              offsetY: offsetY,
              dontFlip: dontFlip
            });
          }
        }, {
          key: "getAnnotations",
          value: function getAnnotations() {
            var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref4$intent = _ref4.intent,
              intent = _ref4$intent === void 0 ? "display" : _ref4$intent;
            var intentArgs = this._transport.getRenderingIntent(intent);
            return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
          }
        }, {
          key: "getJSActions",
          value: function getJSActions() {
            return this._transport.getPageJSActions(this._pageIndex);
          }
        }, {
          key: "filterFactory",
          get: function get() {
            return this._transport.filterFactory;
          }
        }, {
          key: "isPureXfa",
          get: function get() {
            return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
          }
        }, {
          key: "getXfa",
          value: function () {
            var _getXfa = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
              var _this$_transport$_htm;
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null);
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, this);
            }));
            function getXfa() {
              return _getXfa.apply(this, arguments);
            }
            return getXfa;
          }()
        }, {
          key: "render",
          value: function render(_ref5) {
            var _this$_stats,
              _this9 = this,
              _intentState;
            var canvasContext = _ref5.canvasContext,
              viewport = _ref5.viewport,
              _ref5$intent = _ref5.intent,
              intent = _ref5$intent === void 0 ? "display" : _ref5$intent,
              _ref5$annotationMode = _ref5.annotationMode,
              annotationMode = _ref5$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref5$annotationMode,
              _ref5$transform = _ref5.transform,
              transform = _ref5$transform === void 0 ? null : _ref5$transform,
              _ref5$background = _ref5.background,
              background = _ref5$background === void 0 ? null : _ref5$background,
              _ref5$optionalContent = _ref5.optionalContentConfigPromise,
              optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent,
              _ref5$annotationCanva = _ref5.annotationCanvasMap,
              annotationCanvasMap = _ref5$annotationCanva === void 0 ? null : _ref5$annotationCanva,
              _ref5$pageColors = _ref5.pageColors,
              pageColors = _ref5$pageColors === void 0 ? null : _ref5$pageColors,
              _ref5$printAnnotation = _ref5.printAnnotationStorage,
              printAnnotationStorage = _ref5$printAnnotation === void 0 ? null : _ref5$printAnnotation;
            (_this$_stats = this._stats) === null || _this$_stats === void 0 || _this$_stats.time("Overall");
            var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
            _classPrivateFieldSet(_pendingCleanup, this, false);
            _assertClassBrand(_PDFPageProxy_brand, this, _abortDelayedCleanup).call(this);
            if (!optionalContentConfigPromise) {
              optionalContentConfigPromise = this._transport.getOptionalContentConfig();
            }
            var intentState = this._intentStates.get(intentArgs.cacheKey);
            if (!intentState) {
              intentState = Object.create(null);
              this._intentStates.set(intentArgs.cacheKey, intentState);
            }
            if (intentState.streamReaderCancelTimeout) {
              clearTimeout(intentState.streamReaderCancelTimeout);
              intentState.streamReaderCancelTimeout = null;
            }
            var intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
            if (!intentState.displayReadyCapability) {
              var _this$_stats2;
              intentState.displayReadyCapability = new _util.PromiseCapability();
              intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false,
                separateAnnots: null
              };
              (_this$_stats2 = this._stats) === null || _this$_stats2 === void 0 || _this$_stats2.time("Page Request");
              this._pumpOperatorList(intentArgs);
            }
            var complete = function complete(error) {
              var _this9$_stats, _this9$_stats2;
              intentState.renderTasks.delete(internalRenderTask);
              if (_this9._maybeCleanupAfterRender || intentPrint) {
                _classPrivateFieldSet(_pendingCleanup, _this9, true);
              }
              _assertClassBrand(_PDFPageProxy_brand, _this9, _tryCleanup).call(_this9, !intentPrint);
              if (error) {
                internalRenderTask.capability.reject(error);
                _this9._abortOperatorList({
                  intentState: intentState,
                  reason: error instanceof Error ? error : new Error(error)
                });
              } else {
                internalRenderTask.capability.resolve();
              }
              (_this9$_stats = _this9._stats) === null || _this9$_stats === void 0 || _this9$_stats.timeEnd("Rendering");
              (_this9$_stats2 = _this9._stats) === null || _this9$_stats2 === void 0 || _this9$_stats2.timeEnd("Overall");
            };
            var internalRenderTask = new InternalRenderTask({
              callback: complete,
              params: {
                canvasContext: canvasContext,
                viewport: viewport,
                transform: transform,
                background: background
              },
              objs: this.objs,
              commonObjs: this.commonObjs,
              annotationCanvasMap: annotationCanvasMap,
              operatorList: intentState.operatorList,
              pageIndex: this._pageIndex,
              canvasFactory: this._transport.canvasFactory,
              filterFactory: this._transport.filterFactory,
              useRequestAnimationFrame: !intentPrint,
              pdfBug: this._pdfBug,
              pageColors: pageColors
            });
            ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
            var renderTask = internalRenderTask.task;
            Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function (_ref6) {
              var _this9$_stats3;
              var _ref7 = _slicedToArray(_ref6, 2),
                transparency = _ref7[0],
                optionalContentConfig = _ref7[1];
              if (_this9.destroyed) {
                complete();
                return;
              }
              (_this9$_stats3 = _this9._stats) === null || _this9$_stats3 === void 0 || _this9$_stats3.time("Rendering");
              internalRenderTask.initializeGraphics({
                transparency: transparency,
                optionalContentConfig: optionalContentConfig
              });
              internalRenderTask.operatorListChanged();
            }).catch(complete);
            return renderTask;
          }
        }, {
          key: "getOperatorList",
          value: function getOperatorList() {
            var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref8$intent = _ref8.intent,
              intent = _ref8$intent === void 0 ? "display" : _ref8$intent,
              _ref8$annotationMode = _ref8.annotationMode,
              annotationMode = _ref8$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref8$annotationMode,
              _ref8$printAnnotation = _ref8.printAnnotationStorage,
              printAnnotationStorage = _ref8$printAnnotation === void 0 ? null : _ref8$printAnnotation;
            function operatorListChanged() {
              if (intentState.operatorList.lastChunk) {
                intentState.opListReadCapability.resolve(intentState.operatorList);
                intentState.renderTasks.delete(opListTask);
              }
            }
            var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
            var intentState = this._intentStates.get(intentArgs.cacheKey);
            if (!intentState) {
              intentState = Object.create(null);
              this._intentStates.set(intentArgs.cacheKey, intentState);
            }
            var opListTask;
            if (!intentState.opListReadCapability) {
              var _intentState2, _this$_stats3;
              opListTask = Object.create(null);
              opListTask.operatorListChanged = operatorListChanged;
              intentState.opListReadCapability = new _util.PromiseCapability();
              ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
              intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false,
                separateAnnots: null
              };
              (_this$_stats3 = this._stats) === null || _this$_stats3 === void 0 || _this$_stats3.time("Page Request");
              this._pumpOperatorList(intentArgs);
            }
            return intentState.opListReadCapability.promise;
          }
        }, {
          key: "streamTextContent",
          value: function streamTextContent() {
            var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref9$includeMarkedCo = _ref9.includeMarkedContent,
              includeMarkedContent = _ref9$includeMarkedCo === void 0 ? false : _ref9$includeMarkedCo,
              _ref9$disableNormaliz = _ref9.disableNormalization,
              disableNormalization = _ref9$disableNormaliz === void 0 ? false : _ref9$disableNormaliz;
            var TEXT_CONTENT_CHUNK_SIZE = 100;
            return this._transport.messageHandler.sendWithStream("GetTextContent", {
              pageIndex: this._pageIndex,
              includeMarkedContent: includeMarkedContent === true,
              disableNormalization: disableNormalization === true
            }, {
              highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
              size: function size(textContent) {
                return textContent.items.length;
              }
            });
          }
        }, {
          key: "getTextContent",
          value: function getTextContent() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (this._transport._htmlForXfa) {
              return this.getXfa().then(function (xfa) {
                return _xfa_text.XfaText.textContent(xfa);
              });
            }
            var readableStream = this.streamTextContent(params);
            return new Promise(function (resolve, reject) {
              function pump() {
                reader.read().then(function (_ref10) {
                  var _textContent$items;
                  var value = _ref10.value,
                    done = _ref10.done;
                  if (done) {
                    resolve(textContent);
                    return;
                  }
                  Object.assign(textContent.styles, value.styles);
                  (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));
                  pump();
                }, reject);
              }
              var reader = readableStream.getReader();
              var textContent = {
                items: [],
                styles: Object.create(null)
              };
              pump();
            });
          }
        }, {
          key: "getStructTree",
          value: function getStructTree() {
            return this._transport.getStructTree(this._pageIndex);
          }
        }, {
          key: "_destroy",
          value: function _destroy() {
            this.destroyed = true;
            var waitOn = [];
            var _iterator6 = _createForOfIteratorHelper(this._intentStates.values()),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var intentState = _step6.value;
                this._abortOperatorList({
                  intentState: intentState,
                  reason: new Error("Page was destroyed."),
                  force: true
                });
                if (intentState.opListReadCapability) {
                  continue;
                }
                var _iterator7 = _createForOfIteratorHelper(intentState.renderTasks),
                  _step7;
                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    var internalRenderTask = _step7.value;
                    waitOn.push(internalRenderTask.completed);
                    internalRenderTask.cancel();
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            this.objs.clear();
            _classPrivateFieldSet(_pendingCleanup, this, false);
            _assertClassBrand(_PDFPageProxy_brand, this, _abortDelayedCleanup).call(this);
            return Promise.all(waitOn);
          }
        }, {
          key: "cleanup",
          value: function cleanup() {
            var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            _classPrivateFieldSet(_pendingCleanup, this, true);
            var success = _assertClassBrand(_PDFPageProxy_brand, this, _tryCleanup).call(this, false);
            if (resetStats && success) {
              this._stats && (this._stats = new _display_utils.StatTimer());
            }
            return success;
          }
        }, {
          key: "_startRenderPage",
          value: function _startRenderPage(transparency, cacheKey) {
            var _this$_stats4, _intentState$displayR;
            var intentState = this._intentStates.get(cacheKey);
            if (!intentState) {
              return;
            }
            (_this$_stats4 = this._stats) === null || _this$_stats4 === void 0 || _this$_stats4.timeEnd("Page Request");
            (_intentState$displayR = intentState.displayReadyCapability) === null || _intentState$displayR === void 0 || _intentState$displayR.resolve(transparency);
          }
        }, {
          key: "_renderPageChunk",
          value: function _renderPageChunk(operatorListChunk, intentState) {
            for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
              intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
              intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
            }
            intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
            intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
            var _iterator8 = _createForOfIteratorHelper(intentState.renderTasks),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var internalRenderTask = _step8.value;
                internalRenderTask.operatorListChanged();
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            if (operatorListChunk.lastChunk) {
              _assertClassBrand(_PDFPageProxy_brand, this, _tryCleanup).call(this, true);
            }
          }
        }, {
          key: "_pumpOperatorList",
          value: function _pumpOperatorList(_ref11) {
            var _this10 = this;
            var renderingIntent = _ref11.renderingIntent,
              cacheKey = _ref11.cacheKey,
              annotationStorageSerializable = _ref11.annotationStorageSerializable;
            var map = annotationStorageSerializable.map,
              transfers = annotationStorageSerializable.transfers;
            var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
              pageIndex: this._pageIndex,
              intent: renderingIntent,
              cacheKey: cacheKey,
              annotationStorage: map
            }, transfers);
            var reader = readableStream.getReader();
            var intentState = this._intentStates.get(cacheKey);
            intentState.streamReader = reader;
            var _pump = function pump() {
              reader.read().then(function (_ref12) {
                var value = _ref12.value,
                  done = _ref12.done;
                if (done) {
                  intentState.streamReader = null;
                  return;
                }
                if (_this10._transport.destroyed) {
                  return;
                }
                _this10._renderPageChunk(value, intentState);
                _pump();
              }, function (reason) {
                intentState.streamReader = null;
                if (_this10._transport.destroyed) {
                  return;
                }
                if (intentState.operatorList) {
                  intentState.operatorList.lastChunk = true;
                  var _iterator9 = _createForOfIteratorHelper(intentState.renderTasks),
                    _step9;
                  try {
                    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                      var internalRenderTask = _step9.value;
                      internalRenderTask.operatorListChanged();
                    }
                  } catch (err) {
                    _iterator9.e(err);
                  } finally {
                    _iterator9.f();
                  }
                  _assertClassBrand(_PDFPageProxy_brand, _this10, _tryCleanup).call(_this10, true);
                }
                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.reject(reason);
                } else if (intentState.opListReadCapability) {
                  intentState.opListReadCapability.reject(reason);
                } else {
                  throw reason;
                }
              });
            };
            _pump();
          }
        }, {
          key: "_abortOperatorList",
          value: function _abortOperatorList(_ref13) {
            var _this11 = this;
            var intentState = _ref13.intentState,
              reason = _ref13.reason,
              _ref13$force = _ref13.force,
              force = _ref13$force === void 0 ? false : _ref13$force;
            if (!intentState.streamReader) {
              return;
            }
            if (intentState.streamReaderCancelTimeout) {
              clearTimeout(intentState.streamReaderCancelTimeout);
              intentState.streamReaderCancelTimeout = null;
            }
            if (!force) {
              if (intentState.renderTasks.size > 0) {
                return;
              }
              if (reason instanceof _display_utils.RenderingCancelledException) {
                var delay = RENDERING_CANCELLED_TIMEOUT;
                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {
                  delay += reason.extraDelay;
                }
                intentState.streamReaderCancelTimeout = setTimeout(function () {
                  intentState.streamReaderCancelTimeout = null;
                  _this11._abortOperatorList({
                    intentState: intentState,
                    reason: reason,
                    force: true
                  });
                }, delay);
                return;
              }
            }
            intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(function () {});
            intentState.streamReader = null;
            if (this._transport.destroyed) {
              return;
            }
            var _iterator10 = _createForOfIteratorHelper(this._intentStates),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _step10$value = _slicedToArray(_step10.value, 2),
                  curCacheKey = _step10$value[0],
                  curIntentState = _step10$value[1];
                if (curIntentState === intentState) {
                  this._intentStates.delete(curCacheKey);
                  break;
                }
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            this.cleanup();
          }
        }, {
          key: "stats",
          get: function get() {
            return this._stats;
          }
        }]);
      }();
      function _tryCleanup() {
        var _this22 = this;
        var delayed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        _assertClassBrand(_PDFPageProxy_brand, this, _abortDelayedCleanup).call(this);
        if (!_classPrivateFieldGet(_pendingCleanup, this) || this.destroyed) {
          return false;
        }
        if (delayed) {
          _classPrivateFieldSet(_delayedCleanupTimeout, this, setTimeout(function () {
            _classPrivateFieldSet(_delayedCleanupTimeout, _this22, null);
            _assertClassBrand(_PDFPageProxy_brand, _this22, _tryCleanup).call(_this22, false);
          }, DELAYED_CLEANUP_TIMEOUT));
          return false;
        }
        var _iterator14 = _createForOfIteratorHelper(this._intentStates.values()),
          _step14;
        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            var _step14$value = _step14.value,
              renderTasks = _step14$value.renderTasks,
              operatorList = _step14$value.operatorList;
            if (renderTasks.size > 0 || !operatorList.lastChunk) {
              return false;
            }
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
        this._intentStates.clear();
        this.objs.clear();
        _classPrivateFieldSet(_pendingCleanup, this, false);
        return true;
      }
      function _abortDelayedCleanup() {
        if (_classPrivateFieldGet(_delayedCleanupTimeout, this)) {
          clearTimeout(_classPrivateFieldGet(_delayedCleanupTimeout, this));
          _classPrivateFieldSet(_delayedCleanupTimeout, this, null);
        }
      }
      exports.PDFPageProxy = PDFPageProxy;
      var _listeners = /*#__PURE__*/new WeakMap();
      var _deferred = /*#__PURE__*/new WeakMap();
      var LoopbackPort = /*#__PURE__*/function () {
        function LoopbackPort() {
          _classCallCheck(this, LoopbackPort);
          _classPrivateFieldInitSpec(this, _listeners, new Set());
          _classPrivateFieldInitSpec(this, _deferred, Promise.resolve());
        }
        return _createClass(LoopbackPort, [{
          key: "postMessage",
          value: function postMessage(obj, transfer) {
            var _this12 = this;
            var event = {
              data: structuredClone(obj, transfer ? {
                transfer: transfer
              } : null)
            };
            _classPrivateFieldGet(_deferred, this).then(function () {
              var _iterator11 = _createForOfIteratorHelper(_classPrivateFieldGet(_listeners, _this12)),
                _step11;
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  var listener = _step11.value;
                  listener.call(_this12, event);
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
            });
          }
        }, {
          key: "addEventListener",
          value: function addEventListener(name, listener) {
            _classPrivateFieldGet(_listeners, this).add(listener);
          }
        }, {
          key: "removeEventListener",
          value: function removeEventListener(name, listener) {
            _classPrivateFieldGet(_listeners, this).delete(listener);
          }
        }, {
          key: "terminate",
          value: function terminate() {
            _classPrivateFieldGet(_listeners, this).clear();
          }
        }]);
      }();
      exports.LoopbackPort = LoopbackPort;
      var PDFWorkerUtil = {
        isWorkerDisabled: false,
        fallbackWorkerSrc: null,
        fakeWorkerId: 0
      };
      exports.PDFWorkerUtil = PDFWorkerUtil;
      {
        if (_util.isNodeJS && typeof require === "function") {
          PDFWorkerUtil.isWorkerDisabled = true;
          PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
        } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object") {
          var _document;
          var pdfjsFilePath = (_document = document) === null || _document === void 0 || (_document = _document.currentScript) === null || _document === void 0 ? void 0 : _document.src;
          if (pdfjsFilePath) {
            PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
          }
        }
        PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
          var base;
          try {
            base = new URL(baseUrl);
            if (!base.origin || base.origin === "null") {
              return false;
            }
          } catch (_unused5) {
            return false;
          }
          var other = new URL(otherUrl, base);
          return base.origin === other.origin;
        };
        PDFWorkerUtil.createCDNWrapper = function (url) {
          var wrapper = "importScripts(\"".concat(url, "\");");
          return URL.createObjectURL(new Blob([wrapper]));
        };
      }
      var PDFWorker = /*#__PURE__*/function () {
        function PDFWorker() {
          var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref14$name = _ref14.name,
            name = _ref14$name === void 0 ? null : _ref14$name,
            _ref14$port = _ref14.port,
            port = _ref14$port === void 0 ? null : _ref14$port,
            _ref14$verbosity = _ref14.verbosity,
            verbosity = _ref14$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref14$verbosity;
          _classCallCheck(this, PDFWorker);
          this.name = name;
          this.destroyed = false;
          this.verbosity = verbosity;
          this._readyCapability = new _util.PromiseCapability();
          this._port = null;
          this._webWorker = null;
          this._messageHandler = null;
          if (port) {
            var _workerPorts$_;
            if ((_workerPorts$_ = _workerPorts._) !== null && _workerPorts$_ !== void 0 && _workerPorts$_.has(port)) {
              throw new Error("Cannot use more than one PDFWorker per port.");
            }
            (_workerPorts._ || (_workerPorts._ = new WeakMap())).set(port, this);
            this._initializeFromPort(port);
            return;
          }
          this._initialize();
        }
        return _createClass(PDFWorker, [{
          key: "promise",
          get: function get() {
            return this._readyCapability.promise;
          }
        }, {
          key: "port",
          get: function get() {
            return this._port;
          }
        }, {
          key: "messageHandler",
          get: function get() {
            return this._messageHandler;
          }
        }, {
          key: "_initializeFromPort",
          value: function _initializeFromPort(port) {
            this._port = port;
            this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
            this._messageHandler.on("ready", function () {});
            this._readyCapability.resolve();
            this._messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          }
        }, {
          key: "_initialize",
          value: function _initialize() {
            var _this13 = this;
            if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
              var workerSrc = PDFWorker.workerSrc;
              try {
                if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                  workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                }
                var worker = new Worker(workerSrc);
                var messageHandler = new _message_handler.MessageHandler("main", "worker", worker);
                var terminateEarly = function terminateEarly() {
                  worker.removeEventListener("error", onWorkerError);
                  messageHandler.destroy();
                  worker.terminate();
                  if (_this13.destroyed) {
                    _this13._readyCapability.reject(new Error("Worker was destroyed"));
                  } else {
                    _this13._setupFakeWorker();
                  }
                };
                var onWorkerError = function onWorkerError() {
                  if (!_this13._webWorker) {
                    terminateEarly();
                  }
                };
                worker.addEventListener("error", onWorkerError);
                messageHandler.on("test", function (data) {
                  worker.removeEventListener("error", onWorkerError);
                  if (_this13.destroyed) {
                    terminateEarly();
                    return;
                  }
                  if (data) {
                    _this13._messageHandler = messageHandler;
                    _this13._port = worker;
                    _this13._webWorker = worker;
                    _this13._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: _this13.verbosity
                    });
                  } else {
                    _this13._setupFakeWorker();
                    messageHandler.destroy();
                    worker.terminate();
                  }
                });
                messageHandler.on("ready", function (data) {
                  worker.removeEventListener("error", onWorkerError);
                  if (_this13.destroyed) {
                    terminateEarly();
                    return;
                  }
                  try {
                    sendTest();
                  } catch (_unused6) {
                    _this13._setupFakeWorker();
                  }
                });
                var sendTest = function sendTest() {
                  var testObj = new Uint8Array();
                  messageHandler.send("test", testObj, [testObj.buffer]);
                };
                sendTest();
                return;
              } catch (_unused7) {
                (0, _util.info)("The worker has been disabled.");
              }
            }
            this._setupFakeWorker();
          }
        }, {
          key: "_setupFakeWorker",
          value: function _setupFakeWorker() {
            var _this14 = this;
            if (!PDFWorkerUtil.isWorkerDisabled) {
              (0, _util.warn)("Setting up fake worker.");
              PDFWorkerUtil.isWorkerDisabled = true;
            }
            PDFWorker._setupFakeWorkerGlobal.then(function (WorkerMessageHandler) {
              if (_this14.destroyed) {
                _this14._readyCapability.reject(new Error("Worker was destroyed"));
                return;
              }
              var port = new LoopbackPort();
              _this14._port = port;
              var id = "fake".concat(PDFWorkerUtil.fakeWorkerId++);
              var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
              WorkerMessageHandler.setup(workerHandler, port);
              var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
              _this14._messageHandler = messageHandler;
              _this14._readyCapability.resolve();
              messageHandler.send("configure", {
                verbosity: _this14.verbosity
              });
            }).catch(function (reason) {
              _this14._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\".")));
            });
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var _workerPorts$_2;
            this.destroyed = true;
            if (this._webWorker) {
              this._webWorker.terminate();
              this._webWorker = null;
            }
            (_workerPorts$_2 = _workerPorts._) === null || _workerPorts$_2 === void 0 || _workerPorts$_2.delete(this._port);
            this._port = null;
            if (this._messageHandler) {
              this._messageHandler.destroy();
              this._messageHandler = null;
            }
          }
        }], [{
          key: "fromPort",
          value: function fromPort(params) {
            var _assertClassBrand$_;
            if (!(params !== null && params !== void 0 && params.port)) {
              throw new Error("PDFWorker.fromPort - invalid method signature.");
            }
            var cachedPort = (_assertClassBrand$_ = _assertClassBrand(PDFWorker, this, _workerPorts)._) === null || _assertClassBrand$_ === void 0 ? void 0 : _assertClassBrand$_.get(params.port);
            if (cachedPort) {
              if (cachedPort._pendingDestroy) {
                throw new Error("PDFWorker.fromPort - the worker is being destroyed.\n" + "Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
              }
              return cachedPort;
            }
            return new PDFWorker(params);
          }
        }, {
          key: "workerSrc",
          get: function get() {
            if (_worker_options.GlobalWorkerOptions.workerSrc) {
              return _worker_options.GlobalWorkerOptions.workerSrc;
            }
            if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
              if (!_util.isNodeJS) {
                (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              return PDFWorkerUtil.fallbackWorkerSrc;
            }
            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
          }
        }, {
          key: "_mainThreadWorkerMessageHandler",
          get: function get() {
            try {
              var _globalThis$pdfjsWork;
              return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
            } catch (_unused8) {
              return null;
            }
          }
        }, {
          key: "_setupFakeWorkerGlobal",
          get: function get() {
            var _this15 = this;
            var loader = /*#__PURE__*/function () {
              var _ref15 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                var mainWorkerMessageHandler, worker;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      mainWorkerMessageHandler = _this15._mainThreadWorkerMessageHandler;
                      if (!mainWorkerMessageHandler) {
                        _context3.next = 3;
                        break;
                      }
                      return _context3.abrupt("return", mainWorkerMessageHandler);
                    case 3:
                      if (!(_util.isNodeJS && typeof require === "function")) {
                        _context3.next = 6;
                        break;
                      }
                      worker = eval("require")(_this15.workerSrc);
                      return _context3.abrupt("return", worker.WorkerMessageHandler);
                    case 6:
                      _context3.next = 8;
                      return (0, _display_utils.loadScript)(_this15.workerSrc);
                    case 8:
                      return _context3.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);
                    case 9:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }));
              return function loader() {
                return _ref15.apply(this, arguments);
              };
            }();
            return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
          }
        }]);
      }();
      var _workerPorts = {
        _: void 0
      };
      exports.PDFWorker = PDFWorker;
      var _methodPromises = /*#__PURE__*/new WeakMap();
      var _pageCache = /*#__PURE__*/new WeakMap();
      var _pagePromises = /*#__PURE__*/new WeakMap();
      var _passwordCapability = /*#__PURE__*/new WeakMap();
      var _WorkerTransport_brand = /*#__PURE__*/new WeakSet();
      var WorkerTransport = /*#__PURE__*/function () {
        function WorkerTransport(messageHandler, loadingTask, networkStream, params, factory) {
          _classCallCheck(this, WorkerTransport);
          _classPrivateMethodInitSpec(this, _WorkerTransport_brand);
          _classPrivateFieldInitSpec(this, _methodPromises, new Map());
          _classPrivateFieldInitSpec(this, _pageCache, new Map());
          _classPrivateFieldInitSpec(this, _pagePromises, new Map());
          _classPrivateFieldInitSpec(this, _passwordCapability, null);
          this.messageHandler = messageHandler;
          this.loadingTask = loadingTask;
          this.commonObjs = new PDFObjects();
          this.fontLoader = new _font_loader.FontLoader({
            ownerDocument: params.ownerDocument,
            styleElement: params.styleElement
          });
          this._params = params;
          this.canvasFactory = factory.canvasFactory;
          this.filterFactory = factory.filterFactory;
          this.cMapReaderFactory = factory.cMapReaderFactory;
          this.standardFontDataFactory = factory.standardFontDataFactory;
          this.destroyed = false;
          this.destroyCapability = null;
          this._networkStream = networkStream;
          this._fullReader = null;
          this._lastProgress = null;
          this.downloadInfoCapability = new _util.PromiseCapability();
          this.setupMessageHandler();
        }
        return _createClass(WorkerTransport, [{
          key: "annotationStorage",
          get: function get() {
            return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
          }
        }, {
          key: "getRenderingIntent",
          value: function getRenderingIntent(intent) {
            var annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;
            var printAnnotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var isOpList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var renderingIntent = _util.RenderingIntentFlag.DISPLAY;
            var annotationStorageSerializable = _annotation_storage.SerializableEmpty;
            switch (intent) {
              case "any":
                renderingIntent = _util.RenderingIntentFlag.ANY;
                break;
              case "display":
                break;
              case "print":
                renderingIntent = _util.RenderingIntentFlag.PRINT;
                break;
              default:
                (0, _util.warn)("getRenderingIntent - invalid intent: ".concat(intent));
            }
            switch (annotationMode) {
              case _util.AnnotationMode.DISABLE:
                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                break;
              case _util.AnnotationMode.ENABLE:
                break;
              case _util.AnnotationMode.ENABLE_FORMS:
                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                break;
              case _util.AnnotationMode.ENABLE_STORAGE:
                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                var annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                annotationStorageSerializable = annotationStorage.serializable;
                break;
              default:
                (0, _util.warn)("getRenderingIntent - invalid annotationMode: ".concat(annotationMode));
            }
            if (isOpList) {
              renderingIntent += _util.RenderingIntentFlag.OPLIST;
            }
            return {
              renderingIntent: renderingIntent,
              cacheKey: "".concat(renderingIntent, "_").concat(annotationStorageSerializable.hash),
              annotationStorageSerializable: annotationStorageSerializable
            };
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var _classPrivateFieldGet2,
              _this16 = this;
            if (this.destroyCapability) {
              return this.destroyCapability.promise;
            }
            this.destroyed = true;
            this.destroyCapability = new _util.PromiseCapability();
            (_classPrivateFieldGet2 = _classPrivateFieldGet(_passwordCapability, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.reject(new Error("Worker was destroyed during onPassword callback"));
            var waitOn = [];
            var _iterator12 = _createForOfIteratorHelper(_classPrivateFieldGet(_pageCache, this).values()),
              _step12;
            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                var page = _step12.value;
                waitOn.push(page._destroy());
              }
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
            _classPrivateFieldGet(_pageCache, this).clear();
            _classPrivateFieldGet(_pagePromises, this).clear();
            if (this.hasOwnProperty("annotationStorage")) {
              this.annotationStorage.resetModified();
            }
            var terminated = this.messageHandler.sendWithPromise("Terminate", null);
            waitOn.push(terminated);
            Promise.all(waitOn).then(function () {
              var _this16$_networkStrea;
              _this16.commonObjs.clear();
              _this16.fontLoader.clear();
              _classPrivateFieldGet(_methodPromises, _this16).clear();
              _this16.filterFactory.destroy();
              (_this16$_networkStrea = _this16._networkStream) === null || _this16$_networkStrea === void 0 || _this16$_networkStrea.cancelAllRequests(new _util.AbortException("Worker was terminated."));
              if (_this16.messageHandler) {
                _this16.messageHandler.destroy();
                _this16.messageHandler = null;
              }
              _this16.destroyCapability.resolve();
            }, this.destroyCapability.reject);
            return this.destroyCapability.promise;
          }
        }, {
          key: "setupMessageHandler",
          value: function setupMessageHandler() {
            var _this17 = this;
            var messageHandler = this.messageHandler,
              loadingTask = this.loadingTask;
            messageHandler.on("GetReader", function (data, sink) {
              (0, _util.assert)(_this17._networkStream, "GetReader - no `IPDFStream` instance available.");
              _this17._fullReader = _this17._networkStream.getFullReader();
              _this17._fullReader.onProgress = function (evt) {
                _this17._lastProgress = {
                  loaded: evt.loaded,
                  total: evt.total
                };
              };
              sink.onPull = function () {
                _this17._fullReader.read().then(function (_ref16) {
                  var value = _ref16.value,
                    done = _ref16.done;
                  if (done) {
                    sink.close();
                    return;
                  }
                  (0, _util.assert)(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
                  sink.enqueue(new Uint8Array(value), 1, [value]);
                }).catch(function (reason) {
                  sink.error(reason);
                });
              };
              sink.onCancel = function (reason) {
                _this17._fullReader.cancel(reason);
                sink.ready.catch(function (readyReason) {
                  if (_this17.destroyed) {
                    return;
                  }
                  throw readyReason;
                });
              };
            });
            messageHandler.on("ReaderHeadersReady", function (data) {
              var headersCapability = new _util.PromiseCapability();
              var fullReader = _this17._fullReader;
              fullReader.headersReady.then(function () {
                if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                  if (_this17._lastProgress) {
                    var _loadingTask$onProgre;
                    (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 || _loadingTask$onProgre.call(loadingTask, _this17._lastProgress);
                  }
                  fullReader.onProgress = function (evt) {
                    var _loadingTask$onProgre2;
                    (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 || _loadingTask$onProgre2.call(loadingTask, {
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  };
                }
                headersCapability.resolve({
                  isStreamingSupported: fullReader.isStreamingSupported,
                  isRangeSupported: fullReader.isRangeSupported,
                  contentLength: fullReader.contentLength
                });
              }, headersCapability.reject);
              return headersCapability.promise;
            });
            messageHandler.on("GetRangeReader", function (data, sink) {
              (0, _util.assert)(_this17._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
              var rangeReader = _this17._networkStream.getRangeReader(data.begin, data.end);
              if (!rangeReader) {
                sink.close();
                return;
              }
              sink.onPull = function () {
                rangeReader.read().then(function (_ref17) {
                  var value = _ref17.value,
                    done = _ref17.done;
                  if (done) {
                    sink.close();
                    return;
                  }
                  (0, _util.assert)(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                  sink.enqueue(new Uint8Array(value), 1, [value]);
                }).catch(function (reason) {
                  sink.error(reason);
                });
              };
              sink.onCancel = function (reason) {
                rangeReader.cancel(reason);
                sink.ready.catch(function (readyReason) {
                  if (_this17.destroyed) {
                    return;
                  }
                  throw readyReason;
                });
              };
            });
            messageHandler.on("GetDoc", function (_ref18) {
              var pdfInfo = _ref18.pdfInfo;
              _this17._numPages = pdfInfo.numPages;
              _this17._htmlForXfa = pdfInfo.htmlForXfa;
              delete pdfInfo.htmlForXfa;
              loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this17));
            });
            messageHandler.on("DocException", function (ex) {
              var reason;
              switch (ex.name) {
                case "PasswordException":
                  reason = new _util.PasswordException(ex.message, ex.code);
                  break;
                case "InvalidPDFException":
                  reason = new _util.InvalidPDFException(ex.message);
                  break;
                case "MissingPDFException":
                  reason = new _util.MissingPDFException(ex.message);
                  break;
                case "UnexpectedResponseException":
                  reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                  break;
                case "UnknownErrorException":
                  reason = new _util.UnknownErrorException(ex.message, ex.details);
                  break;
                default:
                  (0, _util.unreachable)("DocException - expected a valid Error.");
              }
              loadingTask._capability.reject(reason);
            });
            messageHandler.on("PasswordRequest", function (exception) {
              _classPrivateFieldSet(_passwordCapability, _this17, new _util.PromiseCapability());
              if (loadingTask.onPassword) {
                var updatePassword = function updatePassword(password) {
                  if (password instanceof Error) {
                    _classPrivateFieldGet(_passwordCapability, _this17).reject(password);
                  } else {
                    _classPrivateFieldGet(_passwordCapability, _this17).resolve({
                      password: password
                    });
                  }
                };
                try {
                  loadingTask.onPassword(updatePassword, exception.code);
                } catch (ex) {
                  _classPrivateFieldGet(_passwordCapability, _this17).reject(ex);
                }
              } else {
                _classPrivateFieldGet(_passwordCapability, _this17).reject(new _util.PasswordException(exception.message, exception.code));
              }
              return _classPrivateFieldGet(_passwordCapability, _this17).promise;
            });
            messageHandler.on("DataLoaded", function (data) {
              var _loadingTask$onProgre3;
              (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 || _loadingTask$onProgre3.call(loadingTask, {
                loaded: data.length,
                total: data.length
              });
              _this17.downloadInfoCapability.resolve(data);
            });
            messageHandler.on("StartRenderPage", function (data) {
              if (_this17.destroyed) {
                return;
              }
              var page = _classPrivateFieldGet(_pageCache, _this17).get(data.pageIndex);
              page._startRenderPage(data.transparency, data.cacheKey);
            });
            messageHandler.on("commonobj", function (_ref19) {
              var _globalThis$FontInspe;
              var _ref20 = _slicedToArray(_ref19, 3),
                id = _ref20[0],
                type = _ref20[1],
                exportedData = _ref20[2];
              if (_this17.destroyed) {
                return;
              }
              if (_this17.commonObjs.has(id)) {
                return;
              }
              switch (type) {
                case "Font":
                  var params = _this17._params;
                  if ("error" in exportedData) {
                    var exportedError = exportedData.error;
                    (0, _util.warn)("Error during font loading: ".concat(exportedError));
                    _this17.commonObjs.resolve(id, exportedError);
                    break;
                  }
                  var inspectFont = params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled ? function (font, url) {
                    return globalThis.FontInspector.fontAdded(font, url);
                  } : null;
                  var font = new _font_loader.FontFaceObject(exportedData, {
                    isEvalSupported: params.isEvalSupported,
                    disableFontFace: params.disableFontFace,
                    ignoreErrors: params.ignoreErrors,
                    inspectFont: inspectFont
                  });
                  _this17.fontLoader.bind(font).catch(function (reason) {
                    return messageHandler.sendWithPromise("FontFallback", {
                      id: id
                    });
                  }).finally(function () {
                    if (!params.fontExtraProperties && font.data) {
                      font.data = null;
                    }
                    _this17.commonObjs.resolve(id, font);
                  });
                  break;
                case "FontPath":
                case "Image":
                case "Pattern":
                  _this17.commonObjs.resolve(id, exportedData);
                  break;
                default:
                  throw new Error("Got unknown common object type ".concat(type));
              }
            });
            messageHandler.on("obj", function (_ref21) {
              var _ref22 = _slicedToArray(_ref21, 4),
                id = _ref22[0],
                pageIndex = _ref22[1],
                type = _ref22[2],
                imageData = _ref22[3];
              if (_this17.destroyed) {
                return;
              }
              var pageProxy = _classPrivateFieldGet(_pageCache, _this17).get(pageIndex);
              if (pageProxy.objs.has(id)) {
                return;
              }
              switch (type) {
                case "Image":
                  pageProxy.objs.resolve(id, imageData);
                  if (imageData) {
                    var length;
                    if (imageData.bitmap) {
                      var width = imageData.width,
                        height = imageData.height;
                      length = width * height * 4;
                    } else {
                      var _imageData$data;
                      length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;
                    }
                    if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {
                      pageProxy._maybeCleanupAfterRender = true;
                    }
                  }
                  break;
                case "Pattern":
                  pageProxy.objs.resolve(id, imageData);
                  break;
                default:
                  throw new Error("Got unknown object type ".concat(type));
              }
            });
            messageHandler.on("DocProgress", function (data) {
              var _loadingTask$onProgre4;
              if (_this17.destroyed) {
                return;
              }
              (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 || _loadingTask$onProgre4.call(loadingTask, {
                loaded: data.loaded,
                total: data.total
              });
            });
            messageHandler.on("FetchBuiltInCMap", function (data) {
              if (_this17.destroyed) {
                return Promise.reject(new Error("Worker was destroyed."));
              }
              if (!_this17.cMapReaderFactory) {
                return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
              }
              return _this17.cMapReaderFactory.fetch(data);
            });
            messageHandler.on("FetchStandardFontData", function (data) {
              if (_this17.destroyed) {
                return Promise.reject(new Error("Worker was destroyed."));
              }
              if (!_this17.standardFontDataFactory) {
                return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
              }
              return _this17.standardFontDataFactory.fetch(data);
            });
          }
        }, {
          key: "getData",
          value: function getData() {
            return this.messageHandler.sendWithPromise("GetData", null);
          }
        }, {
          key: "saveDocument",
          value: function saveDocument() {
            var _this$_fullReader$fil,
              _this$_fullReader,
              _this18 = this;
            if (this.annotationStorage.size <= 0) {
              (0, _util.warn)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
            }
            var _this$annotationStora = this.annotationStorage.serializable,
              map = _this$annotationStora.map,
              transfers = _this$annotationStora.transfers;
            return this.messageHandler.sendWithPromise("SaveDocument", {
              isPureXfa: !!this._htmlForXfa,
              numPages: this._numPages,
              annotationStorage: map,
              filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
            }, transfers).finally(function () {
              _this18.annotationStorage.resetModified();
            });
          }
        }, {
          key: "getPage",
          value: function getPage(pageNumber) {
            var _this19 = this;
            if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
              return Promise.reject(new Error("Invalid page request."));
            }
            var pageIndex = pageNumber - 1,
              cachedPromise = _classPrivateFieldGet(_pagePromises, this).get(pageIndex);
            if (cachedPromise) {
              return cachedPromise;
            }
            var promise = this.messageHandler.sendWithPromise("GetPage", {
              pageIndex: pageIndex
            }).then(function (pageInfo) {
              if (_this19.destroyed) {
                throw new Error("Transport destroyed");
              }
              var page = new PDFPageProxy(pageIndex, pageInfo, _this19, _this19._params.pdfBug);
              _classPrivateFieldGet(_pageCache, _this19).set(pageIndex, page);
              return page;
            });
            _classPrivateFieldGet(_pagePromises, this).set(pageIndex, promise);
            return promise;
          }
        }, {
          key: "getPageIndex",
          value: function getPageIndex(ref) {
            if (_typeof(ref) !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
              return Promise.reject(new Error("Invalid pageIndex request."));
            }
            return this.messageHandler.sendWithPromise("GetPageIndex", {
              num: ref.num,
              gen: ref.gen
            });
          }
        }, {
          key: "getAnnotations",
          value: function getAnnotations(pageIndex, intent) {
            return this.messageHandler.sendWithPromise("GetAnnotations", {
              pageIndex: pageIndex,
              intent: intent
            });
          }
        }, {
          key: "getFieldObjects",
          value: function getFieldObjects() {
            return _assertClassBrand(_WorkerTransport_brand, this, _cacheSimpleMethod).call(this, "GetFieldObjects");
          }
        }, {
          key: "hasJSActions",
          value: function hasJSActions() {
            return _assertClassBrand(_WorkerTransport_brand, this, _cacheSimpleMethod).call(this, "HasJSActions");
          }
        }, {
          key: "getCalculationOrderIds",
          value: function getCalculationOrderIds() {
            return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
          }
        }, {
          key: "getDestinations",
          value: function getDestinations() {
            return this.messageHandler.sendWithPromise("GetDestinations", null);
          }
        }, {
          key: "getDestination",
          value: function getDestination(id) {
            if (typeof id !== "string") {
              return Promise.reject(new Error("Invalid destination request."));
            }
            return this.messageHandler.sendWithPromise("GetDestination", {
              id: id
            });
          }
        }, {
          key: "getPageLabels",
          value: function getPageLabels() {
            return this.messageHandler.sendWithPromise("GetPageLabels", null);
          }
        }, {
          key: "getPageLayout",
          value: function getPageLayout() {
            return this.messageHandler.sendWithPromise("GetPageLayout", null);
          }
        }, {
          key: "getPageMode",
          value: function getPageMode() {
            return this.messageHandler.sendWithPromise("GetPageMode", null);
          }
        }, {
          key: "getViewerPreferences",
          value: function getViewerPreferences() {
            return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
          }
        }, {
          key: "getOpenAction",
          value: function getOpenAction() {
            return this.messageHandler.sendWithPromise("GetOpenAction", null);
          }
        }, {
          key: "getAttachments",
          value: function getAttachments() {
            return this.messageHandler.sendWithPromise("GetAttachments", null);
          }
        }, {
          key: "getDocJSActions",
          value: function getDocJSActions() {
            return _assertClassBrand(_WorkerTransport_brand, this, _cacheSimpleMethod).call(this, "GetDocJSActions");
          }
        }, {
          key: "getPageJSActions",
          value: function getPageJSActions(pageIndex) {
            return this.messageHandler.sendWithPromise("GetPageJSActions", {
              pageIndex: pageIndex
            });
          }
        }, {
          key: "getStructTree",
          value: function getStructTree(pageIndex) {
            return this.messageHandler.sendWithPromise("GetStructTree", {
              pageIndex: pageIndex
            });
          }
        }, {
          key: "getOutline",
          value: function getOutline() {
            return this.messageHandler.sendWithPromise("GetOutline", null);
          }
        }, {
          key: "getOptionalContentConfig",
          value: function getOptionalContentConfig() {
            return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(function (results) {
              return new _optional_content_config.OptionalContentConfig(results);
            });
          }
        }, {
          key: "getPermissions",
          value: function getPermissions() {
            return this.messageHandler.sendWithPromise("GetPermissions", null);
          }
        }, {
          key: "getMetadata",
          value: function getMetadata() {
            var _this20 = this;
            var name = "GetMetadata",
              cachedPromise = _classPrivateFieldGet(_methodPromises, this).get(name);
            if (cachedPromise) {
              return cachedPromise;
            }
            var promise = this.messageHandler.sendWithPromise(name, null).then(function (results) {
              var _this20$_fullReader$f, _this20$_fullReader, _this20$_fullReader$c, _this20$_fullReader2;
              return {
                info: results[0],
                metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                contentDispositionFilename: (_this20$_fullReader$f = (_this20$_fullReader = _this20._fullReader) === null || _this20$_fullReader === void 0 ? void 0 : _this20$_fullReader.filename) !== null && _this20$_fullReader$f !== void 0 ? _this20$_fullReader$f : null,
                contentLength: (_this20$_fullReader$c = (_this20$_fullReader2 = _this20._fullReader) === null || _this20$_fullReader2 === void 0 ? void 0 : _this20$_fullReader2.contentLength) !== null && _this20$_fullReader$c !== void 0 ? _this20$_fullReader$c : null
              };
            });
            _classPrivateFieldGet(_methodPromises, this).set(name, promise);
            return promise;
          }
        }, {
          key: "getMarkInfo",
          value: function getMarkInfo() {
            return this.messageHandler.sendWithPromise("GetMarkInfo", null);
          }
        }, {
          key: "startCleanup",
          value: function () {
            var _startCleanup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              var keepLoadedFonts,
                _iterator13,
                _step13,
                page,
                cleanupSuccessful,
                _args4 = arguments;
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    keepLoadedFonts = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : false;
                    if (!this.destroyed) {
                      _context4.next = 3;
                      break;
                    }
                    return _context4.abrupt("return");
                  case 3:
                    _context4.next = 5;
                    return this.messageHandler.sendWithPromise("Cleanup", null);
                  case 5:
                    _iterator13 = _createForOfIteratorHelper(_classPrivateFieldGet(_pageCache, this).values());
                    _context4.prev = 6;
                    _iterator13.s();
                  case 8:
                    if ((_step13 = _iterator13.n()).done) {
                      _context4.next = 15;
                      break;
                    }
                    page = _step13.value;
                    cleanupSuccessful = page.cleanup();
                    if (cleanupSuccessful) {
                      _context4.next = 13;
                      break;
                    }
                    throw new Error("startCleanup: Page ".concat(page.pageNumber, " is currently rendering."));
                  case 13:
                    _context4.next = 8;
                    break;
                  case 15:
                    _context4.next = 20;
                    break;
                  case 17:
                    _context4.prev = 17;
                    _context4.t0 = _context4["catch"](6);
                    _iterator13.e(_context4.t0);
                  case 20:
                    _context4.prev = 20;
                    _iterator13.f();
                    return _context4.finish(20);
                  case 23:
                    this.commonObjs.clear();
                    if (!keepLoadedFonts) {
                      this.fontLoader.clear();
                    }
                    _classPrivateFieldGet(_methodPromises, this).clear();
                    this.filterFactory.destroy(true);
                  case 27:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4, this, [[6, 17, 20, 23]]);
            }));
            function startCleanup() {
              return _startCleanup.apply(this, arguments);
            }
            return startCleanup;
          }()
        }, {
          key: "loadingParams",
          get: function get() {
            var _this$_params = this._params,
              disableAutoFetch = _this$_params.disableAutoFetch,
              enableXfa = _this$_params.enableXfa;
            return (0, _util.shadow)(this, "loadingParams", {
              disableAutoFetch: disableAutoFetch,
              enableXfa: enableXfa
            });
          }
        }]);
      }();
      function _cacheSimpleMethod(name) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var cachedPromise = _classPrivateFieldGet(_methodPromises, this).get(name);
        if (cachedPromise) {
          return cachedPromise;
        }
        var promise = this.messageHandler.sendWithPromise(name, data);
        _classPrivateFieldGet(_methodPromises, this).set(name, promise);
        return promise;
      }
      var _objs = /*#__PURE__*/new WeakMap();
      var _PDFObjects_brand = /*#__PURE__*/new WeakSet();
      var PDFObjects = /*#__PURE__*/function () {
        function PDFObjects() {
          _classCallCheck(this, PDFObjects);
          _classPrivateMethodInitSpec(this, _PDFObjects_brand);
          _classPrivateFieldInitSpec(this, _objs, Object.create(null));
        }
        return _createClass(PDFObjects, [{
          key: "get",
          value: function get(objId) {
            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (callback) {
              var _obj = _assertClassBrand(_PDFObjects_brand, this, _ensureObj).call(this, objId);
              _obj.capability.promise.then(function () {
                return callback(_obj.data);
              });
              return null;
            }
            var obj = _classPrivateFieldGet(_objs, this)[objId];
            if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {
              throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
            }
            return obj.data;
          }
        }, {
          key: "has",
          value: function has(objId) {
            var obj = _classPrivateFieldGet(_objs, this)[objId];
            return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;
          }
        }, {
          key: "resolve",
          value: function resolve(objId) {
            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var obj = _assertClassBrand(_PDFObjects_brand, this, _ensureObj).call(this, objId);
            obj.data = data;
            obj.capability.resolve();
          }
        }, {
          key: "clear",
          value: function clear() {
            for (var objId in _classPrivateFieldGet(_objs, this)) {
              var _data$bitmap;
              var data = _classPrivateFieldGet(_objs, this)[objId].data;
              data === null || data === void 0 || (_data$bitmap = data.bitmap) === null || _data$bitmap === void 0 || _data$bitmap.close();
            }
            _classPrivateFieldSet(_objs, this, Object.create(null));
          }
        }]);
      }();
      function _ensureObj(objId) {
        var _classPrivateFieldGet4;
        return (_classPrivateFieldGet4 = _classPrivateFieldGet(_objs, this))[objId] || (_classPrivateFieldGet4[objId] = {
          capability: new _util.PromiseCapability(),
          data: null
        });
      }
      var _internalRenderTask = /*#__PURE__*/new WeakMap();
      var RenderTask = /*#__PURE__*/function () {
        function RenderTask(internalRenderTask) {
          _classCallCheck(this, RenderTask);
          _classPrivateFieldInitSpec(this, _internalRenderTask, null);
          _classPrivateFieldSet(_internalRenderTask, this, internalRenderTask);
          this.onContinue = null;
        }
        return _createClass(RenderTask, [{
          key: "promise",
          get: function get() {
            return _classPrivateFieldGet(_internalRenderTask, this).capability.promise;
          }
        }, {
          key: "cancel",
          value: function cancel() {
            var extraDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            _classPrivateFieldGet(_internalRenderTask, this).cancel(null, extraDelay);
          }
        }, {
          key: "separateAnnots",
          get: function get() {
            var separateAnnots = _classPrivateFieldGet(_internalRenderTask, this).operatorList.separateAnnots;
            if (!separateAnnots) {
              return false;
            }
            var _classPrivateFieldGet3 = _classPrivateFieldGet(_internalRenderTask, this),
              annotationCanvasMap = _classPrivateFieldGet3.annotationCanvasMap;
            return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap === null || annotationCanvasMap === void 0 ? void 0 : annotationCanvasMap.size) > 0;
          }
        }]);
      }();
      exports.RenderTask = RenderTask;
      var InternalRenderTask = /*#__PURE__*/function () {
        function InternalRenderTask(_ref23) {
          var callback = _ref23.callback,
            params = _ref23.params,
            objs = _ref23.objs,
            commonObjs = _ref23.commonObjs,
            annotationCanvasMap = _ref23.annotationCanvasMap,
            operatorList = _ref23.operatorList,
            pageIndex = _ref23.pageIndex,
            canvasFactory = _ref23.canvasFactory,
            filterFactory = _ref23.filterFactory,
            _ref23$useRequestAnim = _ref23.useRequestAnimationFrame,
            useRequestAnimationFrame = _ref23$useRequestAnim === void 0 ? false : _ref23$useRequestAnim,
            _ref23$pdfBug = _ref23.pdfBug,
            pdfBug = _ref23$pdfBug === void 0 ? false : _ref23$pdfBug,
            _ref23$pageColors = _ref23.pageColors,
            pageColors = _ref23$pageColors === void 0 ? null : _ref23$pageColors;
          _classCallCheck(this, InternalRenderTask);
          this.callback = callback;
          this.params = params;
          this.objs = objs;
          this.commonObjs = commonObjs;
          this.annotationCanvasMap = annotationCanvasMap;
          this.operatorListIdx = null;
          this.operatorList = operatorList;
          this._pageIndex = pageIndex;
          this.canvasFactory = canvasFactory;
          this.filterFactory = filterFactory;
          this._pdfBug = pdfBug;
          this.pageColors = pageColors;
          this.running = false;
          this.graphicsReadyCallback = null;
          this.graphicsReady = false;
          this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
          this.cancelled = false;
          this.capability = new _util.PromiseCapability();
          this.task = new RenderTask(this);
          this._cancelBound = this.cancel.bind(this);
          this._continueBound = this._continue.bind(this);
          this._scheduleNextBound = this._scheduleNext.bind(this);
          this._nextBound = this._next.bind(this);
          this._canvas = params.canvasContext.canvas;
        }
        return _createClass(InternalRenderTask, [{
          key: "completed",
          get: function get() {
            return this.capability.promise.catch(function () {});
          }
        }, {
          key: "initializeGraphics",
          value: function initializeGraphics(_ref24) {
            var _globalThis$StepperMa, _this$graphicsReadyCa;
            var _ref24$transparency = _ref24.transparency,
              transparency = _ref24$transparency === void 0 ? false : _ref24$transparency,
              optionalContentConfig = _ref24.optionalContentConfig;
            if (this.cancelled) {
              return;
            }
            if (this._canvas) {
              if (_canvasInUse._.has(this._canvas)) {
                throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
              }
              _canvasInUse._.add(this._canvas);
            }
            if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
              this.stepper = globalThis.StepperManager.create(this._pageIndex);
              this.stepper.init(this.operatorList);
              this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
            }
            var _this$params = this.params,
              canvasContext = _this$params.canvasContext,
              viewport = _this$params.viewport,
              transform = _this$params.transform,
              background = _this$params.background;
            this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
              optionalContentConfig: optionalContentConfig
            }, this.annotationCanvasMap, this.pageColors);
            this.gfx.beginDrawing({
              transform: transform,
              viewport: viewport,
              transparency: transparency,
              background: background
            });
            this.operatorListIdx = 0;
            this.graphicsReady = true;
            (_this$graphicsReadyCa = this.graphicsReadyCallback) === null || _this$graphicsReadyCa === void 0 || _this$graphicsReadyCa.call(this);
          }
        }, {
          key: "cancel",
          value: function cancel() {
            var _this$gfx;
            var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var extraDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this.running = false;
            this.cancelled = true;
            (_this$gfx = this.gfx) === null || _this$gfx === void 0 || _this$gfx.endDrawing();
            _canvasInUse._.delete(this._canvas);
            this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), extraDelay));
          }
        }, {
          key: "operatorListChanged",
          value: function operatorListChanged() {
            var _this$stepper;
            if (!this.graphicsReady) {
              this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
              return;
            }
            (_this$stepper = this.stepper) === null || _this$stepper === void 0 || _this$stepper.updateOperatorList(this.operatorList);
            if (this.running) {
              return;
            }
            this._continue();
          }
        }, {
          key: "_continue",
          value: function _continue() {
            this.running = true;
            if (this.cancelled) {
              return;
            }
            if (this.task.onContinue) {
              this.task.onContinue(this._scheduleNextBound);
            } else {
              this._scheduleNext();
            }
          }
        }, {
          key: "_scheduleNext",
          value: function _scheduleNext() {
            var _this21 = this;
            if (this._useRequestAnimationFrame) {
              window.requestAnimationFrame(function () {
                _this21._nextBound().catch(_this21._cancelBound);
              });
            } else {
              Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
          }
        }, {
          key: "_next",
          value: function () {
            var _next2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
              return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!this.cancelled) {
                      _context5.next = 2;
                      break;
                    }
                    return _context5.abrupt("return");
                  case 2:
                    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                    if (this.operatorListIdx === this.operatorList.argsArray.length) {
                      this.running = false;
                      if (this.operatorList.lastChunk) {
                        this.gfx.endDrawing();
                        _canvasInUse._.delete(this._canvas);
                        this.callback();
                      }
                    }
                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5, this);
            }));
            function _next() {
              return _next2.apply(this, arguments);
            }
            return _next;
          }()
        }]);
      }();
      var _canvasInUse = {
        _: new WeakSet()
      };
      var version = '3.11.174';
      exports.version = version;
      var build = 'ce8716743';
      exports.build = build;

      /***/
    }), (/* 3 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SerializableEmpty = exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;
      var _util = __w_pdfjs_require__(1);
      var _editor = __w_pdfjs_require__(4);
      var _murmurhash = __w_pdfjs_require__(8);
      var SerializableEmpty = Object.freeze({
        map: null,
        hash: "",
        transfers: undefined
      });
      exports.SerializableEmpty = SerializableEmpty;
      var _modified = /*#__PURE__*/new WeakMap();
      var _storage = /*#__PURE__*/new WeakMap();
      var _AnnotationStorage_brand = /*#__PURE__*/new WeakSet();
      var AnnotationStorage = /*#__PURE__*/function () {
        function AnnotationStorage() {
          _classCallCheck(this, AnnotationStorage);
          _classPrivateMethodInitSpec(this, _AnnotationStorage_brand);
          _classPrivateFieldInitSpec(this, _modified, false);
          _classPrivateFieldInitSpec(this, _storage, new Map());
          this.onSetModified = null;
          this.onResetModified = null;
          this.onAnnotationEditor = null;
        }
        return _createClass(AnnotationStorage, [{
          key: "getValue",
          value: function getValue(key, defaultValue) {
            var value = _classPrivateFieldGet(_storage, this).get(key);
            if (value === undefined) {
              return defaultValue;
            }
            return Object.assign(defaultValue, value);
          }
        }, {
          key: "getRawValue",
          value: function getRawValue(key) {
            return _classPrivateFieldGet(_storage, this).get(key);
          }
        }, {
          key: "remove",
          value: function remove(key) {
            _classPrivateFieldGet(_storage, this).delete(key);
            if (_classPrivateFieldGet(_storage, this).size === 0) {
              this.resetModified();
            }
            if (typeof this.onAnnotationEditor === "function") {
              var _iterator15 = _createForOfIteratorHelper(_classPrivateFieldGet(_storage, this).values()),
                _step15;
              try {
                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                  var value = _step15.value;
                  if (value instanceof _editor.AnnotationEditor) {
                    return;
                  }
                }
              } catch (err) {
                _iterator15.e(err);
              } finally {
                _iterator15.f();
              }
              this.onAnnotationEditor(null);
            }
          }
        }, {
          key: "setValue",
          value: function setValue(key, value) {
            var obj = _classPrivateFieldGet(_storage, this).get(key);
            var modified = false;
            if (obj !== undefined) {
              for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
                var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  entry = _Object$entries$_i[0],
                  val = _Object$entries$_i[1];
                if (obj[entry] !== val) {
                  modified = true;
                  obj[entry] = val;
                }
              }
            } else {
              modified = true;
              _classPrivateFieldGet(_storage, this).set(key, value);
            }
            if (modified) {
              _assertClassBrand(_AnnotationStorage_brand, this, _setModified).call(this);
            }
            if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
              this.onAnnotationEditor(value.constructor._type);
            }
          }
        }, {
          key: "has",
          value: function has(key) {
            return _classPrivateFieldGet(_storage, this).has(key);
          }
        }, {
          key: "getAll",
          value: function getAll() {
            return _classPrivateFieldGet(_storage, this).size > 0 ? (0, _util.objectFromMap)(_classPrivateFieldGet(_storage, this)) : null;
          }
        }, {
          key: "setAll",
          value: function setAll(obj) {
            for (var _i2 = 0, _Object$entries2 = Object.entries(obj); _i2 < _Object$entries2.length; _i2++) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                key = _Object$entries2$_i[0],
                val = _Object$entries2$_i[1];
              this.setValue(key, val);
            }
          }
        }, {
          key: "size",
          get: function get() {
            return _classPrivateFieldGet(_storage, this).size;
          }
        }, {
          key: "resetModified",
          value: function resetModified() {
            if (_classPrivateFieldGet(_modified, this)) {
              _classPrivateFieldSet(_modified, this, false);
              if (typeof this.onResetModified === "function") {
                this.onResetModified();
              }
            }
          }
        }, {
          key: "print",
          get: function get() {
            return new PrintAnnotationStorage(this);
          }
        }, {
          key: "serializable",
          get: function get() {
            if (_classPrivateFieldGet(_storage, this).size === 0) {
              return SerializableEmpty;
            }
            var map = new Map(),
              hash = new _murmurhash.MurmurHash3_64(),
              transfers = [];
            var context = Object.create(null);
            var hasBitmap = false;
            var _iterator16 = _createForOfIteratorHelper(_classPrivateFieldGet(_storage, this)),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var _step16$value = _slicedToArray(_step16.value, 2),
                  key = _step16$value[0],
                  val = _step16$value[1];
                var serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;
                if (serialized) {
                  map.set(key, serialized);
                  hash.update("".concat(key, ":").concat(JSON.stringify(serialized)));
                  hasBitmap || (hasBitmap = !!serialized.bitmap);
                }
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            if (hasBitmap) {
              var _iterator17 = _createForOfIteratorHelper(map.values()),
                _step17;
              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  var value = _step17.value;
                  if (value.bitmap) {
                    transfers.push(value.bitmap);
                  }
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }
            }
            return map.size > 0 ? {
              map: map,
              hash: hash.hexdigest(),
              transfers: transfers
            } : SerializableEmpty;
          }
        }]);
      }();
      function _setModified() {
        if (!_classPrivateFieldGet(_modified, this)) {
          _classPrivateFieldSet(_modified, this, true);
          if (typeof this.onSetModified === "function") {
            this.onSetModified();
          }
        }
      }
      exports.AnnotationStorage = AnnotationStorage;
      var _serializable = /*#__PURE__*/new WeakMap();
      var PrintAnnotationStorage = /*#__PURE__*/function (_AnnotationStorage2) {
        function PrintAnnotationStorage(parent) {
          var _this23;
          _classCallCheck(this, PrintAnnotationStorage);
          _this23 = _callSuper(this, PrintAnnotationStorage);
          _classPrivateFieldInitSpec(_this23, _serializable, void 0);
          var _parent$serializable = parent.serializable,
            map = _parent$serializable.map,
            hash = _parent$serializable.hash,
            transfers = _parent$serializable.transfers;
          var clone = structuredClone(map, transfers ? {
            transfer: transfers
          } : null);
          _classPrivateFieldSet(_serializable, _this23, {
            map: clone,
            hash: hash,
            transfers: transfers
          });
          return _this23;
        }
        _inherits(PrintAnnotationStorage, _AnnotationStorage2);
        return _createClass(PrintAnnotationStorage, [{
          key: "print",
          get: function get() {
            (0, _util.unreachable)("Should not call PrintAnnotationStorage.print");
          }
        }, {
          key: "serializable",
          get: function get() {
            return _classPrivateFieldGet(_serializable, this);
          }
        }]);
      }(AnnotationStorage);
      exports.PrintAnnotationStorage = PrintAnnotationStorage;

      /***/
    }), (/* 4 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      var _AnnotationEditor;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnnotationEditor = void 0;
      var _tools = __w_pdfjs_require__(5);
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      var _altText = /*#__PURE__*/new WeakMap();
      var _altTextDecorative = /*#__PURE__*/new WeakMap();
      var _altTextButton = /*#__PURE__*/new WeakMap();
      var _altTextTooltip = /*#__PURE__*/new WeakMap();
      var _altTextTooltipTimeout = /*#__PURE__*/new WeakMap();
      var _keepAspectRatio = /*#__PURE__*/new WeakMap();
      var _resizersDiv = /*#__PURE__*/new WeakMap();
      var _boundFocusin = /*#__PURE__*/new WeakMap();
      var _boundFocusout = /*#__PURE__*/new WeakMap();
      var _hasBeenClicked = /*#__PURE__*/new WeakMap();
      var _isEditing = /*#__PURE__*/new WeakMap();
      var _isInEditMode = /*#__PURE__*/new WeakMap();
      var _isDraggable = /*#__PURE__*/new WeakMap();
      var _zIndex = /*#__PURE__*/new WeakMap();
      var _AnnotationEditor_brand = /*#__PURE__*/new WeakSet();
      var AnnotationEditor = /*#__PURE__*/function () {
        function AnnotationEditor(parameters) {
          _classCallCheck(this, AnnotationEditor);
          _classPrivateMethodInitSpec(this, _AnnotationEditor_brand);
          _classPrivateFieldInitSpec(this, _altText, "");
          _classPrivateFieldInitSpec(this, _altTextDecorative, false);
          _classPrivateFieldInitSpec(this, _altTextButton, null);
          _classPrivateFieldInitSpec(this, _altTextTooltip, null);
          _classPrivateFieldInitSpec(this, _altTextTooltipTimeout, null);
          _classPrivateFieldInitSpec(this, _keepAspectRatio, false);
          _classPrivateFieldInitSpec(this, _resizersDiv, null);
          _classPrivateFieldInitSpec(this, _boundFocusin, this.focusin.bind(this));
          _classPrivateFieldInitSpec(this, _boundFocusout, this.focusout.bind(this));
          _classPrivateFieldInitSpec(this, _hasBeenClicked, false);
          _classPrivateFieldInitSpec(this, _isEditing, false);
          _classPrivateFieldInitSpec(this, _isInEditMode, false);
          _defineProperty(this, "_initialOptions", Object.create(null));
          _defineProperty(this, "_uiManager", null);
          _defineProperty(this, "_focusEventsAllowed", true);
          _defineProperty(this, "_l10nPromise", null);
          _classPrivateFieldInitSpec(this, _isDraggable, false);
          _classPrivateFieldInitSpec(this, _zIndex, AnnotationEditor._zIndex++);
          if (this.constructor === AnnotationEditor) {
            (0, _util.unreachable)("Cannot initialize AnnotationEditor.");
          }
          this.parent = parameters.parent;
          this.id = parameters.id;
          this.width = this.height = null;
          this.pageIndex = parameters.parent.pageIndex;
          this.name = parameters.name;
          this.div = null;
          this._uiManager = parameters.uiManager;
          this.annotationElementId = null;
          this._willKeepAspectRatio = false;
          this._initialOptions.isCentered = parameters.isCentered;
          this._structTreeParentId = null;
          var _this$parent$viewport = this.parent.viewport,
            _rotation = _this$parent$viewport.rotation,
            _this$parent$viewport2 = _this$parent$viewport.rawDims,
            _pageWidth = _this$parent$viewport2.pageWidth,
            _pageHeight = _this$parent$viewport2.pageHeight,
            pageX = _this$parent$viewport2.pageX,
            pageY = _this$parent$viewport2.pageY;
          this.rotation = _rotation;
          this.pageRotation = (360 + _rotation - this._uiManager.viewParameters.rotation) % 360;
          this.pageDimensions = [_pageWidth, _pageHeight];
          this.pageTranslation = [pageX, pageY];
          var _this$parentDimension = _slicedToArray(this.parentDimensions, 2),
            _width = _this$parentDimension[0],
            _height = _this$parentDimension[1];
          this.x = parameters.x / _width;
          this.y = parameters.y / _height;
          this.isAttachedToDOM = false;
          this.deleted = false;
        }
        return _createClass(AnnotationEditor, [{
          key: "editorType",
          get: function get() {
            return Object.getPrototypeOf(this).constructor._type;
          }
        }, {
          key: "propertiesToUpdate",
          get: function get() {
            return [];
          }
        }, {
          key: "_isDraggable",
          get: function get() {
            return _classPrivateFieldGet(_isDraggable, this);
          },
          set: function set(value) {
            var _this$div;
            _classPrivateFieldSet(_isDraggable, this, value);
            (_this$div = this.div) === null || _this$div === void 0 || _this$div.classList.toggle("draggable", value);
          }
        }, {
          key: "center",
          value: function center() {
            var _this$pageDimensions = _slicedToArray(this.pageDimensions, 2),
              pageWidth = _this$pageDimensions[0],
              pageHeight = _this$pageDimensions[1];
            switch (this.parentRotation) {
              case 90:
                this.x -= this.height * pageHeight / (pageWidth * 2);
                this.y += this.width * pageWidth / (pageHeight * 2);
                break;
              case 180:
                this.x += this.width / 2;
                this.y += this.height / 2;
                break;
              case 270:
                this.x += this.height * pageHeight / (pageWidth * 2);
                this.y -= this.width * pageWidth / (pageHeight * 2);
                break;
              default:
                this.x -= this.width / 2;
                this.y -= this.height / 2;
                break;
            }
            this.fixAndSetPosition();
          }
        }, {
          key: "addCommands",
          value: function addCommands(params) {
            this._uiManager.addCommands(params);
          }
        }, {
          key: "currentLayer",
          get: function get() {
            return this._uiManager.currentLayer;
          }
        }, {
          key: "setInBackground",
          value: function setInBackground() {
            this.div.style.zIndex = 0;
          }
        }, {
          key: "setInForeground",
          value: function setInForeground() {
            this.div.style.zIndex = _classPrivateFieldGet(_zIndex, this);
          }
        }, {
          key: "setParent",
          value: function setParent(parent) {
            if (parent !== null) {
              this.pageIndex = parent.pageIndex;
              this.pageDimensions = parent.pageDimensions;
            }
            this.parent = parent;
          }
        }, {
          key: "focusin",
          value: function focusin(event) {
            if (!this._focusEventsAllowed) {
              return;
            }
            if (!_classPrivateFieldGet(_hasBeenClicked, this)) {
              this.parent.setSelected(this);
            } else {
              _classPrivateFieldSet(_hasBeenClicked, this, false);
            }
          }
        }, {
          key: "focusout",
          value: function focusout(event) {
            var _this$parent;
            if (!this._focusEventsAllowed) {
              return;
            }
            if (!this.isAttachedToDOM) {
              return;
            }
            var target = event.relatedTarget;
            if (target !== null && target !== void 0 && target.closest("#".concat(this.id))) {
              return;
            }
            event.preventDefault();
            if (!((_this$parent = this.parent) !== null && _this$parent !== void 0 && _this$parent.isMultipleSelection)) {
              this.commitOrRemove();
            }
          }
        }, {
          key: "commitOrRemove",
          value: function commitOrRemove() {
            if (this.isEmpty()) {
              this.remove();
            } else {
              this.commit();
            }
          }
        }, {
          key: "commit",
          value: function commit() {
            this.addToAnnotationStorage();
          }
        }, {
          key: "addToAnnotationStorage",
          value: function addToAnnotationStorage() {
            this._uiManager.addToAnnotationStorage(this);
          }
        }, {
          key: "setAt",
          value: function setAt(x, y, tx, ty) {
            var _this$parentDimension2 = _slicedToArray(this.parentDimensions, 2),
              width = _this$parentDimension2[0],
              height = _this$parentDimension2[1];
            var _this$screenToPageTra = this.screenToPageTranslation(tx, ty);
            var _this$screenToPageTra2 = _slicedToArray(_this$screenToPageTra, 2);
            tx = _this$screenToPageTra2[0];
            ty = _this$screenToPageTra2[1];
            this.x = (x + tx) / width;
            this.y = (y + ty) / height;
            this.fixAndSetPosition();
          }
        }, {
          key: "translate",
          value: function translate(x, y) {
            _assertClassBrand(_AnnotationEditor_brand, this, _translate).call(this, this.parentDimensions, x, y);
          }
        }, {
          key: "translateInPage",
          value: function translateInPage(x, y) {
            _assertClassBrand(_AnnotationEditor_brand, this, _translate).call(this, this.pageDimensions, x, y);
            this.div.scrollIntoView({
              block: "nearest"
            });
          }
        }, {
          key: "drag",
          value: function drag(tx, ty) {
            var _this$parentDimension3 = _slicedToArray(this.parentDimensions, 2),
              parentWidth = _this$parentDimension3[0],
              parentHeight = _this$parentDimension3[1];
            this.x += tx / parentWidth;
            this.y += ty / parentHeight;
            if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
              var _this$div$getBounding = this.div.getBoundingClientRect(),
                _x3 = _this$div$getBounding.x,
                _y = _this$div$getBounding.y;
              if (this.parent.findNewParent(this, _x3, _y)) {
                this.x -= Math.floor(this.x);
                this.y -= Math.floor(this.y);
              }
            }
            var x = this.x,
              y = this.y;
            var _assertClassBrand$cal = _assertClassBrand(_AnnotationEditor_brand, this, _getBaseTranslation).call(this),
              _assertClassBrand$cal2 = _slicedToArray(_assertClassBrand$cal, 2),
              bx = _assertClassBrand$cal2[0],
              by = _assertClassBrand$cal2[1];
            x += bx;
            y += by;
            this.div.style.left = "".concat((100 * x).toFixed(2), "%");
            this.div.style.top = "".concat((100 * y).toFixed(2), "%");
            this.div.scrollIntoView({
              block: "nearest"
            });
          }
        }, {
          key: "fixAndSetPosition",
          value: function fixAndSetPosition() {
            var _this$pageDimensions2 = _slicedToArray(this.pageDimensions, 2),
              pageWidth = _this$pageDimensions2[0],
              pageHeight = _this$pageDimensions2[1];
            var x = this.x,
              y = this.y,
              width = this.width,
              height = this.height;
            width *= pageWidth;
            height *= pageHeight;
            x *= pageWidth;
            y *= pageHeight;
            switch (this.rotation) {
              case 0:
                x = Math.max(0, Math.min(pageWidth - width, x));
                y = Math.max(0, Math.min(pageHeight - height, y));
                break;
              case 90:
                x = Math.max(0, Math.min(pageWidth - height, x));
                y = Math.min(pageHeight, Math.max(width, y));
                break;
              case 180:
                x = Math.min(pageWidth, Math.max(width, x));
                y = Math.min(pageHeight, Math.max(height, y));
                break;
              case 270:
                x = Math.min(pageWidth, Math.max(height, x));
                y = Math.max(0, Math.min(pageHeight - width, y));
                break;
            }
            this.x = x /= pageWidth;
            this.y = y /= pageHeight;
            var _assertClassBrand$cal3 = _assertClassBrand(_AnnotationEditor_brand, this, _getBaseTranslation).call(this),
              _assertClassBrand$cal4 = _slicedToArray(_assertClassBrand$cal3, 2),
              bx = _assertClassBrand$cal4[0],
              by = _assertClassBrand$cal4[1];
            x += bx;
            y += by;
            var style = this.div.style;
            style.left = "".concat((100 * x).toFixed(2), "%");
            style.top = "".concat((100 * y).toFixed(2), "%");
            this.moveInDOM();
          }
        }, {
          key: "screenToPageTranslation",
          value: function screenToPageTranslation(x, y) {
            return _rotatePoint.call(AnnotationEditor, x, y, this.parentRotation);
          }
        }, {
          key: "pageTranslationToScreen",
          value: function pageTranslationToScreen(x, y) {
            return _rotatePoint.call(AnnotationEditor, x, y, 360 - this.parentRotation);
          }
        }, {
          key: "parentScale",
          get: function get() {
            return this._uiManager.viewParameters.realScale;
          }
        }, {
          key: "parentRotation",
          get: function get() {
            return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
          }
        }, {
          key: "parentDimensions",
          get: function get() {
            var parentScale = this.parentScale,
              _this$pageDimensions3 = _slicedToArray(this.pageDimensions, 2),
              pageWidth = _this$pageDimensions3[0],
              pageHeight = _this$pageDimensions3[1];
            var scaledWidth = pageWidth * parentScale;
            var scaledHeight = pageHeight * parentScale;
            return _util.FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];
          }
        }, {
          key: "setDims",
          value: function setDims(width, height) {
            var _classPrivateFieldGet5;
            var _this$parentDimension4 = _slicedToArray(this.parentDimensions, 2),
              parentWidth = _this$parentDimension4[0],
              parentHeight = _this$parentDimension4[1];
            this.div.style.width = "".concat((100 * width / parentWidth).toFixed(2), "%");
            if (!_classPrivateFieldGet(_keepAspectRatio, this)) {
              this.div.style.height = "".concat((100 * height / parentHeight).toFixed(2), "%");
            }
            (_classPrivateFieldGet5 = _classPrivateFieldGet(_altTextButton, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.classList.toggle("small", width < AnnotationEditor.SMALL_EDITOR_SIZE || height < AnnotationEditor.SMALL_EDITOR_SIZE);
          }
        }, {
          key: "fixDims",
          value: function fixDims() {
            var style = this.div.style;
            var height = style.height,
              width = style.width;
            var widthPercent = width.endsWith("%");
            var heightPercent = !_classPrivateFieldGet(_keepAspectRatio, this) && height.endsWith("%");
            if (widthPercent && heightPercent) {
              return;
            }
            var _this$parentDimension5 = _slicedToArray(this.parentDimensions, 2),
              parentWidth = _this$parentDimension5[0],
              parentHeight = _this$parentDimension5[1];
            if (!widthPercent) {
              style.width = "".concat((100 * parseFloat(width) / parentWidth).toFixed(2), "%");
            }
            if (!_classPrivateFieldGet(_keepAspectRatio, this) && !heightPercent) {
              style.height = "".concat((100 * parseFloat(height) / parentHeight).toFixed(2), "%");
            }
          }
        }, {
          key: "getInitialTranslation",
          value: function getInitialTranslation() {
            return [0, 0];
          }
        }, {
          key: "addAltTextButton",
          value: function () {
            var _addAltTextButton = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
              var _this24 = this;
              var altText, msg, PERCENT;
              return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                while (1) switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!_classPrivateFieldGet(_altTextButton, this)) {
                      _context7.next = 2;
                      break;
                    }
                    return _context7.abrupt("return");
                  case 2:
                    altText = _classPrivateFieldSet(_altTextButton, this, document.createElement("button"));
                    altText.className = "altText";
                    _context7.next = 6;
                    return AnnotationEditor._l10nPromise.get("editor_alt_text_button_label");
                  case 6:
                    msg = _context7.sent;
                    altText.textContent = msg;
                    altText.setAttribute("aria-label", msg);
                    altText.tabIndex = "0";
                    altText.addEventListener("contextmenu", _display_utils.noContextMenu);
                    altText.addEventListener("pointerdown", function (event) {
                      return event.stopPropagation();
                    });
                    altText.addEventListener("click", function (event) {
                      event.preventDefault();
                      _this24._uiManager.editAltText(_this24);
                    }, {
                      capture: true
                    });
                    altText.addEventListener("keydown", function (event) {
                      if (event.target === altText && event.key === "Enter") {
                        event.preventDefault();
                        _this24._uiManager.editAltText(_this24);
                      }
                    });
                    _assertClassBrand(_AnnotationEditor_brand, this, _setAltTextButtonState).call(this);
                    this.div.append(altText);
                    if (!AnnotationEditor.SMALL_EDITOR_SIZE) {
                      PERCENT = 40;
                      AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));
                    }
                  case 17:
                  case "end":
                    return _context7.stop();
                }
              }, _callee7, this);
            }));
            function addAltTextButton() {
              return _addAltTextButton.apply(this, arguments);
            }
            return addAltTextButton;
          }()
        }, {
          key: "getClientDimensions",
          value: function getClientDimensions() {
            return this.div.getBoundingClientRect();
          }
        }, {
          key: "altTextData",
          get: function get() {
            return {
              altText: _classPrivateFieldGet(_altText, this),
              decorative: _classPrivateFieldGet(_altTextDecorative, this)
            };
          },
          set: function set(_ref25) {
            var altText = _ref25.altText,
              decorative = _ref25.decorative;
            if (_classPrivateFieldGet(_altText, this) === altText && _classPrivateFieldGet(_altTextDecorative, this) === decorative) {
              return;
            }
            _classPrivateFieldSet(_altText, this, altText);
            _classPrivateFieldSet(_altTextDecorative, this, decorative);
            _assertClassBrand(_AnnotationEditor_brand, this, _setAltTextButtonState).call(this);
          }
        }, {
          key: "render",
          value: function render() {
            this.div = document.createElement("div");
            this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
            this.div.className = this.name;
            this.div.setAttribute("id", this.id);
            this.div.setAttribute("tabIndex", 0);
            this.setInForeground();
            this.div.addEventListener("focusin", _classPrivateFieldGet(_boundFocusin, this));
            this.div.addEventListener("focusout", _classPrivateFieldGet(_boundFocusout, this));
            var _this$parentDimension6 = _slicedToArray(this.parentDimensions, 2),
              parentWidth = _this$parentDimension6[0],
              parentHeight = _this$parentDimension6[1];
            if (this.parentRotation % 180 !== 0) {
              this.div.style.maxWidth = "".concat((100 * parentHeight / parentWidth).toFixed(2), "%");
              this.div.style.maxHeight = "".concat((100 * parentWidth / parentHeight).toFixed(2), "%");
            }
            var _this$getInitialTrans = this.getInitialTranslation(),
              _this$getInitialTrans2 = _slicedToArray(_this$getInitialTrans, 2),
              tx = _this$getInitialTrans2[0],
              ty = _this$getInitialTrans2[1];
            this.translate(tx, ty);
            (0, _tools.bindEvents)(this, this.div, ["pointerdown"]);
            return this.div;
          }
        }, {
          key: "pointerdown",
          value: function pointerdown(event) {
            var isMac = _util.FeatureTest.platform.isMac;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              event.preventDefault();
              return;
            }
            _classPrivateFieldSet(_hasBeenClicked, this, true);
            _assertClassBrand(_AnnotationEditor_brand, this, _setUpDragSession).call(this, event);
          }
        }, {
          key: "moveInDOM",
          value: function moveInDOM() {
            var _this$parent2;
            (_this$parent2 = this.parent) === null || _this$parent2 === void 0 || _this$parent2.moveEditorInDOM(this);
          }
        }, {
          key: "_setParentAndPosition",
          value: function _setParentAndPosition(parent, x, y) {
            parent.changeParent(this);
            this.x = x;
            this.y = y;
            this.fixAndSetPosition();
          }
        }, {
          key: "getRect",
          value: function getRect(tx, ty) {
            var scale = this.parentScale;
            var _this$pageDimensions4 = _slicedToArray(this.pageDimensions, 2),
              pageWidth = _this$pageDimensions4[0],
              pageHeight = _this$pageDimensions4[1];
            var _this$pageTranslation = _slicedToArray(this.pageTranslation, 2),
              pageX = _this$pageTranslation[0],
              pageY = _this$pageTranslation[1];
            var shiftX = tx / scale;
            var shiftY = ty / scale;
            var x = this.x * pageWidth;
            var y = this.y * pageHeight;
            var width = this.width * pageWidth;
            var height = this.height * pageHeight;
            switch (this.rotation) {
              case 0:
                return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
              case 90:
                return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
              case 180:
                return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
              case 270:
                return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
              default:
                throw new Error("Invalid rotation");
            }
          }
        }, {
          key: "getRectInCurrentCoords",
          value: function getRectInCurrentCoords(rect, pageHeight) {
            var _rect = _slicedToArray(rect, 4),
              x1 = _rect[0],
              y1 = _rect[1],
              x2 = _rect[2],
              y2 = _rect[3];
            var width = x2 - x1;
            var height = y2 - y1;
            switch (this.rotation) {
              case 0:
                return [x1, pageHeight - y2, width, height];
              case 90:
                return [x1, pageHeight - y1, height, width];
              case 180:
                return [x2, pageHeight - y1, width, height];
              case 270:
                return [x2, pageHeight - y2, height, width];
              default:
                throw new Error("Invalid rotation");
            }
          }
        }, {
          key: "onceAdded",
          value: function onceAdded() {}
        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return false;
          }
        }, {
          key: "enableEditMode",
          value: function enableEditMode() {
            _classPrivateFieldSet(_isInEditMode, this, true);
          }
        }, {
          key: "disableEditMode",
          value: function disableEditMode() {
            _classPrivateFieldSet(_isInEditMode, this, false);
          }
        }, {
          key: "isInEditMode",
          value: function isInEditMode() {
            return _classPrivateFieldGet(_isInEditMode, this);
          }
        }, {
          key: "shouldGetKeyboardEvents",
          value: function shouldGetKeyboardEvents() {
            return false;
          }
        }, {
          key: "needsToBeRebuilt",
          value: function needsToBeRebuilt() {
            return this.div && !this.isAttachedToDOM;
          }
        }, {
          key: "rebuild",
          value: function rebuild() {
            var _this$div2, _this$div3;
            (_this$div2 = this.div) === null || _this$div2 === void 0 || _this$div2.addEventListener("focusin", _classPrivateFieldGet(_boundFocusin, this));
            (_this$div3 = this.div) === null || _this$div3 === void 0 || _this$div3.addEventListener("focusout", _classPrivateFieldGet(_boundFocusout, this));
          }
        }, {
          key: "serialize",
          value: function serialize() {
            var isForCopying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            (0, _util.unreachable)("An editor must be serializable");
          }
        }, {
          key: "remove",
          value: function remove() {
            var _classPrivateFieldGet6;
            this.div.removeEventListener("focusin", _classPrivateFieldGet(_boundFocusin, this));
            this.div.removeEventListener("focusout", _classPrivateFieldGet(_boundFocusout, this));
            if (!this.isEmpty()) {
              this.commit();
            }
            if (this.parent) {
              this.parent.remove(this);
            } else {
              this._uiManager.removeEditor(this);
            }
            (_classPrivateFieldGet6 = _classPrivateFieldGet(_altTextButton, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.remove();
            _classPrivateFieldSet(_altTextButton, this, null);
            _classPrivateFieldSet(_altTextTooltip, this, null);
          }
        }, {
          key: "isResizable",
          get: function get() {
            return false;
          }
        }, {
          key: "makeResizable",
          value: function makeResizable() {
            if (this.isResizable) {
              _assertClassBrand(_AnnotationEditor_brand, this, _createResizers).call(this);
              _classPrivateFieldGet(_resizersDiv, this).classList.remove("hidden");
            }
          }
        }, {
          key: "select",
          value: function select() {
            var _this$div4;
            this.makeResizable();
            (_this$div4 = this.div) === null || _this$div4 === void 0 || _this$div4.classList.add("selectedEditor");
          }
        }, {
          key: "unselect",
          value: function unselect() {
            var _classPrivateFieldGet7, _this$div5, _this$div6;
            (_classPrivateFieldGet7 = _classPrivateFieldGet(_resizersDiv, this)) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.classList.add("hidden");
            (_this$div5 = this.div) === null || _this$div5 === void 0 || _this$div5.classList.remove("selectedEditor");
            if ((_this$div6 = this.div) !== null && _this$div6 !== void 0 && _this$div6.contains(document.activeElement)) {
              this._uiManager.currentLayer.div.focus();
            }
          }
        }, {
          key: "updateParams",
          value: function updateParams(type, value) {}
        }, {
          key: "disableEditing",
          value: function disableEditing() {
            if (_classPrivateFieldGet(_altTextButton, this)) {
              _classPrivateFieldGet(_altTextButton, this).hidden = true;
            }
          }
        }, {
          key: "enableEditing",
          value: function enableEditing() {
            if (_classPrivateFieldGet(_altTextButton, this)) {
              _classPrivateFieldGet(_altTextButton, this).hidden = false;
            }
          }
        }, {
          key: "enterInEditMode",
          value: function enterInEditMode() {}
        }, {
          key: "contentDiv",
          get: function get() {
            return this.div;
          }
        }, {
          key: "isEditing",
          get: function get() {
            return _classPrivateFieldGet(_isEditing, this);
          },
          set: function set(value) {
            _classPrivateFieldSet(_isEditing, this, value);
            if (!this.parent) {
              return;
            }
            if (value) {
              this.parent.setSelected(this);
              this.parent.setActiveEditor(this);
            } else {
              this.parent.setActiveEditor(null);
            }
          }
        }, {
          key: "setAspectRatio",
          value: function setAspectRatio(width, height) {
            _classPrivateFieldSet(_keepAspectRatio, this, true);
            var aspectRatio = width / height;
            var style = this.div.style;
            style.aspectRatio = aspectRatio;
            style.height = "auto";
          }
        }], [{
          key: "_defaultLineColor",
          get: function get() {
            return (0, _util.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
          }
        }, {
          key: "deleteAnnotationElement",
          value: function deleteAnnotationElement(editor) {
            var fakeEditor = new FakeEditor({
              id: editor.parent.getNextId(),
              parent: editor.parent,
              uiManager: editor._uiManager
            });
            fakeEditor.annotationElementId = editor.annotationElementId;
            fakeEditor.deleted = true;
            fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
          }
        }, {
          key: "initialize",
          value: function initialize(l10n) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            AnnotationEditor._l10nPromise || (AnnotationEditor._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map(function (str) {
              return [str, l10n.get(str)];
            })));
            if (options !== null && options !== void 0 && options.strings) {
              var _iterator18 = _createForOfIteratorHelper(options.strings),
                _step18;
              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  var str = _step18.value;
                  AnnotationEditor._l10nPromise.set(str, l10n.get(str));
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }
            }
            if (AnnotationEditor._borderLineWidth !== -1) {
              return;
            }
            var style = getComputedStyle(document.documentElement);
            AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
          }
        }, {
          key: "updateDefaultParams",
          value: function updateDefaultParams(_type, _value) {}
        }, {
          key: "defaultPropertiesToUpdate",
          get: function get() {
            return [];
          }
        }, {
          key: "isHandlingMimeForPasting",
          value: function isHandlingMimeForPasting(mime) {
            return false;
          }
        }, {
          key: "paste",
          value: function paste(item, parent) {
            (0, _util.unreachable)("Not implemented");
          }
        }, {
          key: "deserialize",
          value: function deserialize(data, parent, uiManager) {
            var editor = new this.prototype.constructor({
              parent: parent,
              id: parent.getNextId(),
              uiManager: uiManager
            });
            editor.rotation = data.rotation;
            var _editor$pageDimension = _slicedToArray(editor.pageDimensions, 2),
              pageWidth = _editor$pageDimension[0],
              pageHeight = _editor$pageDimension[1];
            var _editor$getRectInCurr = editor.getRectInCurrentCoords(data.rect, pageHeight),
              _editor$getRectInCurr2 = _slicedToArray(_editor$getRectInCurr, 4),
              x = _editor$getRectInCurr2[0],
              y = _editor$getRectInCurr2[1],
              width = _editor$getRectInCurr2[2],
              height = _editor$getRectInCurr2[3];
            editor.x = x / pageWidth;
            editor.y = y / pageHeight;
            editor.width = width / pageWidth;
            editor.height = height / pageHeight;
            return editor;
          }
        }, {
          key: "MIN_SIZE",
          get: function get() {
            return 16;
          }
        }]);
      }();
      _AnnotationEditor = AnnotationEditor;
      function _translate(_ref26, x, y) {
        var _ref27 = _slicedToArray(_ref26, 2),
          width = _ref27[0],
          height = _ref27[1];
        var _this$screenToPageTra3 = this.screenToPageTranslation(x, y);
        var _this$screenToPageTra4 = _slicedToArray(_this$screenToPageTra3, 2);
        x = _this$screenToPageTra4[0];
        y = _this$screenToPageTra4[1];
        this.x += x / width;
        this.y += y / height;
        this.fixAndSetPosition();
      }
      function _getBaseTranslation() {
        var _this$parentDimension7 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension7[0],
          parentHeight = _this$parentDimension7[1];
        var _borderLineWidth = _AnnotationEditor._borderLineWidth;
        var x = _borderLineWidth / parentWidth;
        var y = _borderLineWidth / parentHeight;
        switch (this.rotation) {
          case 90:
            return [-x, y];
          case 180:
            return [x, y];
          case 270:
            return [x, -y];
          default:
            return [-x, -y];
        }
      }
      function _rotatePoint(x, y, angle) {
        switch (angle) {
          case 90:
            return [y, -x];
          case 180:
            return [-x, -y];
          case 270:
            return [-y, x];
          default:
            return [x, y];
        }
      }
      function _getRotationMatrix(rotation) {
        switch (rotation) {
          case 90:
            {
              var _this$pageDimensions5 = _slicedToArray(this.pageDimensions, 2),
                pageWidth = _this$pageDimensions5[0],
                pageHeight = _this$pageDimensions5[1];
              return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
            }
          case 180:
            return [-1, 0, 0, -1];
          case 270:
            {
              var _this$pageDimensions6 = _slicedToArray(this.pageDimensions, 2),
                _pageWidth2 = _this$pageDimensions6[0],
                _pageHeight2 = _this$pageDimensions6[1];
              return [0, _pageWidth2 / _pageHeight2, -_pageHeight2 / _pageWidth2, 0];
            }
          default:
            return [1, 0, 0, 1];
        }
      }
      function _createResizers() {
        if (_classPrivateFieldGet(_resizersDiv, this)) {
          return;
        }
        _classPrivateFieldSet(_resizersDiv, this, document.createElement("div"));
        _classPrivateFieldGet(_resizersDiv, this).classList.add("resizers");
        var classes = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
        if (!this._willKeepAspectRatio) {
          classes.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
        }
        for (var _i3 = 0, _classes = classes; _i3 < _classes.length; _i3++) {
          var name = _classes[_i3];
          var div = document.createElement("div");
          _classPrivateFieldGet(_resizersDiv, this).append(div);
          div.classList.add("resizer", name);
          div.addEventListener("pointerdown", _assertClassBrand(_AnnotationEditor_brand, this, _resizerPointerdown).bind(this, name));
          div.addEventListener("contextmenu", _display_utils.noContextMenu);
        }
        this.div.prepend(_classPrivateFieldGet(_resizersDiv, this));
      }
      function _resizerPointerdown(name, event) {
        var _this26 = this;
        event.preventDefault();
        var isMac = _util.FeatureTest.platform.isMac;
        if (event.button !== 0 || event.ctrlKey && isMac) {
          return;
        }
        var boundResizerPointermove = _assertClassBrand(_AnnotationEditor_brand, this, _resizerPointermove).bind(this, name);
        var savedDraggable = this._isDraggable;
        this._isDraggable = false;
        var pointerMoveOptions = {
          passive: true,
          capture: true
        };
        window.addEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
        var savedX = this.x;
        var savedY = this.y;
        var savedWidth = this.width;
        var savedHeight = this.height;
        var savedParentCursor = this.parent.div.style.cursor;
        var savedCursor = this.div.style.cursor;
        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
        var _pointerUpCallback = function pointerUpCallback() {
          _this26._isDraggable = savedDraggable;
          window.removeEventListener("pointerup", _pointerUpCallback);
          window.removeEventListener("blur", _pointerUpCallback);
          window.removeEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
          _this26.parent.div.style.cursor = savedParentCursor;
          _this26.div.style.cursor = savedCursor;
          var newX = _this26.x;
          var newY = _this26.y;
          var newWidth = _this26.width;
          var newHeight = _this26.height;
          if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
            return;
          }
          _this26.addCommands({
            cmd: function cmd() {
              _this26.width = newWidth;
              _this26.height = newHeight;
              _this26.x = newX;
              _this26.y = newY;
              var _this26$parentDimensi = _slicedToArray(_this26.parentDimensions, 2),
                parentWidth = _this26$parentDimensi[0],
                parentHeight = _this26$parentDimensi[1];
              _this26.setDims(parentWidth * newWidth, parentHeight * newHeight);
              _this26.fixAndSetPosition();
            },
            undo: function undo() {
              _this26.width = savedWidth;
              _this26.height = savedHeight;
              _this26.x = savedX;
              _this26.y = savedY;
              var _this26$parentDimensi2 = _slicedToArray(_this26.parentDimensions, 2),
                parentWidth = _this26$parentDimensi2[0],
                parentHeight = _this26$parentDimensi2[1];
              _this26.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
              _this26.fixAndSetPosition();
            },
            mustExec: true
          });
        };
        window.addEventListener("pointerup", _pointerUpCallback);
        window.addEventListener("blur", _pointerUpCallback);
      }
      function _resizerPointermove(name, event) {
        var _this$parentDimension8 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension8[0],
          parentHeight = _this$parentDimension8[1];
        var savedX = this.x;
        var savedY = this.y;
        var savedWidth = this.width;
        var savedHeight = this.height;
        var minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
        var minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
        var round = function round(x) {
          return Math.round(x * 10000) / 10000;
        };
        var rotationMatrix = _assertClassBrand(_AnnotationEditor_brand, this, _getRotationMatrix).call(this, this.rotation);
        var transf = function transf(x, y) {
          return [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
        };
        var invRotationMatrix = _assertClassBrand(_AnnotationEditor_brand, this, _getRotationMatrix).call(this, 360 - this.rotation);
        var invTransf = function invTransf(x, y) {
          return [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
        };
        var getPoint;
        var getOpposite;
        var isDiagonal = false;
        var isHorizontal = false;
        switch (name) {
          case "topLeft":
            isDiagonal = true;
            getPoint = function getPoint(w, h) {
              return [0, 0];
            };
            getOpposite = function getOpposite(w, h) {
              return [w, h];
            };
            break;
          case "topMiddle":
            getPoint = function getPoint(w, h) {
              return [w / 2, 0];
            };
            getOpposite = function getOpposite(w, h) {
              return [w / 2, h];
            };
            break;
          case "topRight":
            isDiagonal = true;
            getPoint = function getPoint(w, h) {
              return [w, 0];
            };
            getOpposite = function getOpposite(w, h) {
              return [0, h];
            };
            break;
          case "middleRight":
            isHorizontal = true;
            getPoint = function getPoint(w, h) {
              return [w, h / 2];
            };
            getOpposite = function getOpposite(w, h) {
              return [0, h / 2];
            };
            break;
          case "bottomRight":
            isDiagonal = true;
            getPoint = function getPoint(w, h) {
              return [w, h];
            };
            getOpposite = function getOpposite(w, h) {
              return [0, 0];
            };
            break;
          case "bottomMiddle":
            getPoint = function getPoint(w, h) {
              return [w / 2, h];
            };
            getOpposite = function getOpposite(w, h) {
              return [w / 2, 0];
            };
            break;
          case "bottomLeft":
            isDiagonal = true;
            getPoint = function getPoint(w, h) {
              return [0, h];
            };
            getOpposite = function getOpposite(w, h) {
              return [w, 0];
            };
            break;
          case "middleLeft":
            isHorizontal = true;
            getPoint = function getPoint(w, h) {
              return [0, h / 2];
            };
            getOpposite = function getOpposite(w, h) {
              return [w, h / 2];
            };
            break;
        }
        var point = getPoint(savedWidth, savedHeight);
        var oppositePoint = getOpposite(savedWidth, savedHeight);
        var transfOppositePoint = transf.apply(void 0, _toConsumableArray(oppositePoint));
        var oppositeX = round(savedX + transfOppositePoint[0]);
        var oppositeY = round(savedY + transfOppositePoint[1]);
        var ratioX = 1;
        var ratioY = 1;
        var _this$screenToPageTra5 = this.screenToPageTranslation(event.movementX, event.movementY),
          _this$screenToPageTra6 = _slicedToArray(_this$screenToPageTra5, 2),
          deltaX = _this$screenToPageTra6[0],
          deltaY = _this$screenToPageTra6[1];
        var _invTransf = invTransf(deltaX / parentWidth, deltaY / parentHeight);
        var _invTransf2 = _slicedToArray(_invTransf, 2);
        deltaX = _invTransf2[0];
        deltaY = _invTransf2[1];
        if (isDiagonal) {
          var oldDiag = Math.hypot(savedWidth, savedHeight);
          ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
        } else if (isHorizontal) {
          ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
        } else {
          ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
        }
        var newWidth = round(savedWidth * ratioX);
        var newHeight = round(savedHeight * ratioY);
        transfOppositePoint = transf.apply(void 0, _toConsumableArray(getOpposite(newWidth, newHeight)));
        var newX = oppositeX - transfOppositePoint[0];
        var newY = oppositeY - transfOppositePoint[1];
        this.width = newWidth;
        this.height = newHeight;
        this.x = newX;
        this.y = newY;
        this.setDims(parentWidth * newWidth, parentHeight * newHeight);
        this.fixAndSetPosition();
      }
      function _setAltTextButtonState() {
        return _setAltTextButtonState2.apply(this, arguments);
      }
      function _setAltTextButtonState2() {
        _setAltTextButtonState2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          var _this28 = this;
          var button, _classPrivateFieldGet8, tooltip, id, DELAY_TO_SHOW_TOOLTIP;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                button = _classPrivateFieldGet(_altTextButton, this);
                if (button) {
                  _context8.next = 3;
                  break;
                }
                return _context8.abrupt("return");
              case 3:
                if (!(!_classPrivateFieldGet(_altText, this) && !_classPrivateFieldGet(_altTextDecorative, this))) {
                  _context8.next = 7;
                  break;
                }
                button.classList.remove("done");
                (_classPrivateFieldGet8 = _classPrivateFieldGet(_altTextTooltip, this)) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.remove();
                return _context8.abrupt("return");
              case 7:
                _AnnotationEditor._l10nPromise.get("editor_alt_text_edit_button_label").then(function (msg) {
                  button.setAttribute("aria-label", msg);
                });
                tooltip = _classPrivateFieldGet(_altTextTooltip, this);
                if (!tooltip) {
                  _classPrivateFieldSet(_altTextTooltip, this, tooltip = document.createElement("span"));
                  tooltip.className = "tooltip";
                  tooltip.setAttribute("role", "tooltip");
                  id = tooltip.id = "alt-text-tooltip-".concat(this.id);
                  button.setAttribute("aria-describedby", id);
                  DELAY_TO_SHOW_TOOLTIP = 100;
                  button.addEventListener("mouseenter", function () {
                    _classPrivateFieldSet(_altTextTooltipTimeout, _this28, setTimeout(function () {
                      _classPrivateFieldSet(_altTextTooltipTimeout, _this28, null);
                      _classPrivateFieldGet(_altTextTooltip, _this28).classList.add("show");
                      _this28._uiManager._eventBus.dispatch("reporttelemetry", {
                        source: _this28,
                        details: {
                          type: "editing",
                          subtype: _this28.editorType,
                          data: {
                            action: "alt_text_tooltip"
                          }
                        }
                      });
                    }, DELAY_TO_SHOW_TOOLTIP));
                  });
                  button.addEventListener("mouseleave", function () {
                    var _classPrivateFieldGet9;
                    clearTimeout(_classPrivateFieldGet(_altTextTooltipTimeout, _this28));
                    _classPrivateFieldSet(_altTextTooltipTimeout, _this28, null);
                    (_classPrivateFieldGet9 = _classPrivateFieldGet(_altTextTooltip, _this28)) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.classList.remove("show");
                  });
                }
                button.classList.add("done");
                if (!_classPrivateFieldGet(_altTextDecorative, this)) {
                  _context8.next = 17;
                  break;
                }
                _context8.next = 14;
                return _AnnotationEditor._l10nPromise.get("editor_alt_text_decorative_tooltip");
              case 14:
                _context8.t0 = _context8.sent;
                _context8.next = 18;
                break;
              case 17:
                _context8.t0 = _classPrivateFieldGet(_altText, this);
              case 18:
                tooltip.innerText = _context8.t0;
                if (!tooltip.parentNode) {
                  button.append(tooltip);
                }
              case 20:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        return _setAltTextButtonState2.apply(this, arguments);
      }
      function _setUpDragSession(event) {
        var _this27 = this;
        if (!this._isDraggable) {
          return;
        }
        var isSelected = this._uiManager.isSelected(this);
        this._uiManager.setUpDragSession();
        var pointerMoveOptions, pointerMoveCallback;
        if (isSelected) {
          pointerMoveOptions = {
            passive: true,
            capture: true
          };
          pointerMoveCallback = function pointerMoveCallback(e) {
            var _this27$screenToPageT = _this27.screenToPageTranslation(e.movementX, e.movementY),
              _this27$screenToPageT2 = _slicedToArray(_this27$screenToPageT, 2),
              tx = _this27$screenToPageT2[0],
              ty = _this27$screenToPageT2[1];
            _this27._uiManager.dragSelectedEditors(tx, ty);
          };
          window.addEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
        }
        var _pointerUpCallback2 = function pointerUpCallback() {
          window.removeEventListener("pointerup", _pointerUpCallback2);
          window.removeEventListener("blur", _pointerUpCallback2);
          if (isSelected) {
            window.removeEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
          }
          _classPrivateFieldSet(_hasBeenClicked, _this27, false);
          if (!_this27._uiManager.endDragSession()) {
            var isMac = _util.FeatureTest.platform.isMac;
            if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
              _this27.parent.toggleSelected(_this27);
            } else {
              _this27.parent.setSelected(_this27);
            }
          }
        };
        window.addEventListener("pointerup", _pointerUpCallback2);
        window.addEventListener("blur", _pointerUpCallback2);
      }
      _defineProperty(AnnotationEditor, "_borderLineWidth", -1);
      _defineProperty(AnnotationEditor, "_colorManager", new _tools.ColorManager());
      _defineProperty(AnnotationEditor, "_zIndex", 1);
      _defineProperty(AnnotationEditor, "SMALL_EDITOR_SIZE", 0);
      exports.AnnotationEditor = AnnotationEditor;
      var FakeEditor = /*#__PURE__*/function (_AnnotationEditor2) {
        function FakeEditor(params) {
          var _this25;
          _classCallCheck(this, FakeEditor);
          _this25 = _callSuper(this, FakeEditor, [params]);
          _this25.annotationElementId = params.annotationElementId;
          _this25.deleted = true;
          return _this25;
        }
        _inherits(FakeEditor, _AnnotationEditor2);
        return _createClass(FakeEditor, [{
          key: "serialize",
          value: function serialize() {
            return {
              id: this.annotationElementId,
              deleted: true,
              pageIndex: this.pageIndex
            };
          }
        }]);
      }(AnnotationEditor);
      /***/
    }), (/* 5 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      var _ImageManager;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;
      exports.bindEvents = bindEvents;
      exports.opacityToHex = opacityToHex;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      function bindEvents(obj, element, names) {
        var _iterator19 = _createForOfIteratorHelper(names),
          _step19;
        try {
          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
            var name = _step19.value;
            element.addEventListener(name, obj[name].bind(obj));
          }
        } catch (err) {
          _iterator19.e(err);
        } finally {
          _iterator19.f();
        }
      }
      function opacityToHex(opacity) {
        return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
      }
      var _id = /*#__PURE__*/new WeakMap();
      var IdManager = /*#__PURE__*/function () {
        function IdManager() {
          _classCallCheck(this, IdManager);
          _classPrivateFieldInitSpec(this, _id, 0);
        }
        return _createClass(IdManager, [{
          key: "getId",
          value: function getId() {
            var _this$id, _this$id2;
            return "".concat(_util.AnnotationEditorPrefix).concat((_classPrivateFieldSet(_id, this, (_this$id = _classPrivateFieldGet(_id, this), _this$id2 = _this$id++, _this$id)), _this$id2));
          }
        }]);
      }();
      var _baseId = /*#__PURE__*/new WeakMap();
      var _id2 = /*#__PURE__*/new WeakMap();
      var _cache = /*#__PURE__*/new WeakMap();
      var _ImageManager_brand = /*#__PURE__*/new WeakSet();
      var ImageManager = /*#__PURE__*/function () {
        function ImageManager() {
          _classCallCheck(this, ImageManager);
          _classPrivateMethodInitSpec(this, _ImageManager_brand);
          _classPrivateFieldInitSpec(this, _baseId, (0, _util.getUuid)());
          _classPrivateFieldInitSpec(this, _id2, 0);
          _classPrivateFieldInitSpec(this, _cache, null);
        }
        return _createClass(ImageManager, [{
          key: "getFromFile",
          value: function () {
            var _getFromFile = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(file) {
              var lastModified, name, size, type;
              return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    lastModified = file.lastModified, name = file.name, size = file.size, type = file.type;
                    return _context9.abrupt("return", _assertClassBrand(_ImageManager_brand, this, _get).call(this, "".concat(lastModified, "_").concat(name, "_").concat(size, "_").concat(type), file));
                  case 2:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9, this);
            }));
            function getFromFile(_x4) {
              return _getFromFile.apply(this, arguments);
            }
            return getFromFile;
          }()
        }, {
          key: "getFromUrl",
          value: function () {
            var _getFromUrl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(url) {
              return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    return _context10.abrupt("return", _assertClassBrand(_ImageManager_brand, this, _get).call(this, url, url));
                  case 1:
                  case "end":
                    return _context10.stop();
                }
              }, _callee10, this);
            }));
            function getFromUrl(_x5) {
              return _getFromUrl.apply(this, arguments);
            }
            return getFromUrl;
          }()
        }, {
          key: "getFromId",
          value: function () {
            var _getFromId = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(id) {
              var data;
              return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                while (1) switch (_context11.prev = _context11.next) {
                  case 0:
                    _classPrivateFieldGet(_cache, this) || _classPrivateFieldSet(_cache, this, new Map());
                    data = _classPrivateFieldGet(_cache, this).get(id);
                    if (data) {
                      _context11.next = 4;
                      break;
                    }
                    return _context11.abrupt("return", null);
                  case 4:
                    if (!data.bitmap) {
                      _context11.next = 7;
                      break;
                    }
                    data.refCounter += 1;
                    return _context11.abrupt("return", data);
                  case 7:
                    if (!data.file) {
                      _context11.next = 9;
                      break;
                    }
                    return _context11.abrupt("return", this.getFromFile(data.file));
                  case 9:
                    return _context11.abrupt("return", this.getFromUrl(data.url));
                  case 10:
                  case "end":
                    return _context11.stop();
                }
              }, _callee11, this);
            }));
            function getFromId(_x6) {
              return _getFromId.apply(this, arguments);
            }
            return getFromId;
          }()
        }, {
          key: "getSvgUrl",
          value: function getSvgUrl(id) {
            var data = _classPrivateFieldGet(_cache, this).get(id);
            if (!(data !== null && data !== void 0 && data.isSvg)) {
              return null;
            }
            return data.svgUrl;
          }
        }, {
          key: "deleteId",
          value: function deleteId(id) {
            _classPrivateFieldGet(_cache, this) || _classPrivateFieldSet(_cache, this, new Map());
            var data = _classPrivateFieldGet(_cache, this).get(id);
            if (!data) {
              return;
            }
            data.refCounter -= 1;
            if (data.refCounter !== 0) {
              return;
            }
            data.bitmap = null;
          }
        }, {
          key: "isValidId",
          value: function isValidId(id) {
            return id.startsWith("image_".concat(_classPrivateFieldGet(_baseId, this), "_"));
          }
        }], [{
          key: "_isSVGFittingCanvas",
          get: function get() {
            var svg = "data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>";
            var canvas = new OffscreenCanvas(1, 3);
            var ctx = canvas.getContext("2d");
            var image = new Image();
            image.src = svg;
            var promise = image.decode().then(function () {
              ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
              return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
            });
            return (0, _util.shadow)(this, "_isSVGFittingCanvas", promise);
          }
        }]);
      }();
      _ImageManager = ImageManager;
      function _get(_x7, _x8) {
        return _get2.apply(this, arguments);
      }
      function _get2() {
        _get2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(key, rawData) {
          var _data;
          var data, _this$id3, _this$id4, image, response, mustRemoveAspectRatioPromise, fileReader, imageElement, imagePromise;
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                _classPrivateFieldGet(_cache, this) || _classPrivateFieldSet(_cache, this, new Map());
                data = _classPrivateFieldGet(_cache, this).get(key);
                if (!(data === null)) {
                  _context13.next = 4;
                  break;
                }
                return _context13.abrupt("return", null);
              case 4:
                if (!((_data = data) !== null && _data !== void 0 && _data.bitmap)) {
                  _context13.next = 7;
                  break;
                }
                data.refCounter += 1;
                return _context13.abrupt("return", data);
              case 7:
                _context13.prev = 7;
                data || (data = {
                  bitmap: null,
                  id: "image_".concat(_classPrivateFieldGet(_baseId, this), "_").concat((_classPrivateFieldSet(_id2, this, (_this$id3 = _classPrivateFieldGet(_id2, this), _this$id4 = _this$id3++, _this$id3)), _this$id4)),
                  refCounter: 0,
                  isSvg: false
                });
                if (!(typeof rawData === "string")) {
                  _context13.next = 21;
                  break;
                }
                data.url = rawData;
                _context13.next = 13;
                return fetch(rawData);
              case 13:
                response = _context13.sent;
                if (response.ok) {
                  _context13.next = 16;
                  break;
                }
                throw new Error(response.statusText);
              case 16:
                _context13.next = 18;
                return response.blob();
              case 18:
                image = _context13.sent;
                _context13.next = 22;
                break;
              case 21:
                image = data.file = rawData;
              case 22:
                if (!(image.type === "image/svg+xml")) {
                  _context13.next = 32;
                  break;
                }
                mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
                fileReader = new FileReader();
                imageElement = new Image();
                imagePromise = new Promise(function (resolve, reject) {
                  imageElement.onload = function () {
                    data.bitmap = imageElement;
                    data.isSvg = true;
                    resolve();
                  };
                  fileReader.onload = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                    var url;
                    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                      while (1) switch (_context12.prev = _context12.next) {
                        case 0:
                          url = data.svgUrl = fileReader.result;
                          _context12.next = 3;
                          return mustRemoveAspectRatioPromise;
                        case 3:
                          if (!_context12.sent) {
                            _context12.next = 7;
                            break;
                          }
                          _context12.t0 = "".concat(url, "#svgView(preserveAspectRatio(none))");
                          _context12.next = 8;
                          break;
                        case 7:
                          _context12.t0 = url;
                        case 8:
                          imageElement.src = _context12.t0;
                        case 9:
                        case "end":
                          return _context12.stop();
                      }
                    }, _callee12);
                  }));
                  imageElement.onerror = fileReader.onerror = reject;
                });
                fileReader.readAsDataURL(image);
                _context13.next = 30;
                return imagePromise;
              case 30:
                _context13.next = 35;
                break;
              case 32:
                _context13.next = 34;
                return createImageBitmap(image);
              case 34:
                data.bitmap = _context13.sent;
              case 35:
                data.refCounter = 1;
                _context13.next = 42;
                break;
              case 38:
                _context13.prev = 38;
                _context13.t0 = _context13["catch"](7);
                console.error(_context13.t0);
                data = null;
              case 42:
                _classPrivateFieldGet(_cache, this).set(key, data);
                if (data) {
                  _classPrivateFieldGet(_cache, this).set(data.id, data);
                }
                return _context13.abrupt("return", data);
              case 45:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this, [[7, 38]]);
        }));
        return _get2.apply(this, arguments);
      }
      var _commands = /*#__PURE__*/new WeakMap();
      var _locked = /*#__PURE__*/new WeakMap();
      var _maxSize = /*#__PURE__*/new WeakMap();
      var _position = /*#__PURE__*/new WeakMap();
      var CommandManager = /*#__PURE__*/function () {
        function CommandManager() {
          var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;
          _classCallCheck(this, CommandManager);
          _classPrivateFieldInitSpec(this, _commands, []);
          _classPrivateFieldInitSpec(this, _locked, false);
          _classPrivateFieldInitSpec(this, _maxSize, void 0);
          _classPrivateFieldInitSpec(this, _position, -1);
          _classPrivateFieldSet(_maxSize, this, maxSize);
        }
        return _createClass(CommandManager, [{
          key: "add",
          value: function add(_ref28) {
            var cmd = _ref28.cmd,
              undo = _ref28.undo,
              mustExec = _ref28.mustExec,
              _ref28$type = _ref28.type,
              type = _ref28$type === void 0 ? NaN : _ref28$type,
              _ref28$overwriteIfSam = _ref28.overwriteIfSameType,
              overwriteIfSameType = _ref28$overwriteIfSam === void 0 ? false : _ref28$overwriteIfSam,
              _ref28$keepUndo = _ref28.keepUndo,
              keepUndo = _ref28$keepUndo === void 0 ? false : _ref28$keepUndo;
            if (mustExec) {
              cmd();
            }
            if (_classPrivateFieldGet(_locked, this)) {
              return;
            }
            var save = {
              cmd: cmd,
              undo: undo,
              type: type
            };
            if (_classPrivateFieldGet(_position, this) === -1) {
              if (_classPrivateFieldGet(_commands, this).length > 0) {
                _classPrivateFieldGet(_commands, this).length = 0;
              }
              _classPrivateFieldSet(_position, this, 0);
              _classPrivateFieldGet(_commands, this).push(save);
              return;
            }
            if (overwriteIfSameType && _classPrivateFieldGet(_commands, this)[_classPrivateFieldGet(_position, this)].type === type) {
              if (keepUndo) {
                save.undo = _classPrivateFieldGet(_commands, this)[_classPrivateFieldGet(_position, this)].undo;
              }
              _classPrivateFieldGet(_commands, this)[_classPrivateFieldGet(_position, this)] = save;
              return;
            }
            var next = _classPrivateFieldGet(_position, this) + 1;
            if (next === _classPrivateFieldGet(_maxSize, this)) {
              _classPrivateFieldGet(_commands, this).splice(0, 1);
            } else {
              _classPrivateFieldSet(_position, this, next);
              if (next < _classPrivateFieldGet(_commands, this).length) {
                _classPrivateFieldGet(_commands, this).splice(next);
              }
            }
            _classPrivateFieldGet(_commands, this).push(save);
          }
        }, {
          key: "undo",
          value: function undo() {
            if (_classPrivateFieldGet(_position, this) === -1) {
              return;
            }
            _classPrivateFieldSet(_locked, this, true);
            _classPrivateFieldGet(_commands, this)[_classPrivateFieldGet(_position, this)].undo();
            _classPrivateFieldSet(_locked, this, false);
            _classPrivateFieldSet(_position, this, _classPrivateFieldGet(_position, this) - 1);
          }
        }, {
          key: "redo",
          value: function redo() {
            if (_classPrivateFieldGet(_position, this) < _classPrivateFieldGet(_commands, this).length - 1) {
              _classPrivateFieldSet(_position, this, _classPrivateFieldGet(_position, this) + 1);
              _classPrivateFieldSet(_locked, this, true);
              _classPrivateFieldGet(_commands, this)[_classPrivateFieldGet(_position, this)].cmd();
              _classPrivateFieldSet(_locked, this, false);
            }
          }
        }, {
          key: "hasSomethingToUndo",
          value: function hasSomethingToUndo() {
            return _classPrivateFieldGet(_position, this) !== -1;
          }
        }, {
          key: "hasSomethingToRedo",
          value: function hasSomethingToRedo() {
            return _classPrivateFieldGet(_position, this) < _classPrivateFieldGet(_commands, this).length - 1;
          }
        }, {
          key: "destroy",
          value: function destroy() {
            _classPrivateFieldSet(_commands, this, null);
          }
        }]);
      }();
      exports.CommandManager = CommandManager;
      var _KeyboardManager_brand = /*#__PURE__*/new WeakSet();
      var KeyboardManager = /*#__PURE__*/function () {
        function KeyboardManager(callbacks) {
          _classCallCheck(this, KeyboardManager);
          _classPrivateMethodInitSpec(this, _KeyboardManager_brand);
          this.buffer = [];
          this.callbacks = new Map();
          this.allKeys = new Set();
          var isMac = _util.FeatureTest.platform.isMac;
          var _iterator20 = _createForOfIteratorHelper(callbacks),
            _step20;
          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var _step20$value = _slicedToArray(_step20.value, 3),
                keys = _step20$value[0],
                callback = _step20$value[1],
                _step20$value$ = _step20$value[2],
                options = _step20$value$ === void 0 ? {} : _step20$value$;
              var _iterator21 = _createForOfIteratorHelper(keys),
                _step21;
              try {
                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                  var key = _step21.value;
                  var isMacKey = key.startsWith("mac+");
                  if (isMac && isMacKey) {
                    this.callbacks.set(key.slice(4), {
                      callback: callback,
                      options: options
                    });
                    this.allKeys.add(key.split("+").at(-1));
                  } else if (!isMac && !isMacKey) {
                    this.callbacks.set(key, {
                      callback: callback,
                      options: options
                    });
                    this.allKeys.add(key.split("+").at(-1));
                  }
                }
              } catch (err) {
                _iterator21.e(err);
              } finally {
                _iterator21.f();
              }
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }
        }
        return _createClass(KeyboardManager, [{
          key: "exec",
          value: function exec(self, event) {
            if (!this.allKeys.has(event.key)) {
              return;
            }
            var info = this.callbacks.get(_assertClassBrand(_KeyboardManager_brand, this, _serialize).call(this, event));
            if (!info) {
              return;
            }
            var callback = info.callback,
              _info$options = info.options,
              _info$options$bubbles = _info$options.bubbles,
              bubbles = _info$options$bubbles === void 0 ? false : _info$options$bubbles,
              _info$options$args = _info$options.args,
              args = _info$options$args === void 0 ? [] : _info$options$args,
              _info$options$checker = _info$options.checker,
              checker = _info$options$checker === void 0 ? null : _info$options$checker;
            if (checker && !checker(self, event)) {
              return;
            }
            callback.bind.apply(callback, [self].concat(_toConsumableArray(args)))();
            if (!bubbles) {
              event.stopPropagation();
              event.preventDefault();
            }
          }
        }]);
      }();
      function _serialize(event) {
        if (event.altKey) {
          this.buffer.push("alt");
        }
        if (event.ctrlKey) {
          this.buffer.push("ctrl");
        }
        if (event.metaKey) {
          this.buffer.push("meta");
        }
        if (event.shiftKey) {
          this.buffer.push("shift");
        }
        this.buffer.push(event.key);
        var str = this.buffer.join("+");
        this.buffer.length = 0;
        return str;
      }
      exports.KeyboardManager = KeyboardManager;
      var ColorManager = /*#__PURE__*/function () {
        function ColorManager() {
          _classCallCheck(this, ColorManager);
        }
        return _createClass(ColorManager, [{
          key: "_colors",
          get: function get() {
            var colors = new Map([["CanvasText", null], ["Canvas", null]]);
            (0, _display_utils.getColorValues)(colors);
            return (0, _util.shadow)(this, "_colors", colors);
          }
        }, {
          key: "convert",
          value: function convert(color) {
            var rgb = (0, _display_utils.getRGB)(color);
            if (!window.matchMedia("(forced-colors: active)").matches) {
              return rgb;
            }
            var _iterator22 = _createForOfIteratorHelper(this._colors),
              _step22;
            try {
              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                var _step22$value = _slicedToArray(_step22.value, 2),
                  name = _step22$value[0],
                  RGB = _step22$value[1];
                if (RGB.every(function (x, i) {
                  return x === rgb[i];
                })) {
                  return ColorManager._colorsMapping.get(name);
                }
              }
            } catch (err) {
              _iterator22.e(err);
            } finally {
              _iterator22.f();
            }
            return rgb;
          }
        }, {
          key: "getHexCode",
          value: function getHexCode(name) {
            var _util$Util;
            var rgb = this._colors.get(name);
            if (!rgb) {
              return name;
            }
            return (_util$Util = _util.Util).makeHexColor.apply(_util$Util, _toConsumableArray(rgb));
          }
        }]);
      }();
      _defineProperty(ColorManager, "_colorsMapping", new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
      exports.ColorManager = ColorManager;
      var _activeEditor = /*#__PURE__*/new WeakMap();
      var _allEditors = /*#__PURE__*/new WeakMap();
      var _allLayers = /*#__PURE__*/new WeakMap();
      var _altTextManager = /*#__PURE__*/new WeakMap();
      var _annotationStorage = /*#__PURE__*/new WeakMap();
      var _commandManager = /*#__PURE__*/new WeakMap();
      var _currentPageIndex = /*#__PURE__*/new WeakMap();
      var _deletedAnnotationsElementIds = /*#__PURE__*/new WeakMap();
      var _draggingEditors = /*#__PURE__*/new WeakMap();
      var _editorTypes = /*#__PURE__*/new WeakMap();
      var _editorsToRescale = /*#__PURE__*/new WeakMap();
      var _filterFactory = /*#__PURE__*/new WeakMap();
      var _idManager = /*#__PURE__*/new WeakMap();
      var _isEnabled = /*#__PURE__*/new WeakMap();
      var _isWaiting = /*#__PURE__*/new WeakMap();
      var _lastActiveElement = /*#__PURE__*/new WeakMap();
      var _mode = /*#__PURE__*/new WeakMap();
      var _selectedEditors = /*#__PURE__*/new WeakMap();
      var _pageColors = /*#__PURE__*/new WeakMap();
      var _boundBlur = /*#__PURE__*/new WeakMap();
      var _boundFocus = /*#__PURE__*/new WeakMap();
      var _boundCopy = /*#__PURE__*/new WeakMap();
      var _boundCut = /*#__PURE__*/new WeakMap();
      var _boundPaste = /*#__PURE__*/new WeakMap();
      var _boundKeydown = /*#__PURE__*/new WeakMap();
      var _boundOnEditingAction = /*#__PURE__*/new WeakMap();
      var _boundOnPageChanging = /*#__PURE__*/new WeakMap();
      var _boundOnScaleChanging = /*#__PURE__*/new WeakMap();
      var _boundOnRotationChanging = /*#__PURE__*/new WeakMap();
      var _previousStates = /*#__PURE__*/new WeakMap();
      var _translation = /*#__PURE__*/new WeakMap();
      var _translationTimeoutId = /*#__PURE__*/new WeakMap();
      var _container = /*#__PURE__*/new WeakMap();
      var _viewer = /*#__PURE__*/new WeakMap();
      var _AnnotationEditorUIManager_brand = /*#__PURE__*/new WeakSet();
      var AnnotationEditorUIManager = /*#__PURE__*/function () {
        function AnnotationEditorUIManager(container, viewer, altTextManager, eventBus, pdfDocument, pageColors) {
          _classCallCheck(this, AnnotationEditorUIManager);
          _classPrivateMethodInitSpec(this, _AnnotationEditorUIManager_brand);
          _classPrivateFieldInitSpec(this, _activeEditor, null);
          _classPrivateFieldInitSpec(this, _allEditors, new Map());
          _classPrivateFieldInitSpec(this, _allLayers, new Map());
          _classPrivateFieldInitSpec(this, _altTextManager, null);
          _classPrivateFieldInitSpec(this, _annotationStorage, null);
          _classPrivateFieldInitSpec(this, _commandManager, new CommandManager());
          _classPrivateFieldInitSpec(this, _currentPageIndex, 0);
          _classPrivateFieldInitSpec(this, _deletedAnnotationsElementIds, new Set());
          _classPrivateFieldInitSpec(this, _draggingEditors, null);
          _classPrivateFieldInitSpec(this, _editorTypes, null);
          _classPrivateFieldInitSpec(this, _editorsToRescale, new Set());
          _classPrivateFieldInitSpec(this, _filterFactory, null);
          _classPrivateFieldInitSpec(this, _idManager, new IdManager());
          _classPrivateFieldInitSpec(this, _isEnabled, false);
          _classPrivateFieldInitSpec(this, _isWaiting, false);
          _classPrivateFieldInitSpec(this, _lastActiveElement, null);
          _classPrivateFieldInitSpec(this, _mode, _util.AnnotationEditorType.NONE);
          _classPrivateFieldInitSpec(this, _selectedEditors, new Set());
          _classPrivateFieldInitSpec(this, _pageColors, null);
          _classPrivateFieldInitSpec(this, _boundBlur, this.blur.bind(this));
          _classPrivateFieldInitSpec(this, _boundFocus, this.focus.bind(this));
          _classPrivateFieldInitSpec(this, _boundCopy, this.copy.bind(this));
          _classPrivateFieldInitSpec(this, _boundCut, this.cut.bind(this));
          _classPrivateFieldInitSpec(this, _boundPaste, this.paste.bind(this));
          _classPrivateFieldInitSpec(this, _boundKeydown, this.keydown.bind(this));
          _classPrivateFieldInitSpec(this, _boundOnEditingAction, this.onEditingAction.bind(this));
          _classPrivateFieldInitSpec(this, _boundOnPageChanging, this.onPageChanging.bind(this));
          _classPrivateFieldInitSpec(this, _boundOnScaleChanging, this.onScaleChanging.bind(this));
          _classPrivateFieldInitSpec(this, _boundOnRotationChanging, this.onRotationChanging.bind(this));
          _classPrivateFieldInitSpec(this, _previousStates, {
            isEditing: false,
            isEmpty: true,
            hasSomethingToUndo: false,
            hasSomethingToRedo: false,
            hasSelectedEditor: false
          });
          _classPrivateFieldInitSpec(this, _translation, [0, 0]);
          _classPrivateFieldInitSpec(this, _translationTimeoutId, null);
          _classPrivateFieldInitSpec(this, _container, null);
          _classPrivateFieldInitSpec(this, _viewer, null);
          _classPrivateFieldSet(_container, this, container);
          _classPrivateFieldSet(_viewer, this, viewer);
          _classPrivateFieldSet(_altTextManager, this, altTextManager);
          this._eventBus = eventBus;
          this._eventBus._on("editingaction", _classPrivateFieldGet(_boundOnEditingAction, this));
          this._eventBus._on("pagechanging", _classPrivateFieldGet(_boundOnPageChanging, this));
          this._eventBus._on("scalechanging", _classPrivateFieldGet(_boundOnScaleChanging, this));
          this._eventBus._on("rotationchanging", _classPrivateFieldGet(_boundOnRotationChanging, this));
          _classPrivateFieldSet(_annotationStorage, this, pdfDocument.annotationStorage);
          _classPrivateFieldSet(_filterFactory, this, pdfDocument.filterFactory);
          _classPrivateFieldSet(_pageColors, this, pageColors);
          this.viewParameters = {
            realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: 0
          };
        }
        return _createClass(AnnotationEditorUIManager, [{
          key: "destroy",
          value: function destroy() {
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeKeyboardManager).call(this);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeFocusManager).call(this);
            this._eventBus._off("editingaction", _classPrivateFieldGet(_boundOnEditingAction, this));
            this._eventBus._off("pagechanging", _classPrivateFieldGet(_boundOnPageChanging, this));
            this._eventBus._off("scalechanging", _classPrivateFieldGet(_boundOnScaleChanging, this));
            this._eventBus._off("rotationchanging", _classPrivateFieldGet(_boundOnRotationChanging, this));
            var _iterator23 = _createForOfIteratorHelper(_classPrivateFieldGet(_allLayers, this).values()),
              _step23;
            try {
              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                var layer = _step23.value;
                layer.destroy();
              }
            } catch (err) {
              _iterator23.e(err);
            } finally {
              _iterator23.f();
            }
            _classPrivateFieldGet(_allLayers, this).clear();
            _classPrivateFieldGet(_allEditors, this).clear();
            _classPrivateFieldGet(_editorsToRescale, this).clear();
            _classPrivateFieldSet(_activeEditor, this, null);
            _classPrivateFieldGet(_selectedEditors, this).clear();
            _classPrivateFieldGet(_commandManager, this).destroy();
            _classPrivateFieldGet(_altTextManager, this).destroy();
          }
        }, {
          key: "hcmFilter",
          get: function get() {
            return (0, _util.shadow)(this, "hcmFilter", _classPrivateFieldGet(_pageColors, this) ? _classPrivateFieldGet(_filterFactory, this).addHCMFilter(_classPrivateFieldGet(_pageColors, this).foreground, _classPrivateFieldGet(_pageColors, this).background) : "none");
          }
        }, {
          key: "direction",
          get: function get() {
            return (0, _util.shadow)(this, "direction", getComputedStyle(_classPrivateFieldGet(_container, this)).direction);
          }
        }, {
          key: "editAltText",
          value: function editAltText(editor) {
            var _classPrivateFieldGet10;
            (_classPrivateFieldGet10 = _classPrivateFieldGet(_altTextManager, this)) === null || _classPrivateFieldGet10 === void 0 || _classPrivateFieldGet10.editAltText(this, editor);
          }
        }, {
          key: "onPageChanging",
          value: function onPageChanging(_ref29) {
            var pageNumber = _ref29.pageNumber;
            _classPrivateFieldSet(_currentPageIndex, this, pageNumber - 1);
          }
        }, {
          key: "focusMainContainer",
          value: function focusMainContainer() {
            _classPrivateFieldGet(_container, this).focus();
          }
        }, {
          key: "findParent",
          value: function findParent(x, y) {
            var _iterator24 = _createForOfIteratorHelper(_classPrivateFieldGet(_allLayers, this).values()),
              _step24;
            try {
              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                var layer = _step24.value;
                var _layer$div$getBoundin = layer.div.getBoundingClientRect(),
                  layerX = _layer$div$getBoundin.x,
                  layerY = _layer$div$getBoundin.y,
                  width = _layer$div$getBoundin.width,
                  height = _layer$div$getBoundin.height;
                if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
                  return layer;
                }
              }
            } catch (err) {
              _iterator24.e(err);
            } finally {
              _iterator24.f();
            }
            return null;
          }
        }, {
          key: "disableUserSelect",
          value: function disableUserSelect() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            _classPrivateFieldGet(_viewer, this).classList.toggle("noUserSelect", value);
          }
        }, {
          key: "addShouldRescale",
          value: function addShouldRescale(editor) {
            _classPrivateFieldGet(_editorsToRescale, this).add(editor);
          }
        }, {
          key: "removeShouldRescale",
          value: function removeShouldRescale(editor) {
            _classPrivateFieldGet(_editorsToRescale, this).delete(editor);
          }
        }, {
          key: "onScaleChanging",
          value: function onScaleChanging(_ref30) {
            var scale = _ref30.scale;
            this.commitOrRemove();
            this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;
            var _iterator25 = _createForOfIteratorHelper(_classPrivateFieldGet(_editorsToRescale, this)),
              _step25;
            try {
              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                var editor = _step25.value;
                editor.onScaleChanging();
              }
            } catch (err) {
              _iterator25.e(err);
            } finally {
              _iterator25.f();
            }
          }
        }, {
          key: "onRotationChanging",
          value: function onRotationChanging(_ref31) {
            var pagesRotation = _ref31.pagesRotation;
            this.commitOrRemove();
            this.viewParameters.rotation = pagesRotation;
          }
        }, {
          key: "addToAnnotationStorage",
          value: function addToAnnotationStorage(editor) {
            if (!editor.isEmpty() && _classPrivateFieldGet(_annotationStorage, this) && !_classPrivateFieldGet(_annotationStorage, this).has(editor.id)) {
              _classPrivateFieldGet(_annotationStorage, this).setValue(editor.id, editor);
            }
          }
        }, {
          key: "blur",
          value: function blur() {
            if (!this.hasSelection) {
              return;
            }
            var _document2 = document,
              activeElement = _document2.activeElement;
            var _iterator26 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step26;
            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var editor = _step26.value;
                if (editor.div.contains(activeElement)) {
                  _classPrivateFieldSet(_lastActiveElement, this, [editor, activeElement]);
                  editor._focusEventsAllowed = false;
                  break;
                }
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }
          }
        }, {
          key: "focus",
          value: function focus() {
            if (!_classPrivateFieldGet(_lastActiveElement, this)) {
              return;
            }
            var _classPrivateFieldGet11 = _classPrivateFieldGet(_lastActiveElement, this),
              _classPrivateFieldGet12 = _slicedToArray(_classPrivateFieldGet11, 2),
              lastEditor = _classPrivateFieldGet12[0],
              lastActiveElement = _classPrivateFieldGet12[1];
            _classPrivateFieldSet(_lastActiveElement, this, null);
            lastActiveElement.addEventListener("focusin", function () {
              lastEditor._focusEventsAllowed = true;
            }, {
              once: true
            });
            lastActiveElement.focus();
          }
        }, {
          key: "addEditListeners",
          value: function addEditListeners() {
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _addKeyboardManager).call(this);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _addCopyPasteListeners).call(this);
          }
        }, {
          key: "removeEditListeners",
          value: function removeEditListeners() {
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeKeyboardManager).call(this);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeCopyPasteListeners).call(this);
          }
        }, {
          key: "copy",
          value: function copy(event) {
            var _classPrivateFieldGet13;
            event.preventDefault();
            (_classPrivateFieldGet13 = _classPrivateFieldGet(_activeEditor, this)) === null || _classPrivateFieldGet13 === void 0 || _classPrivateFieldGet13.commitOrRemove();
            if (!this.hasSelection) {
              return;
            }
            var editors = [];
            var _iterator27 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step27;
            try {
              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                var editor = _step27.value;
                var serialized = editor.serialize(true);
                if (serialized) {
                  editors.push(serialized);
                }
              }
            } catch (err) {
              _iterator27.e(err);
            } finally {
              _iterator27.f();
            }
            if (editors.length === 0) {
              return;
            }
            event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
          }
        }, {
          key: "cut",
          value: function cut(event) {
            this.copy(event);
            this.delete();
          }
        }, {
          key: "paste",
          value: function paste(event) {
            var _this29 = this;
            event.preventDefault();
            var clipboardData = event.clipboardData;
            var _iterator28 = _createForOfIteratorHelper(clipboardData.items),
              _step28;
            try {
              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                var item = _step28.value;
                var _iterator30 = _createForOfIteratorHelper(_classPrivateFieldGet(_editorTypes, this)),
                  _step30;
                try {
                  for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                    var editorType = _step30.value;
                    if (editorType.isHandlingMimeForPasting(item.type)) {
                      editorType.paste(item, this.currentLayer);
                      return;
                    }
                  }
                } catch (err) {
                  _iterator30.e(err);
                } finally {
                  _iterator30.f();
                }
              }
            } catch (err) {
              _iterator28.e(err);
            } finally {
              _iterator28.f();
            }
            var data = clipboardData.getData("application/pdfjs");
            if (!data) {
              return;
            }
            try {
              data = JSON.parse(data);
            } catch (ex) {
              (0, _util.warn)("paste: \"".concat(ex.message, "\"."));
              return;
            }
            if (!Array.isArray(data)) {
              return;
            }
            this.unselectAll();
            var layer = this.currentLayer;
            try {
              var newEditors = [];
              var _iterator29 = _createForOfIteratorHelper(data),
                _step29;
              try {
                for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                  var editor = _step29.value;
                  var deserializedEditor = layer.deserialize(editor);
                  if (!deserializedEditor) {
                    return;
                  }
                  newEditors.push(deserializedEditor);
                }
              } catch (err) {
                _iterator29.e(err);
              } finally {
                _iterator29.f();
              }
              var cmd = function cmd() {
                for (var _i4 = 0, _newEditors = newEditors; _i4 < _newEditors.length; _i4++) {
                  var editor = _newEditors[_i4];
                  _assertClassBrand(_AnnotationEditorUIManager_brand, _this29, _addEditorToLayer).call(_this29, editor);
                }
                _assertClassBrand(_AnnotationEditorUIManager_brand, _this29, _selectEditors).call(_this29, newEditors);
              };
              var undo = function undo() {
                for (var _i5 = 0, _newEditors2 = newEditors; _i5 < _newEditors2.length; _i5++) {
                  var editor = _newEditors2[_i5];
                  editor.remove();
                }
              };
              this.addCommands({
                cmd: cmd,
                undo: undo,
                mustExec: true
              });
            } catch (ex) {
              (0, _util.warn)("paste: \"".concat(ex.message, "\"."));
            }
          }
        }, {
          key: "keydown",
          value: function keydown(event) {
            var _this$getActive;
            if (!((_this$getActive = this.getActive()) !== null && _this$getActive !== void 0 && _this$getActive.shouldGetKeyboardEvents())) {
              AnnotationEditorUIManager._keyboardManager.exec(this, event);
            }
          }
        }, {
          key: "onEditingAction",
          value: function onEditingAction(details) {
            if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
              this[details.name]();
            }
          }
        }, {
          key: "setEditingState",
          value: function setEditingState(isEditing) {
            if (isEditing) {
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _addFocusManager).call(this);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _addKeyboardManager).call(this);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _addCopyPasteListeners).call(this);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
                isEditing: _classPrivateFieldGet(_mode, this) !== _util.AnnotationEditorType.NONE,
                isEmpty: _assertClassBrand(_AnnotationEditorUIManager_brand, this, _isEmpty).call(this),
                hasSomethingToUndo: _classPrivateFieldGet(_commandManager, this).hasSomethingToUndo(),
                hasSomethingToRedo: _classPrivateFieldGet(_commandManager, this).hasSomethingToRedo(),
                hasSelectedEditor: false
              });
            } else {
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeFocusManager).call(this);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeKeyboardManager).call(this);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _removeCopyPasteListeners).call(this);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
                isEditing: false
              });
              this.disableUserSelect(false);
            }
          }
        }, {
          key: "registerEditorTypes",
          value: function registerEditorTypes(types) {
            if (_classPrivateFieldGet(_editorTypes, this)) {
              return;
            }
            _classPrivateFieldSet(_editorTypes, this, types);
            var _iterator31 = _createForOfIteratorHelper(_classPrivateFieldGet(_editorTypes, this)),
              _step31;
            try {
              for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
                var editorType = _step31.value;
                _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateUI).call(this, editorType.defaultPropertiesToUpdate);
              }
            } catch (err) {
              _iterator31.e(err);
            } finally {
              _iterator31.f();
            }
          }
        }, {
          key: "getId",
          value: function getId() {
            return _classPrivateFieldGet(_idManager, this).getId();
          }
        }, {
          key: "currentLayer",
          get: function get() {
            return _classPrivateFieldGet(_allLayers, this).get(_classPrivateFieldGet(_currentPageIndex, this));
          }
        }, {
          key: "getLayer",
          value: function getLayer(pageIndex) {
            return _classPrivateFieldGet(_allLayers, this).get(pageIndex);
          }
        }, {
          key: "currentPageIndex",
          get: function get() {
            return _classPrivateFieldGet(_currentPageIndex, this);
          }
        }, {
          key: "addLayer",
          value: function addLayer(layer) {
            _classPrivateFieldGet(_allLayers, this).set(layer.pageIndex, layer);
            if (_classPrivateFieldGet(_isEnabled, this)) {
              layer.enable();
            } else {
              layer.disable();
            }
          }
        }, {
          key: "removeLayer",
          value: function removeLayer(layer) {
            _classPrivateFieldGet(_allLayers, this).delete(layer.pageIndex);
          }
        }, {
          key: "updateMode",
          value: function updateMode(mode) {
            var editId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (_classPrivateFieldGet(_mode, this) === mode) {
              return;
            }
            _classPrivateFieldSet(_mode, this, mode);
            if (mode === _util.AnnotationEditorType.NONE) {
              this.setEditingState(false);
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _disableAll).call(this);
              return;
            }
            this.setEditingState(true);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _enableAll).call(this);
            this.unselectAll();
            var _iterator32 = _createForOfIteratorHelper(_classPrivateFieldGet(_allLayers, this).values()),
              _step32;
            try {
              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                var layer = _step32.value;
                layer.updateMode(mode);
              }
            } catch (err) {
              _iterator32.e(err);
            } finally {
              _iterator32.f();
            }
            if (!editId) {
              return;
            }
            var _iterator33 = _createForOfIteratorHelper(_classPrivateFieldGet(_allEditors, this).values()),
              _step33;
            try {
              for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                var editor = _step33.value;
                if (editor.annotationElementId === editId) {
                  this.setSelected(editor);
                  editor.enterInEditMode();
                  break;
                }
              }
            } catch (err) {
              _iterator33.e(err);
            } finally {
              _iterator33.f();
            }
          }
        }, {
          key: "updateToolbar",
          value: function updateToolbar(mode) {
            if (mode === _classPrivateFieldGet(_mode, this)) {
              return;
            }
            this._eventBus.dispatch("switchannotationeditormode", {
              source: this,
              mode: mode
            });
          }
        }, {
          key: "updateParams",
          value: function updateParams(type, value) {
            if (!_classPrivateFieldGet(_editorTypes, this)) {
              return;
            }
            if (type === _util.AnnotationEditorParamsType.CREATE) {
              this.currentLayer.addNewEditor(type);
              return;
            }
            var _iterator34 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step34;
            try {
              for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                var editor = _step34.value;
                editor.updateParams(type, value);
              }
            } catch (err) {
              _iterator34.e(err);
            } finally {
              _iterator34.f();
            }
            var _iterator35 = _createForOfIteratorHelper(_classPrivateFieldGet(_editorTypes, this)),
              _step35;
            try {
              for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                var editorType = _step35.value;
                editorType.updateDefaultParams(type, value);
              }
            } catch (err) {
              _iterator35.e(err);
            } finally {
              _iterator35.f();
            }
          }
        }, {
          key: "enableWaiting",
          value: function enableWaiting() {
            var mustWait = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (_classPrivateFieldGet(_isWaiting, this) === mustWait) {
              return;
            }
            _classPrivateFieldSet(_isWaiting, this, mustWait);
            var _iterator36 = _createForOfIteratorHelper(_classPrivateFieldGet(_allLayers, this).values()),
              _step36;
            try {
              for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                var layer = _step36.value;
                if (mustWait) {
                  layer.disableClick();
                } else {
                  layer.enableClick();
                }
                layer.div.classList.toggle("waiting", mustWait);
              }
            } catch (err) {
              _iterator36.e(err);
            } finally {
              _iterator36.f();
            }
          }
        }, {
          key: "getEditors",
          value: function getEditors(pageIndex) {
            var editors = [];
            var _iterator37 = _createForOfIteratorHelper(_classPrivateFieldGet(_allEditors, this).values()),
              _step37;
            try {
              for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
                var editor = _step37.value;
                if (editor.pageIndex === pageIndex) {
                  editors.push(editor);
                }
              }
            } catch (err) {
              _iterator37.e(err);
            } finally {
              _iterator37.f();
            }
            return editors;
          }
        }, {
          key: "getEditor",
          value: function getEditor(id) {
            return _classPrivateFieldGet(_allEditors, this).get(id);
          }
        }, {
          key: "addEditor",
          value: function addEditor(editor) {
            _classPrivateFieldGet(_allEditors, this).set(editor.id, editor);
          }
        }, {
          key: "removeEditor",
          value: function removeEditor(editor) {
            _classPrivateFieldGet(_allEditors, this).delete(editor.id);
            this.unselect(editor);
            if (!editor.annotationElementId || !_classPrivateFieldGet(_deletedAnnotationsElementIds, this).has(editor.annotationElementId)) {
              var _classPrivateFieldGet14;
              (_classPrivateFieldGet14 = _classPrivateFieldGet(_annotationStorage, this)) === null || _classPrivateFieldGet14 === void 0 || _classPrivateFieldGet14.remove(editor.id);
            }
          }
        }, {
          key: "addDeletedAnnotationElement",
          value: function addDeletedAnnotationElement(editor) {
            _classPrivateFieldGet(_deletedAnnotationsElementIds, this).add(editor.annotationElementId);
            editor.deleted = true;
          }
        }, {
          key: "isDeletedAnnotationElement",
          value: function isDeletedAnnotationElement(annotationElementId) {
            return _classPrivateFieldGet(_deletedAnnotationsElementIds, this).has(annotationElementId);
          }
        }, {
          key: "removeDeletedAnnotationElement",
          value: function removeDeletedAnnotationElement(editor) {
            _classPrivateFieldGet(_deletedAnnotationsElementIds, this).delete(editor.annotationElementId);
            editor.deleted = false;
          }
        }, {
          key: "setActiveEditor",
          value: function setActiveEditor(editor) {
            if (_classPrivateFieldGet(_activeEditor, this) === editor) {
              return;
            }
            _classPrivateFieldSet(_activeEditor, this, editor);
            if (editor) {
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateUI).call(this, editor.propertiesToUpdate);
            }
          }
        }, {
          key: "toggleSelected",
          value: function toggleSelected(editor) {
            if (_classPrivateFieldGet(_selectedEditors, this).has(editor)) {
              _classPrivateFieldGet(_selectedEditors, this).delete(editor);
              editor.unselect();
              _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
                hasSelectedEditor: this.hasSelection
              });
              return;
            }
            _classPrivateFieldGet(_selectedEditors, this).add(editor);
            editor.select();
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateUI).call(this, editor.propertiesToUpdate);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSelectedEditor: true
            });
          }
        }, {
          key: "setSelected",
          value: function setSelected(editor) {
            var _iterator38 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step38;
            try {
              for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                var ed = _step38.value;
                if (ed !== editor) {
                  ed.unselect();
                }
              }
            } catch (err) {
              _iterator38.e(err);
            } finally {
              _iterator38.f();
            }
            _classPrivateFieldGet(_selectedEditors, this).clear();
            _classPrivateFieldGet(_selectedEditors, this).add(editor);
            editor.select();
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateUI).call(this, editor.propertiesToUpdate);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSelectedEditor: true
            });
          }
        }, {
          key: "isSelected",
          value: function isSelected(editor) {
            return _classPrivateFieldGet(_selectedEditors, this).has(editor);
          }
        }, {
          key: "unselect",
          value: function unselect(editor) {
            editor.unselect();
            _classPrivateFieldGet(_selectedEditors, this).delete(editor);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSelectedEditor: this.hasSelection
            });
          }
        }, {
          key: "hasSelection",
          get: function get() {
            return _classPrivateFieldGet(_selectedEditors, this).size !== 0;
          }
        }, {
          key: "undo",
          value: function undo() {
            _classPrivateFieldGet(_commandManager, this).undo();
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSomethingToUndo: _classPrivateFieldGet(_commandManager, this).hasSomethingToUndo(),
              hasSomethingToRedo: true,
              isEmpty: _assertClassBrand(_AnnotationEditorUIManager_brand, this, _isEmpty).call(this)
            });
          }
        }, {
          key: "redo",
          value: function redo() {
            _classPrivateFieldGet(_commandManager, this).redo();
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSomethingToUndo: true,
              hasSomethingToRedo: _classPrivateFieldGet(_commandManager, this).hasSomethingToRedo(),
              isEmpty: _assertClassBrand(_AnnotationEditorUIManager_brand, this, _isEmpty).call(this)
            });
          }
        }, {
          key: "addCommands",
          value: function addCommands(params) {
            _classPrivateFieldGet(_commandManager, this).add(params);
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSomethingToUndo: true,
              hasSomethingToRedo: false,
              isEmpty: _assertClassBrand(_AnnotationEditorUIManager_brand, this, _isEmpty).call(this)
            });
          }
        }, {
          key: "delete",
          value: function _delete() {
            var _this30 = this;
            this.commitOrRemove();
            if (!this.hasSelection) {
              return;
            }
            var editors = _toConsumableArray(_classPrivateFieldGet(_selectedEditors, this));
            var cmd = function cmd() {
              var _iterator39 = _createForOfIteratorHelper(editors),
                _step39;
              try {
                for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                  var editor = _step39.value;
                  editor.remove();
                }
              } catch (err) {
                _iterator39.e(err);
              } finally {
                _iterator39.f();
              }
            };
            var undo = function undo() {
              var _iterator40 = _createForOfIteratorHelper(editors),
                _step40;
              try {
                for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
                  var editor = _step40.value;
                  _assertClassBrand(_AnnotationEditorUIManager_brand, _this30, _addEditorToLayer).call(_this30, editor);
                }
              } catch (err) {
                _iterator40.e(err);
              } finally {
                _iterator40.f();
              }
            };
            this.addCommands({
              cmd: cmd,
              undo: undo,
              mustExec: true
            });
          }
        }, {
          key: "commitOrRemove",
          value: function commitOrRemove() {
            var _classPrivateFieldGet15;
            (_classPrivateFieldGet15 = _classPrivateFieldGet(_activeEditor, this)) === null || _classPrivateFieldGet15 === void 0 || _classPrivateFieldGet15.commitOrRemove();
          }
        }, {
          key: "hasSomethingToControl",
          value: function hasSomethingToControl() {
            return _classPrivateFieldGet(_activeEditor, this) || this.hasSelection;
          }
        }, {
          key: "selectAll",
          value: function selectAll() {
            var _iterator41 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step41;
            try {
              for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                var editor = _step41.value;
                editor.commit();
              }
            } catch (err) {
              _iterator41.e(err);
            } finally {
              _iterator41.f();
            }
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _selectEditors).call(this, _classPrivateFieldGet(_allEditors, this).values());
          }
        }, {
          key: "unselectAll",
          value: function unselectAll() {
            if (_classPrivateFieldGet(_activeEditor, this)) {
              _classPrivateFieldGet(_activeEditor, this).commitOrRemove();
              return;
            }
            if (!this.hasSelection) {
              return;
            }
            var _iterator42 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step42;
            try {
              for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
                var editor = _step42.value;
                editor.unselect();
              }
            } catch (err) {
              _iterator42.e(err);
            } finally {
              _iterator42.f();
            }
            _classPrivateFieldGet(_selectedEditors, this).clear();
            _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
              hasSelectedEditor: false
            });
          }
        }, {
          key: "translateSelectedEditors",
          value: function translateSelectedEditors(x, y) {
            var _this31 = this;
            var noCommit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (!noCommit) {
              this.commitOrRemove();
            }
            if (!this.hasSelection) {
              return;
            }
            _classPrivateFieldGet(_translation, this)[0] += x;
            _classPrivateFieldGet(_translation, this)[1] += y;
            var _classPrivateFieldGet16 = _classPrivateFieldGet(_translation, this),
              _classPrivateFieldGet17 = _slicedToArray(_classPrivateFieldGet16, 2),
              totalX = _classPrivateFieldGet17[0],
              totalY = _classPrivateFieldGet17[1];
            var editors = _toConsumableArray(_classPrivateFieldGet(_selectedEditors, this));
            var TIME_TO_WAIT = 1000;
            if (_classPrivateFieldGet(_translationTimeoutId, this)) {
              clearTimeout(_classPrivateFieldGet(_translationTimeoutId, this));
            }
            _classPrivateFieldSet(_translationTimeoutId, this, setTimeout(function () {
              _classPrivateFieldSet(_translationTimeoutId, _this31, null);
              _classPrivateFieldGet(_translation, _this31)[0] = _classPrivateFieldGet(_translation, _this31)[1] = 0;
              _this31.addCommands({
                cmd: function cmd() {
                  var _iterator43 = _createForOfIteratorHelper(editors),
                    _step43;
                  try {
                    for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
                      var editor = _step43.value;
                      if (_classPrivateFieldGet(_allEditors, _this31).has(editor.id)) {
                        editor.translateInPage(totalX, totalY);
                      }
                    }
                  } catch (err) {
                    _iterator43.e(err);
                  } finally {
                    _iterator43.f();
                  }
                },
                undo: function undo() {
                  var _iterator44 = _createForOfIteratorHelper(editors),
                    _step44;
                  try {
                    for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                      var editor = _step44.value;
                      if (_classPrivateFieldGet(_allEditors, _this31).has(editor.id)) {
                        editor.translateInPage(-totalX, -totalY);
                      }
                    }
                  } catch (err) {
                    _iterator44.e(err);
                  } finally {
                    _iterator44.f();
                  }
                },
                mustExec: false
              });
            }, TIME_TO_WAIT));
            var _iterator45 = _createForOfIteratorHelper(editors),
              _step45;
            try {
              for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
                var editor = _step45.value;
                editor.translateInPage(x, y);
              }
            } catch (err) {
              _iterator45.e(err);
            } finally {
              _iterator45.f();
            }
          }
        }, {
          key: "setUpDragSession",
          value: function setUpDragSession() {
            if (!this.hasSelection) {
              return;
            }
            this.disableUserSelect(true);
            _classPrivateFieldSet(_draggingEditors, this, new Map());
            var _iterator46 = _createForOfIteratorHelper(_classPrivateFieldGet(_selectedEditors, this)),
              _step46;
            try {
              for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
                var editor = _step46.value;
                _classPrivateFieldGet(_draggingEditors, this).set(editor, {
                  savedX: editor.x,
                  savedY: editor.y,
                  savedPageIndex: editor.pageIndex,
                  newX: 0,
                  newY: 0,
                  newPageIndex: -1
                });
              }
            } catch (err) {
              _iterator46.e(err);
            } finally {
              _iterator46.f();
            }
          }
        }, {
          key: "endDragSession",
          value: function endDragSession() {
            var _this32 = this;
            if (!_classPrivateFieldGet(_draggingEditors, this)) {
              return false;
            }
            this.disableUserSelect(false);
            var map = _classPrivateFieldGet(_draggingEditors, this);
            _classPrivateFieldSet(_draggingEditors, this, null);
            var mustBeAddedInUndoStack = false;
            var _iterator47 = _createForOfIteratorHelper(map),
              _step47;
            try {
              for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
                var _step47$value = _slicedToArray(_step47.value, 2),
                  _step47$value$ = _step47$value[0],
                  x = _step47$value$.x,
                  y = _step47$value$.y,
                  pageIndex = _step47$value$.pageIndex,
                  value = _step47$value[1];
                value.newX = x;
                value.newY = y;
                value.newPageIndex = pageIndex;
                mustBeAddedInUndoStack || (mustBeAddedInUndoStack = x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex);
              }
            } catch (err) {
              _iterator47.e(err);
            } finally {
              _iterator47.f();
            }
            if (!mustBeAddedInUndoStack) {
              return false;
            }
            var move = function move(editor, x, y, pageIndex) {
              if (_classPrivateFieldGet(_allEditors, _this32).has(editor.id)) {
                var parent = _classPrivateFieldGet(_allLayers, _this32).get(pageIndex);
                if (parent) {
                  editor._setParentAndPosition(parent, x, y);
                } else {
                  editor.pageIndex = pageIndex;
                  editor.x = x;
                  editor.y = y;
                }
              }
            };
            this.addCommands({
              cmd: function cmd() {
                var _iterator48 = _createForOfIteratorHelper(map),
                  _step48;
                try {
                  for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
                    var _step48$value = _slicedToArray(_step48.value, 2),
                      editor = _step48$value[0],
                      _step48$value$ = _step48$value[1],
                      newX = _step48$value$.newX,
                      newY = _step48$value$.newY,
                      newPageIndex = _step48$value$.newPageIndex;
                    move(editor, newX, newY, newPageIndex);
                  }
                } catch (err) {
                  _iterator48.e(err);
                } finally {
                  _iterator48.f();
                }
              },
              undo: function undo() {
                var _iterator49 = _createForOfIteratorHelper(map),
                  _step49;
                try {
                  for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
                    var _step49$value = _slicedToArray(_step49.value, 2),
                      editor = _step49$value[0],
                      _step49$value$ = _step49$value[1],
                      savedX = _step49$value$.savedX,
                      savedY = _step49$value$.savedY,
                      savedPageIndex = _step49$value$.savedPageIndex;
                    move(editor, savedX, savedY, savedPageIndex);
                  }
                } catch (err) {
                  _iterator49.e(err);
                } finally {
                  _iterator49.f();
                }
              },
              mustExec: true
            });
            return true;
          }
        }, {
          key: "dragSelectedEditors",
          value: function dragSelectedEditors(tx, ty) {
            if (!_classPrivateFieldGet(_draggingEditors, this)) {
              return;
            }
            var _iterator50 = _createForOfIteratorHelper(_classPrivateFieldGet(_draggingEditors, this).keys()),
              _step50;
            try {
              for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
                var editor = _step50.value;
                editor.drag(tx, ty);
              }
            } catch (err) {
              _iterator50.e(err);
            } finally {
              _iterator50.f();
            }
          }
        }, {
          key: "rebuild",
          value: function rebuild(editor) {
            if (editor.parent === null) {
              var parent = this.getLayer(editor.pageIndex);
              if (parent) {
                parent.changeParent(editor);
                parent.addOrRebuild(editor);
              } else {
                this.addEditor(editor);
                this.addToAnnotationStorage(editor);
                editor.rebuild();
              }
            } else {
              editor.parent.addOrRebuild(editor);
            }
          }
        }, {
          key: "isActive",
          value: function isActive(editor) {
            return _classPrivateFieldGet(_activeEditor, this) === editor;
          }
        }, {
          key: "getActive",
          value: function getActive() {
            return _classPrivateFieldGet(_activeEditor, this);
          }
        }, {
          key: "getMode",
          value: function getMode() {
            return _classPrivateFieldGet(_mode, this);
          }
        }, {
          key: "imageManager",
          get: function get() {
            return (0, _util.shadow)(this, "imageManager", new ImageManager());
          }
        }], [{
          key: "_keyboardManager",
          get: function get() {
            var proto = AnnotationEditorUIManager.prototype;
            var arrowChecker = function arrowChecker(self) {
              var _document3 = document,
                activeElement = _document3.activeElement;
              return activeElement && _classPrivateFieldGet(_container, self).contains(activeElement) && self.hasSomethingToControl();
            };
            var small = this.TRANSLATE_SMALL;
            var big = this.TRANSLATE_BIG;
            return (0, _util.shadow)(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll], [["ctrl+z", "mac+meta+z"], proto.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
              args: [-small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
              args: [-big, 0],
              checker: arrowChecker
            }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
              args: [small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
              args: [big, 0],
              checker: arrowChecker
            }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
              args: [0, -small],
              checker: arrowChecker
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
              args: [0, -big],
              checker: arrowChecker
            }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
              args: [0, small],
              checker: arrowChecker
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
              args: [0, big],
              checker: arrowChecker
            }]]));
          }
        }]);
      }();
      function _addFocusManager() {
        window.addEventListener("focus", _classPrivateFieldGet(_boundFocus, this));
        window.addEventListener("blur", _classPrivateFieldGet(_boundBlur, this));
      }
      function _removeFocusManager() {
        window.removeEventListener("focus", _classPrivateFieldGet(_boundFocus, this));
        window.removeEventListener("blur", _classPrivateFieldGet(_boundBlur, this));
      }
      function _addKeyboardManager() {
        window.addEventListener("keydown", _classPrivateFieldGet(_boundKeydown, this), {
          capture: true
        });
      }
      function _removeKeyboardManager() {
        window.removeEventListener("keydown", _classPrivateFieldGet(_boundKeydown, this), {
          capture: true
        });
      }
      function _addCopyPasteListeners() {
        document.addEventListener("copy", _classPrivateFieldGet(_boundCopy, this));
        document.addEventListener("cut", _classPrivateFieldGet(_boundCut, this));
        document.addEventListener("paste", _classPrivateFieldGet(_boundPaste, this));
      }
      function _removeCopyPasteListeners() {
        document.removeEventListener("copy", _classPrivateFieldGet(_boundCopy, this));
        document.removeEventListener("cut", _classPrivateFieldGet(_boundCut, this));
        document.removeEventListener("paste", _classPrivateFieldGet(_boundPaste, this));
      }
      function _dispatchUpdateStates(details) {
        var _this33 = this;
        var hasChanged = Object.entries(details).some(function (_ref32) {
          var _ref33 = _slicedToArray(_ref32, 2),
            key = _ref33[0],
            value = _ref33[1];
          return _classPrivateFieldGet(_previousStates, _this33)[key] !== value;
        });
        if (hasChanged) {
          this._eventBus.dispatch("annotationeditorstateschanged", {
            source: this,
            details: Object.assign(_classPrivateFieldGet(_previousStates, this), details)
          });
        }
      }
      function _dispatchUpdateUI(details) {
        this._eventBus.dispatch("annotationeditorparamschanged", {
          source: this,
          details: details
        });
      }
      function _enableAll() {
        if (!_classPrivateFieldGet(_isEnabled, this)) {
          _classPrivateFieldSet(_isEnabled, this, true);
          var _iterator51 = _createForOfIteratorHelper(_classPrivateFieldGet(_allLayers, this).values()),
            _step51;
          try {
            for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
              var layer = _step51.value;
              layer.enable();
            }
          } catch (err) {
            _iterator51.e(err);
          } finally {
            _iterator51.f();
          }
        }
      }
      function _disableAll() {
        this.unselectAll();
        if (_classPrivateFieldGet(_isEnabled, this)) {
          _classPrivateFieldSet(_isEnabled, this, false);
          var _iterator52 = _createForOfIteratorHelper(_classPrivateFieldGet(_allLayers, this).values()),
            _step52;
          try {
            for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
              var layer = _step52.value;
              layer.disable();
            }
          } catch (err) {
            _iterator52.e(err);
          } finally {
            _iterator52.f();
          }
        }
      }
      function _addEditorToLayer(editor) {
        var layer = _classPrivateFieldGet(_allLayers, this).get(editor.pageIndex);
        if (layer) {
          layer.addOrRebuild(editor);
        } else {
          this.addEditor(editor);
        }
      }
      function _isEmpty() {
        if (_classPrivateFieldGet(_allEditors, this).size === 0) {
          return true;
        }
        if (_classPrivateFieldGet(_allEditors, this).size === 1) {
          var _iterator53 = _createForOfIteratorHelper(_classPrivateFieldGet(_allEditors, this).values()),
            _step53;
          try {
            for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
              var editor = _step53.value;
              return editor.isEmpty();
            }
          } catch (err) {
            _iterator53.e(err);
          } finally {
            _iterator53.f();
          }
        }
        return false;
      }
      function _selectEditors(editors) {
        _classPrivateFieldGet(_selectedEditors, this).clear();
        var _iterator54 = _createForOfIteratorHelper(editors),
          _step54;
        try {
          for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
            var editor = _step54.value;
            if (editor.isEmpty()) {
              continue;
            }
            _classPrivateFieldGet(_selectedEditors, this).add(editor);
            editor.select();
          }
        } catch (err) {
          _iterator54.e(err);
        } finally {
          _iterator54.f();
        }
        _assertClassBrand(_AnnotationEditorUIManager_brand, this, _dispatchUpdateStates).call(this, {
          hasSelectedEditor: true
        });
      }
      _defineProperty(AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
      _defineProperty(AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
      exports.AnnotationEditorUIManager = AnnotationEditorUIManager;

      /***/
    }), (/* 6 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      var _PixelsPerInch;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMFilterFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;
      exports.deprecated = deprecated;
      exports.getColorValues = getColorValues;
      exports.getCurrentTransform = getCurrentTransform;
      exports.getCurrentTransformInverse = getCurrentTransformInverse;
      exports.getFilenameFromUrl = getFilenameFromUrl;
      exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
      exports.getRGB = getRGB;
      exports.getXfaPageViewport = getXfaPageViewport;
      exports.isDataScheme = isDataScheme;
      exports.isPdfFile = isPdfFile;
      exports.isValidFetchUrl = isValidFetchUrl;
      exports.loadScript = loadScript;
      exports.noContextMenu = noContextMenu;
      exports.setLayerDimensions = setLayerDimensions;
      var _base_factory = __w_pdfjs_require__(7);
      var _util = __w_pdfjs_require__(1);
      var SVG_NS = "http://www.w3.org/2000/svg";
      var PixelsPerInch = /*#__PURE__*/_createClass(function PixelsPerInch() {
        _classCallCheck(this, PixelsPerInch);
      });
      _PixelsPerInch = PixelsPerInch;
      _defineProperty(PixelsPerInch, "CSS", 96.0);
      _defineProperty(PixelsPerInch, "PDF", 72.0);
      _defineProperty(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
      exports.PixelsPerInch = PixelsPerInch;
      var _cache2 = /*#__PURE__*/new WeakMap();
      var _defs = /*#__PURE__*/new WeakMap();
      var _docId2 = /*#__PURE__*/new WeakMap();
      var _document4 = /*#__PURE__*/new WeakMap();
      var _hcmFilter = /*#__PURE__*/new WeakMap();
      var _hcmKey = /*#__PURE__*/new WeakMap();
      var _hcmUrl = /*#__PURE__*/new WeakMap();
      var _hcmHighlightFilter = /*#__PURE__*/new WeakMap();
      var _hcmHighlightKey = /*#__PURE__*/new WeakMap();
      var _hcmHighlightUrl = /*#__PURE__*/new WeakMap();
      var _id3 = /*#__PURE__*/new WeakMap();
      var _DOMFilterFactory_brand = /*#__PURE__*/new WeakSet();
      var DOMFilterFactory = /*#__PURE__*/function (_base_factory$BaseFil) {
        function DOMFilterFactory() {
          var _this36;
          var _ref35 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            docId = _ref35.docId,
            _ref35$ownerDocument = _ref35.ownerDocument,
            ownerDocument = _ref35$ownerDocument === void 0 ? globalThis.document : _ref35$ownerDocument;
          _classCallCheck(this, DOMFilterFactory);
          _this36 = _callSuper(this, DOMFilterFactory);
          _classPrivateMethodInitSpec(_this36, _DOMFilterFactory_brand);
          _classPrivateFieldInitSpec(_this36, _cache2, void 0);
          _classPrivateFieldInitSpec(_this36, _defs, void 0);
          _classPrivateFieldInitSpec(_this36, _docId2, void 0);
          _classPrivateFieldInitSpec(_this36, _document4, void 0);
          _classPrivateFieldInitSpec(_this36, _hcmFilter, void 0);
          _classPrivateFieldInitSpec(_this36, _hcmKey, void 0);
          _classPrivateFieldInitSpec(_this36, _hcmUrl, void 0);
          _classPrivateFieldInitSpec(_this36, _hcmHighlightFilter, void 0);
          _classPrivateFieldInitSpec(_this36, _hcmHighlightKey, void 0);
          _classPrivateFieldInitSpec(_this36, _hcmHighlightUrl, void 0);
          _classPrivateFieldInitSpec(_this36, _id3, 0);
          _classPrivateFieldSet(_docId2, _this36, docId);
          _classPrivateFieldSet(_document4, _this36, ownerDocument);
          return _this36;
        }
        _inherits(DOMFilterFactory, _base_factory$BaseFil);
        return _createClass(DOMFilterFactory, [{
          key: "addFilter",
          value: function addFilter(maps) {
            var _this$id5, _this$id6;
            if (!maps) {
              return "none";
            }
            var value = _classPrivateGetter(_DOMFilterFactory_brand, this, _get_cache).get(maps);
            if (value) {
              return value;
            }
            var tableR, tableG, tableB, key;
            if (maps.length === 1) {
              var mapR = maps[0];
              var buffer = new Array(256);
              for (var i = 0; i < 256; i++) {
                buffer[i] = mapR[i] / 255;
              }
              key = tableR = tableG = tableB = buffer.join(",");
            } else {
              var _maps = _slicedToArray(maps, 3),
                _mapR = _maps[0],
                mapG = _maps[1],
                mapB = _maps[2];
              var bufferR = new Array(256);
              var bufferG = new Array(256);
              var bufferB = new Array(256);
              for (var _i6 = 0; _i6 < 256; _i6++) {
                bufferR[_i6] = _mapR[_i6] / 255;
                bufferG[_i6] = mapG[_i6] / 255;
                bufferB[_i6] = mapB[_i6] / 255;
              }
              tableR = bufferR.join(",");
              tableG = bufferG.join(",");
              tableB = bufferB.join(",");
              key = "".concat(tableR).concat(tableG).concat(tableB);
            }
            value = _classPrivateGetter(_DOMFilterFactory_brand, this, _get_cache).get(key);
            if (value) {
              _classPrivateGetter(_DOMFilterFactory_brand, this, _get_cache).set(maps, value);
              return value;
            }
            var id = "g_".concat(_classPrivateFieldGet(_docId2, this), "_transfer_map_").concat((_classPrivateFieldSet(_id3, this, (_this$id5 = _classPrivateFieldGet(_id3, this), _this$id6 = _this$id5++, _this$id5)), _this$id6));
            var url = "url(#".concat(id, ")");
            _classPrivateGetter(_DOMFilterFactory_brand, this, _get_cache).set(maps, url);
            _classPrivateGetter(_DOMFilterFactory_brand, this, _get_cache).set(key, url);
            var filter = _assertClassBrand(_DOMFilterFactory_brand, this, _createFilter).call(this, id);
            _assertClassBrand(_DOMFilterFactory_brand, this, _addTransferMapConversion).call(this, tableR, tableG, tableB, filter);
            return url;
          }
        }, {
          key: "addHCMFilter",
          value: function addHCMFilter(fgColor, bgColor) {
            var _classPrivateFieldGet18, _util$Util2, _util$Util3;
            var key = "".concat(fgColor, "-").concat(bgColor);
            if (_classPrivateFieldGet(_hcmKey, this) === key) {
              return _classPrivateFieldGet(_hcmUrl, this);
            }
            _classPrivateFieldSet(_hcmKey, this, key);
            _classPrivateFieldSet(_hcmUrl, this, "none");
            (_classPrivateFieldGet18 = _classPrivateFieldGet(_hcmFilter, this)) === null || _classPrivateFieldGet18 === void 0 || _classPrivateFieldGet18.remove();
            if (!fgColor || !bgColor) {
              return _classPrivateFieldGet(_hcmUrl, this);
            }
            var fgRGB = _assertClassBrand(_DOMFilterFactory_brand, this, _getRGB).call(this, fgColor);
            fgColor = (_util$Util2 = _util.Util).makeHexColor.apply(_util$Util2, _toConsumableArray(fgRGB));
            var bgRGB = _assertClassBrand(_DOMFilterFactory_brand, this, _getRGB).call(this, bgColor);
            bgColor = (_util$Util3 = _util.Util).makeHexColor.apply(_util$Util3, _toConsumableArray(bgRGB));
            _classPrivateGetter(_DOMFilterFactory_brand, this, _get_defs).style.color = "";
            if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
              return _classPrivateFieldGet(_hcmUrl, this);
            }
            var map = new Array(256);
            for (var i = 0; i <= 255; i++) {
              var x = i / 255;
              map[i] = x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
            }
            var table = map.join(",");
            var id = "g_".concat(_classPrivateFieldGet(_docId2, this), "_hcm_filter");
            var filter = _classPrivateFieldSet(_hcmHighlightFilter, this, _assertClassBrand(_DOMFilterFactory_brand, this, _createFilter).call(this, id));
            _assertClassBrand(_DOMFilterFactory_brand, this, _addTransferMapConversion).call(this, table, table, table, filter);
            _assertClassBrand(_DOMFilterFactory_brand, this, _addGrayConversion).call(this, filter);
            var getSteps = function getSteps(c, n) {
              var start = fgRGB[c] / 255;
              var end = bgRGB[c] / 255;
              var arr = new Array(n + 1);
              for (var _i7 = 0; _i7 <= n; _i7++) {
                arr[_i7] = start + _i7 / n * (end - start);
              }
              return arr.join(",");
            };
            _assertClassBrand(_DOMFilterFactory_brand, this, _addTransferMapConversion).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
            _classPrivateFieldSet(_hcmUrl, this, "url(#".concat(id, ")"));
            return _classPrivateFieldGet(_hcmUrl, this);
          }
        }, {
          key: "addHighlightHCMFilter",
          value: function addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
            var _classPrivateFieldGet19;
            var key = "".concat(fgColor, "-").concat(bgColor, "-").concat(newFgColor, "-").concat(newBgColor);
            if (_classPrivateFieldGet(_hcmHighlightKey, this) === key) {
              return _classPrivateFieldGet(_hcmHighlightUrl, this);
            }
            _classPrivateFieldSet(_hcmHighlightKey, this, key);
            _classPrivateFieldSet(_hcmHighlightUrl, this, "none");
            (_classPrivateFieldGet19 = _classPrivateFieldGet(_hcmHighlightFilter, this)) === null || _classPrivateFieldGet19 === void 0 || _classPrivateFieldGet19.remove();
            if (!fgColor || !bgColor) {
              return _classPrivateFieldGet(_hcmHighlightUrl, this);
            }
            var _map = [fgColor, bgColor].map(_assertClassBrand(_DOMFilterFactory_brand, this, _getRGB).bind(this)),
              _map2 = _slicedToArray(_map, 2),
              fgRGB = _map2[0],
              bgRGB = _map2[1];
            var fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
            var bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
            var _map3 = [newFgColor, newBgColor].map(_assertClassBrand(_DOMFilterFactory_brand, this, _getRGB).bind(this)),
              _map4 = _slicedToArray(_map3, 2),
              newFgRGB = _map4[0],
              newBgRGB = _map4[1];
            if (bgGray < fgGray) {
              var _ref36 = [bgGray, fgGray, newBgRGB, newFgRGB];
              fgGray = _ref36[0];
              bgGray = _ref36[1];
              newFgRGB = _ref36[2];
              newBgRGB = _ref36[3];
            }
            _classPrivateGetter(_DOMFilterFactory_brand, this, _get_defs).style.color = "";
            var getSteps = function getSteps(fg, bg, n) {
              var arr = new Array(256);
              var step = (bgGray - fgGray) / n;
              var newStart = fg / 255;
              var newStep = (bg - fg) / (255 * n);
              var prev = 0;
              for (var i = 0; i <= n; i++) {
                var k = Math.round(fgGray + i * step);
                var value = newStart + i * newStep;
                for (var j = prev; j <= k; j++) {
                  arr[j] = value;
                }
                prev = k + 1;
              }
              for (var _i8 = prev; _i8 < 256; _i8++) {
                arr[_i8] = arr[prev - 1];
              }
              return arr.join(",");
            };
            var id = "g_".concat(_classPrivateFieldGet(_docId2, this), "_hcm_highlight_filter");
            var filter = _classPrivateFieldSet(_hcmHighlightFilter, this, _assertClassBrand(_DOMFilterFactory_brand, this, _createFilter).call(this, id));
            _assertClassBrand(_DOMFilterFactory_brand, this, _addGrayConversion).call(this, filter);
            _assertClassBrand(_DOMFilterFactory_brand, this, _addTransferMapConversion).call(this, getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
            _classPrivateFieldSet(_hcmHighlightUrl, this, "url(#".concat(id, ")"));
            return _classPrivateFieldGet(_hcmHighlightUrl, this);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var keepHCM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (keepHCM && (_classPrivateFieldGet(_hcmUrl, this) || _classPrivateFieldGet(_hcmHighlightUrl, this))) {
              return;
            }
            if (_classPrivateFieldGet(_defs, this)) {
              _classPrivateFieldGet(_defs, this).parentNode.parentNode.remove();
              _classPrivateFieldSet(_defs, this, null);
            }
            if (_classPrivateFieldGet(_cache2, this)) {
              _classPrivateFieldGet(_cache2, this).clear();
              _classPrivateFieldSet(_cache2, this, null);
            }
            _classPrivateFieldSet(_id3, this, 0);
          }
        }]);
      }(_base_factory.BaseFilterFactory);
      function _get_cache(_this34) {
        return _classPrivateFieldGet(_cache2, _this34) || _classPrivateFieldSet(_cache2, _this34, new Map());
      }
      function _get_defs(_this35) {
        if (!_classPrivateFieldGet(_defs, _this35)) {
          var div = _classPrivateFieldGet(_document4, _this35).createElement("div");
          var style = div.style;
          style.visibility = "hidden";
          style.contain = "strict";
          style.width = style.height = 0;
          style.position = "absolute";
          style.top = style.left = 0;
          style.zIndex = -1;
          var svg = _classPrivateFieldGet(_document4, _this35).createElementNS(SVG_NS, "svg");
          svg.setAttribute("width", 0);
          svg.setAttribute("height", 0);
          _classPrivateFieldSet(_defs, _this35, _classPrivateFieldGet(_document4, _this35).createElementNS(SVG_NS, "defs"));
          div.append(svg);
          svg.append(_classPrivateFieldGet(_defs, _this35));
          _classPrivateFieldGet(_document4, _this35).body.append(div);
        }
        return _classPrivateFieldGet(_defs, _this35);
      }
      function _addGrayConversion(filter) {
        var feColorMatrix = _classPrivateFieldGet(_document4, this).createElementNS(SVG_NS, "feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
        filter.append(feColorMatrix);
      }
      function _createFilter(id) {
        var filter = _classPrivateFieldGet(_document4, this).createElementNS(SVG_NS, "filter");
        filter.setAttribute("color-interpolation-filters", "sRGB");
        filter.setAttribute("id", id);
        _classPrivateGetter(_DOMFilterFactory_brand, this, _get_defs).append(filter);
        return filter;
      }
      function _appendFeFunc(feComponentTransfer, func, table) {
        var feFunc = _classPrivateFieldGet(_document4, this).createElementNS(SVG_NS, func);
        feFunc.setAttribute("type", "discrete");
        feFunc.setAttribute("tableValues", table);
        feComponentTransfer.append(feFunc);
      }
      function _addTransferMapConversion(rTable, gTable, bTable, filter) {
        var feComponentTransfer = _classPrivateFieldGet(_document4, this).createElementNS(SVG_NS, "feComponentTransfer");
        filter.append(feComponentTransfer);
        _assertClassBrand(_DOMFilterFactory_brand, this, _appendFeFunc).call(this, feComponentTransfer, "feFuncR", rTable);
        _assertClassBrand(_DOMFilterFactory_brand, this, _appendFeFunc).call(this, feComponentTransfer, "feFuncG", gTable);
        _assertClassBrand(_DOMFilterFactory_brand, this, _appendFeFunc).call(this, feComponentTransfer, "feFuncB", bTable);
      }
      function _getRGB(color) {
        _classPrivateGetter(_DOMFilterFactory_brand, this, _get_defs).style.color = color;
        return getRGB(getComputedStyle(_classPrivateGetter(_DOMFilterFactory_brand, this, _get_defs)).getPropertyValue("color"));
      }
      exports.DOMFilterFactory = DOMFilterFactory;
      var DOMCanvasFactory = /*#__PURE__*/function (_base_factory$BaseCan) {
        function DOMCanvasFactory() {
          var _this37;
          var _ref37 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref37$ownerDocument = _ref37.ownerDocument,
            ownerDocument = _ref37$ownerDocument === void 0 ? globalThis.document : _ref37$ownerDocument;
          _classCallCheck(this, DOMCanvasFactory);
          _this37 = _callSuper(this, DOMCanvasFactory);
          _this37._document = ownerDocument;
          return _this37;
        }
        _inherits(DOMCanvasFactory, _base_factory$BaseCan);
        return _createClass(DOMCanvasFactory, [{
          key: "_createCanvas",
          value: function _createCanvas(width, height) {
            var canvas = this._document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            return canvas;
          }
        }]);
      }(_base_factory.BaseCanvasFactory);
      exports.DOMCanvasFactory = DOMCanvasFactory;
      function fetchData(_x9) {
        return _fetchData.apply(this, arguments);
      }
      function _fetchData() {
        _fetchData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(url) {
          var asTypedArray,
            response,
            _args14 = arguments;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                asTypedArray = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : false;
                if (!isValidFetchUrl(url, document.baseURI)) {
                  _context14.next = 21;
                  break;
                }
                _context14.next = 4;
                return fetch(url);
              case 4:
                response = _context14.sent;
                if (response.ok) {
                  _context14.next = 7;
                  break;
                }
                throw new Error(response.statusText);
              case 7:
                if (!asTypedArray) {
                  _context14.next = 15;
                  break;
                }
                _context14.t1 = Uint8Array;
                _context14.next = 11;
                return response.arrayBuffer();
              case 11:
                _context14.t2 = _context14.sent;
                _context14.t0 = new _context14.t1(_context14.t2);
                _context14.next = 20;
                break;
              case 15:
                _context14.t3 = (0, _util.stringToBytes);
                _context14.next = 18;
                return response.text();
              case 18:
                _context14.t4 = _context14.sent;
                _context14.t0 = (0, _context14.t3)(_context14.t4);
              case 20:
                return _context14.abrupt("return", _context14.t0);
              case 21:
                return _context14.abrupt("return", new Promise(function (resolve, reject) {
                  var request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = function () {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      var data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                }));
              case 22:
              case "end":
                return _context14.stop();
            }
          }, _callee14);
        }));
        return _fetchData.apply(this, arguments);
      }
      var DOMCMapReaderFactory = /*#__PURE__*/function (_base_factory$BaseCMa) {
        function DOMCMapReaderFactory() {
          _classCallCheck(this, DOMCMapReaderFactory);
          return _callSuper(this, DOMCMapReaderFactory, arguments);
        }
        _inherits(DOMCMapReaderFactory, _base_factory$BaseCMa);
        return _createClass(DOMCMapReaderFactory, [{
          key: "_fetchData",
          value: function _fetchData(url, compressionType) {
            return fetchData(url, this.isCompressed).then(function (data) {
              return {
                cMapData: data,
                compressionType: compressionType
              };
            });
          }
        }]);
      }(_base_factory.BaseCMapReaderFactory);
      exports.DOMCMapReaderFactory = DOMCMapReaderFactory;
      var DOMStandardFontDataFactory = /*#__PURE__*/function (_base_factory$BaseSta) {
        function DOMStandardFontDataFactory() {
          _classCallCheck(this, DOMStandardFontDataFactory);
          return _callSuper(this, DOMStandardFontDataFactory, arguments);
        }
        _inherits(DOMStandardFontDataFactory, _base_factory$BaseSta);
        return _createClass(DOMStandardFontDataFactory, [{
          key: "_fetchData",
          value: function _fetchData(url) {
            return fetchData(url, true);
          }
        }]);
      }(_base_factory.BaseStandardFontDataFactory);
      exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
      var DOMSVGFactory = /*#__PURE__*/function (_base_factory$BaseSVG) {
        function DOMSVGFactory() {
          _classCallCheck(this, DOMSVGFactory);
          return _callSuper(this, DOMSVGFactory, arguments);
        }
        _inherits(DOMSVGFactory, _base_factory$BaseSVG);
        return _createClass(DOMSVGFactory, [{
          key: "_createSVG",
          value: function _createSVG(type) {
            return document.createElementNS(SVG_NS, type);
          }
        }]);
      }(_base_factory.BaseSVGFactory);
      exports.DOMSVGFactory = DOMSVGFactory;
      var PageViewport = /*#__PURE__*/function () {
        function PageViewport(_ref38) {
          var viewBox = _ref38.viewBox,
            scale = _ref38.scale,
            rotation = _ref38.rotation,
            _ref38$offsetX = _ref38.offsetX,
            offsetX = _ref38$offsetX === void 0 ? 0 : _ref38$offsetX,
            _ref38$offsetY = _ref38.offsetY,
            offsetY = _ref38$offsetY === void 0 ? 0 : _ref38$offsetY,
            _ref38$dontFlip = _ref38.dontFlip,
            dontFlip = _ref38$dontFlip === void 0 ? false : _ref38$dontFlip;
          _classCallCheck(this, PageViewport);
          this.viewBox = viewBox;
          this.scale = scale;
          this.rotation = rotation;
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          var centerX = (viewBox[2] + viewBox[0]) / 2;
          var centerY = (viewBox[3] + viewBox[1]) / 2;
          var rotateA, rotateB, rotateC, rotateD;
          rotation %= 360;
          if (rotation < 0) {
            rotation += 360;
          }
          switch (rotation) {
            case 180:
              rotateA = -1;
              rotateB = 0;
              rotateC = 0;
              rotateD = 1;
              break;
            case 90:
              rotateA = 0;
              rotateB = 1;
              rotateC = 1;
              rotateD = 0;
              break;
            case 270:
              rotateA = 0;
              rotateB = -1;
              rotateC = -1;
              rotateD = 0;
              break;
            case 0:
              rotateA = 1;
              rotateB = 0;
              rotateC = 0;
              rotateD = -1;
              break;
            default:
              throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
          }
          if (dontFlip) {
            rotateC = -rotateC;
            rotateD = -rotateD;
          }
          var offsetCanvasX, offsetCanvasY;
          var width, height;
          if (rotateA === 0) {
            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
            width = (viewBox[3] - viewBox[1]) * scale;
            height = (viewBox[2] - viewBox[0]) * scale;
          } else {
            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
            width = (viewBox[2] - viewBox[0]) * scale;
            height = (viewBox[3] - viewBox[1]) * scale;
          }
          this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
          this.width = width;
          this.height = height;
        }
        return _createClass(PageViewport, [{
          key: "rawDims",
          get: function get() {
            var viewBox = this.viewBox;
            return (0, _util.shadow)(this, "rawDims", {
              pageWidth: viewBox[2] - viewBox[0],
              pageHeight: viewBox[3] - viewBox[1],
              pageX: viewBox[0],
              pageY: viewBox[1]
            });
          }
        }, {
          key: "clone",
          value: function clone() {
            var _ref39 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref39$scale = _ref39.scale,
              scale = _ref39$scale === void 0 ? this.scale : _ref39$scale,
              _ref39$rotation = _ref39.rotation,
              rotation = _ref39$rotation === void 0 ? this.rotation : _ref39$rotation,
              _ref39$offsetX = _ref39.offsetX,
              offsetX = _ref39$offsetX === void 0 ? this.offsetX : _ref39$offsetX,
              _ref39$offsetY = _ref39.offsetY,
              offsetY = _ref39$offsetY === void 0 ? this.offsetY : _ref39$offsetY,
              _ref39$dontFlip = _ref39.dontFlip,
              dontFlip = _ref39$dontFlip === void 0 ? false : _ref39$dontFlip;
            return new PageViewport({
              viewBox: this.viewBox.slice(),
              scale: scale,
              rotation: rotation,
              offsetX: offsetX,
              offsetY: offsetY,
              dontFlip: dontFlip
            });
          }
        }, {
          key: "convertToViewportPoint",
          value: function convertToViewportPoint(x, y) {
            return _util.Util.applyTransform([x, y], this.transform);
          }
        }, {
          key: "convertToViewportRectangle",
          value: function convertToViewportRectangle(rect) {
            var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);
            var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);
            return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
          }
        }, {
          key: "convertToPdfPoint",
          value: function convertToPdfPoint(x, y) {
            return _util.Util.applyInverseTransform([x, y], this.transform);
          }
        }]);
      }();
      exports.PageViewport = PageViewport;
      var RenderingCancelledException = /*#__PURE__*/function (_util$BaseException) {
        function RenderingCancelledException(msg) {
          var _this38;
          var extraDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          _classCallCheck(this, RenderingCancelledException);
          _this38 = _callSuper(this, RenderingCancelledException, [msg, "RenderingCancelledException"]);
          _this38.extraDelay = extraDelay;
          return _this38;
        }
        _inherits(RenderingCancelledException, _util$BaseException);
        return _createClass(RenderingCancelledException);
      }(_util.BaseException);
      exports.RenderingCancelledException = RenderingCancelledException;
      function isDataScheme(url) {
        var ii = url.length;
        var i = 0;
        while (i < ii && url[i].trim() === "") {
          i++;
        }
        return url.substring(i, i + 5).toLowerCase() === "data:";
      }
      function isPdfFile(filename) {
        return typeof filename === "string" && /\.pdf$/i.test(filename);
      }
      function getFilenameFromUrl(url) {
        var onlyStripPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!onlyStripPath) {
          var _url$split = url.split(/[#?]/, 1);
          var _url$split2 = _slicedToArray(_url$split, 1);
          url = _url$split2[0];
        }
        return url.substring(url.lastIndexOf("/") + 1);
      }
      function getPdfFilenameFromUrl(url) {
        var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf";
        if (typeof url !== "string") {
          return defaultFilename;
        }
        if (isDataScheme(url)) {
          (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
          return defaultFilename;
        }
        var reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
        var reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
        var splitURI = reURI.exec(url);
        var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
        if (suggestedFilename) {
          suggestedFilename = suggestedFilename[0];
          if (suggestedFilename.includes("%")) {
            try {
              suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
            } catch (_unused9) {}
          }
        }
        return suggestedFilename || defaultFilename;
      }
      var StatTimer = /*#__PURE__*/function () {
        function StatTimer() {
          _classCallCheck(this, StatTimer);
          _defineProperty(this, "started", Object.create(null));
          _defineProperty(this, "times", []);
        }
        return _createClass(StatTimer, [{
          key: "time",
          value: function time(name) {
            if (name in this.started) {
              (0, _util.warn)("Timer is already running for ".concat(name));
            }
            this.started[name] = Date.now();
          }
        }, {
          key: "timeEnd",
          value: function timeEnd(name) {
            if (!(name in this.started)) {
              (0, _util.warn)("Timer has not been started for ".concat(name));
            }
            this.times.push({
              name: name,
              start: this.started[name],
              end: Date.now()
            });
            delete this.started[name];
          }
        }, {
          key: "toString",
          value: function toString() {
            var outBuf = [];
            var longest = 0;
            var _iterator55 = _createForOfIteratorHelper(this.times),
              _step55;
            try {
              for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
                var name = _step55.value.name;
                longest = Math.max(name.length, longest);
              }
            } catch (err) {
              _iterator55.e(err);
            } finally {
              _iterator55.f();
            }
            var _iterator56 = _createForOfIteratorHelper(this.times),
              _step56;
            try {
              for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
                var _step56$value = _step56.value,
                  _name = _step56$value.name,
                  start = _step56$value.start,
                  end = _step56$value.end;
                outBuf.push("".concat(_name.padEnd(longest), " ").concat(end - start, "ms\n"));
              }
            } catch (err) {
              _iterator56.e(err);
            } finally {
              _iterator56.f();
            }
            return outBuf.join("");
          }
        }]);
      }();
      exports.StatTimer = StatTimer;
      function isValidFetchUrl(url, baseUrl) {
        try {
          var _ref40 = baseUrl ? new URL(url, baseUrl) : new URL(url),
            protocol = _ref40.protocol;
          return protocol === "http:" || protocol === "https:";
        } catch (_unused10) {
          return false;
        }
      }
      function noContextMenu(e) {
        e.preventDefault();
      }
      function loadScript(src) {
        var removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return new Promise(function (resolve, reject) {
          var script = document.createElement("script");
          script.src = src;
          script.onload = function (evt) {
            if (removeScriptElement) {
              script.remove();
            }
            resolve(evt);
          };
          script.onerror = function () {
            reject(new Error("Cannot load script at: ".concat(script.src)));
          };
          (document.head || document.documentElement).append(script);
        });
      }
      function deprecated(details) {
        console.log("Deprecated API usage: " + details);
      }
      var pdfDateStringRegex;
      var PDFDateString = /*#__PURE__*/function () {
        function PDFDateString() {
          _classCallCheck(this, PDFDateString);
        }
        return _createClass(PDFDateString, null, [{
          key: "toDateObject",
          value: function toDateObject(input) {
            if (!input || typeof input !== "string") {
              return null;
            }
            pdfDateStringRegex || (pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?"));
            var matches = pdfDateStringRegex.exec(input);
            if (!matches) {
              return null;
            }
            var year = parseInt(matches[1], 10);
            var month = parseInt(matches[2], 10);
            month = month >= 1 && month <= 12 ? month - 1 : 0;
            var day = parseInt(matches[3], 10);
            day = day >= 1 && day <= 31 ? day : 1;
            var hour = parseInt(matches[4], 10);
            hour = hour >= 0 && hour <= 23 ? hour : 0;
            var minute = parseInt(matches[5], 10);
            minute = minute >= 0 && minute <= 59 ? minute : 0;
            var second = parseInt(matches[6], 10);
            second = second >= 0 && second <= 59 ? second : 0;
            var universalTimeRelation = matches[7] || "Z";
            var offsetHour = parseInt(matches[8], 10);
            offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
            var offsetMinute = parseInt(matches[9], 10) || 0;
            offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
            if (universalTimeRelation === "-") {
              hour += offsetHour;
              minute += offsetMinute;
            } else if (universalTimeRelation === "+") {
              hour -= offsetHour;
              minute -= offsetMinute;
            }
            return new Date(Date.UTC(year, month, day, hour, minute, second));
          }
        }]);
      }();
      exports.PDFDateString = PDFDateString;
      function getXfaPageViewport(xfaPage, _ref41) {
        var _ref41$scale = _ref41.scale,
          scale = _ref41$scale === void 0 ? 1 : _ref41$scale,
          _ref41$rotation = _ref41.rotation,
          rotation = _ref41$rotation === void 0 ? 0 : _ref41$rotation;
        var _xfaPage$attributes$s = xfaPage.attributes.style,
          width = _xfaPage$attributes$s.width,
          height = _xfaPage$attributes$s.height;
        var viewBox = [0, 0, parseInt(width), parseInt(height)];
        return new PageViewport({
          viewBox: viewBox,
          scale: scale,
          rotation: rotation
        });
      }
      function getRGB(color) {
        if (color.startsWith("#")) {
          var colorRGB = parseInt(color.slice(1), 16);
          return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];
        }
        if (color.startsWith("rgb(")) {
          return color.slice(4, -1).split(",").map(function (x) {
            return parseInt(x);
          });
        }
        if (color.startsWith("rgba(")) {
          return color.slice(5, -1).split(",").map(function (x) {
            return parseInt(x);
          }).slice(0, 3);
        }
        (0, _util.warn)("Not a valid color format: \"".concat(color, "\""));
        return [0, 0, 0];
      }
      function getColorValues(colors) {
        var span = document.createElement("span");
        span.style.visibility = "hidden";
        document.body.append(span);
        var _iterator57 = _createForOfIteratorHelper(colors.keys()),
          _step57;
        try {
          for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
            var name = _step57.value;
            span.style.color = name;
            var computedColor = window.getComputedStyle(span).color;
            colors.set(name, getRGB(computedColor));
          }
        } catch (err) {
          _iterator57.e(err);
        } finally {
          _iterator57.f();
        }
        span.remove();
      }
      function getCurrentTransform(ctx) {
        var _ctx$getTransform = ctx.getTransform(),
          a = _ctx$getTransform.a,
          b = _ctx$getTransform.b,
          c = _ctx$getTransform.c,
          d = _ctx$getTransform.d,
          e = _ctx$getTransform.e,
          f = _ctx$getTransform.f;
        return [a, b, c, d, e, f];
      }
      function getCurrentTransformInverse(ctx) {
        var _ctx$getTransform$inv = ctx.getTransform().invertSelf(),
          a = _ctx$getTransform$inv.a,
          b = _ctx$getTransform$inv.b,
          c = _ctx$getTransform$inv.c,
          d = _ctx$getTransform$inv.d,
          e = _ctx$getTransform$inv.e,
          f = _ctx$getTransform$inv.f;
        return [a, b, c, d, e, f];
      }
      function setLayerDimensions(div, viewport) {
        var mustFlip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var mustRotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        if (viewport instanceof PageViewport) {
          var _viewport$rawDims = viewport.rawDims,
            pageWidth = _viewport$rawDims.pageWidth,
            pageHeight = _viewport$rawDims.pageHeight;
          var style = div.style;
          var useRound = _util.FeatureTest.isCSSRoundSupported;
          var w = "var(--scale-factor) * ".concat(pageWidth, "px"),
            h = "var(--scale-factor) * ".concat(pageHeight, "px");
          var widthStr = useRound ? "round(".concat(w, ", 1px)") : "calc(".concat(w, ")"),
            heightStr = useRound ? "round(".concat(h, ", 1px)") : "calc(".concat(h, ")");
          if (!mustFlip || viewport.rotation % 180 === 0) {
            style.width = widthStr;
            style.height = heightStr;
          } else {
            style.width = heightStr;
            style.height = widthStr;
          }
        }
        if (mustRotate) {
          div.setAttribute("data-main-rotation", viewport.rotation);
        }
      }

      /***/
    }), (/* 7 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseFilterFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;
      var _util = __w_pdfjs_require__(1);
      var BaseFilterFactory = /*#__PURE__*/function () {
        function BaseFilterFactory() {
          _classCallCheck(this, BaseFilterFactory);
          if (this.constructor === BaseFilterFactory) {
            (0, _util.unreachable)("Cannot initialize BaseFilterFactory.");
          }
        }
        return _createClass(BaseFilterFactory, [{
          key: "addFilter",
          value: function addFilter(maps) {
            return "none";
          }
        }, {
          key: "addHCMFilter",
          value: function addHCMFilter(fgColor, bgColor) {
            return "none";
          }
        }, {
          key: "addHighlightHCMFilter",
          value: function addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
            return "none";
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var keepHCM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          }
        }]);
      }();
      exports.BaseFilterFactory = BaseFilterFactory;
      var BaseCanvasFactory = /*#__PURE__*/function () {
        function BaseCanvasFactory() {
          _classCallCheck(this, BaseCanvasFactory);
          if (this.constructor === BaseCanvasFactory) {
            (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
          }
        }
        return _createClass(BaseCanvasFactory, [{
          key: "create",
          value: function create(width, height) {
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid canvas size");
            }
            var canvas = this._createCanvas(width, height);
            return {
              canvas: canvas,
              context: canvas.getContext("2d")
            };
          }
        }, {
          key: "reset",
          value: function reset(canvasAndContext, width, height) {
            if (!canvasAndContext.canvas) {
              throw new Error("Canvas is not specified");
            }
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid canvas size");
            }
            canvasAndContext.canvas.width = width;
            canvasAndContext.canvas.height = height;
          }
        }, {
          key: "destroy",
          value: function destroy(canvasAndContext) {
            if (!canvasAndContext.canvas) {
              throw new Error("Canvas is not specified");
            }
            canvasAndContext.canvas.width = 0;
            canvasAndContext.canvas.height = 0;
            canvasAndContext.canvas = null;
            canvasAndContext.context = null;
          }
        }, {
          key: "_createCanvas",
          value: function _createCanvas(width, height) {
            (0, _util.unreachable)("Abstract method `_createCanvas` called.");
          }
        }]);
      }();
      exports.BaseCanvasFactory = BaseCanvasFactory;
      var BaseCMapReaderFactory = /*#__PURE__*/function () {
        function BaseCMapReaderFactory(_ref42) {
          var _ref42$baseUrl = _ref42.baseUrl,
            baseUrl = _ref42$baseUrl === void 0 ? null : _ref42$baseUrl,
            _ref42$isCompressed = _ref42.isCompressed,
            isCompressed = _ref42$isCompressed === void 0 ? true : _ref42$isCompressed;
          _classCallCheck(this, BaseCMapReaderFactory);
          if (this.constructor === BaseCMapReaderFactory) {
            (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
          }
          this.baseUrl = baseUrl;
          this.isCompressed = isCompressed;
        }
        return _createClass(BaseCMapReaderFactory, [{
          key: "fetch",
          value: function () {
            var _fetch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_ref43) {
              var _this39 = this;
              var name, url, compressionType;
              return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                while (1) switch (_context15.prev = _context15.next) {
                  case 0:
                    name = _ref43.name;
                    if (this.baseUrl) {
                      _context15.next = 3;
                      break;
                    }
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  case 3:
                    if (name) {
                      _context15.next = 5;
                      break;
                    }
                    throw new Error("CMap name must be specified.");
                  case 5:
                    url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                    compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
                    return _context15.abrupt("return", this._fetchData(url, compressionType).catch(function (reason) {
                      throw new Error("Unable to load ".concat(_this39.isCompressed ? "binary " : "", "CMap at: ").concat(url));
                    }));
                  case 8:
                  case "end":
                    return _context15.stop();
                }
              }, _callee15, this);
            }));
            function fetch(_x10) {
              return _fetch.apply(this, arguments);
            }
            return fetch;
          }()
        }, {
          key: "_fetchData",
          value: function _fetchData(url, compressionType) {
            (0, _util.unreachable)("Abstract method `_fetchData` called.");
          }
        }]);
      }();
      exports.BaseCMapReaderFactory = BaseCMapReaderFactory;
      var BaseStandardFontDataFactory = /*#__PURE__*/function () {
        function BaseStandardFontDataFactory(_ref44) {
          var _ref44$baseUrl = _ref44.baseUrl,
            baseUrl = _ref44$baseUrl === void 0 ? null : _ref44$baseUrl;
          _classCallCheck(this, BaseStandardFontDataFactory);
          if (this.constructor === BaseStandardFontDataFactory) {
            (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
          }
          this.baseUrl = baseUrl;
        }
        return _createClass(BaseStandardFontDataFactory, [{
          key: "fetch",
          value: function () {
            var _fetch2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(_ref45) {
              var filename, url;
              return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                while (1) switch (_context16.prev = _context16.next) {
                  case 0:
                    filename = _ref45.filename;
                    if (this.baseUrl) {
                      _context16.next = 3;
                      break;
                    }
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
                  case 3:
                    if (filename) {
                      _context16.next = 5;
                      break;
                    }
                    throw new Error("Font filename must be specified.");
                  case 5:
                    url = "".concat(this.baseUrl).concat(filename);
                    return _context16.abrupt("return", this._fetchData(url).catch(function (reason) {
                      throw new Error("Unable to load font data at: ".concat(url));
                    }));
                  case 7:
                  case "end":
                    return _context16.stop();
                }
              }, _callee16, this);
            }));
            function fetch(_x11) {
              return _fetch2.apply(this, arguments);
            }
            return fetch;
          }()
        }, {
          key: "_fetchData",
          value: function _fetchData(url) {
            (0, _util.unreachable)("Abstract method `_fetchData` called.");
          }
        }]);
      }();
      exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
      var BaseSVGFactory = /*#__PURE__*/function () {
        function BaseSVGFactory() {
          _classCallCheck(this, BaseSVGFactory);
          if (this.constructor === BaseSVGFactory) {
            (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
          }
        }
        return _createClass(BaseSVGFactory, [{
          key: "create",
          value: function create(width, height) {
            var skipDimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid SVG dimensions");
            }
            var svg = this._createSVG("svg:svg");
            svg.setAttribute("version", "1.1");
            if (!skipDimensions) {
              svg.setAttribute("width", "".concat(width, "px"));
              svg.setAttribute("height", "".concat(height, "px"));
            }
            svg.setAttribute("preserveAspectRatio", "none");
            svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
            return svg;
          }
        }, {
          key: "createElement",
          value: function createElement(type) {
            if (typeof type !== "string") {
              throw new Error("Invalid SVG element type");
            }
            return this._createSVG(type);
          }
        }, {
          key: "_createSVG",
          value: function _createSVG(type) {
            (0, _util.unreachable)("Abstract method `_createSVG` called.");
          }
        }]);
      }();
      exports.BaseSVGFactory = BaseSVGFactory;

      /***/
    }), (/* 8 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MurmurHash3_64 = void 0;
      var _util = __w_pdfjs_require__(1);
      var SEED = 0xc3d2e1f0;
      var MASK_HIGH = 0xffff0000;
      var MASK_LOW = 0xffff;
      var MurmurHash3_64 = /*#__PURE__*/function () {
        function MurmurHash3_64(seed) {
          _classCallCheck(this, MurmurHash3_64);
          this.h1 = seed ? seed & 0xffffffff : SEED;
          this.h2 = seed ? seed & 0xffffffff : SEED;
        }
        return _createClass(MurmurHash3_64, [{
          key: "update",
          value: function update(input) {
            var data, length;
            if (typeof input === "string") {
              data = new Uint8Array(input.length * 2);
              length = 0;
              for (var i = 0, ii = input.length; i < ii; i++) {
                var code = input.charCodeAt(i);
                if (code <= 0xff) {
                  data[length++] = code;
                } else {
                  data[length++] = code >>> 8;
                  data[length++] = code & 0xff;
                }
              }
            } else if ((0, _util.isArrayBuffer)(input)) {
              data = input.slice();
              length = data.byteLength;
            } else {
              throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
            }
            var blockCounts = length >> 2;
            var tailLength = length - blockCounts * 4;
            var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
            var k1 = 0,
              k2 = 0;
            var h1 = this.h1,
              h2 = this.h2;
            var C1 = 0xcc9e2d51,
              C2 = 0x1b873593;
            var C1_LOW = C1 & MASK_LOW,
              C2_LOW = C2 & MASK_LOW;
            for (var _i9 = 0; _i9 < blockCounts; _i9++) {
              if (_i9 & 1) {
                k1 = dataUint32[_i9];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                h1 ^= k1;
                h1 = h1 << 13 | h1 >>> 19;
                h1 = h1 * 5 + 0xe6546b64;
              } else {
                k2 = dataUint32[_i9];
                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                k2 = k2 << 15 | k2 >>> 17;
                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                h2 ^= k2;
                h2 = h2 << 13 | h2 >>> 19;
                h2 = h2 * 5 + 0xe6546b64;
              }
            }
            k1 = 0;
            switch (tailLength) {
              case 3:
                k1 ^= data[blockCounts * 4 + 2] << 16;
              case 2:
                k1 ^= data[blockCounts * 4 + 1] << 8;
              case 1:
                k1 ^= data[blockCounts * 4];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                if (blockCounts & 1) {
                  h1 ^= k1;
                } else {
                  h2 ^= k1;
                }
            }
            this.h1 = h1;
            this.h2 = h2;
          }
        }, {
          key: "hexdigest",
          value: function hexdigest() {
            var h1 = this.h1,
              h2 = this.h2;
            h1 ^= h2 >>> 1;
            h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
            h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
            h1 ^= h2 >>> 1;
            h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
            h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
            h1 ^= h2 >>> 1;
            return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
          }
        }]);
      }();
      exports.MurmurHash3_64 = MurmurHash3_64;

      /***/
    }), (/* 9 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FontLoader = exports.FontFaceObject = void 0;
      var _util = __w_pdfjs_require__(1);
      var _systemFonts = /*#__PURE__*/new WeakMap();
      var FontLoader = /*#__PURE__*/function () {
        function FontLoader(_ref46) {
          var _ref46$ownerDocument = _ref46.ownerDocument,
            ownerDocument = _ref46$ownerDocument === void 0 ? globalThis.document : _ref46$ownerDocument,
            _ref46$styleElement = _ref46.styleElement,
            styleElement = _ref46$styleElement === void 0 ? null : _ref46$styleElement;
          _classCallCheck(this, FontLoader);
          _classPrivateFieldInitSpec(this, _systemFonts, new Set());
          this._document = ownerDocument;
          this.nativeFontFaces = new Set();
          this.styleElement = null;
          this.loadingRequests = [];
          this.loadTestFontId = 0;
        }
        return _createClass(FontLoader, [{
          key: "addNativeFontFace",
          value: function addNativeFontFace(nativeFontFace) {
            this.nativeFontFaces.add(nativeFontFace);
            this._document.fonts.add(nativeFontFace);
          }
        }, {
          key: "removeNativeFontFace",
          value: function removeNativeFontFace(nativeFontFace) {
            this.nativeFontFaces.delete(nativeFontFace);
            this._document.fonts.delete(nativeFontFace);
          }
        }, {
          key: "insertRule",
          value: function insertRule(rule) {
            if (!this.styleElement) {
              this.styleElement = this._document.createElement("style");
              this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
            }
            var styleSheet = this.styleElement.sheet;
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
          }
        }, {
          key: "clear",
          value: function clear() {
            var _iterator58 = _createForOfIteratorHelper(this.nativeFontFaces),
              _step58;
            try {
              for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
                var nativeFontFace = _step58.value;
                this._document.fonts.delete(nativeFontFace);
              }
            } catch (err) {
              _iterator58.e(err);
            } finally {
              _iterator58.f();
            }
            this.nativeFontFaces.clear();
            _classPrivateFieldGet(_systemFonts, this).clear();
            if (this.styleElement) {
              this.styleElement.remove();
              this.styleElement = null;
            }
          }
        }, {
          key: "loadSystemFont",
          value: function () {
            var _loadSystemFont = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(info) {
              var loadedName, src, style, fontFace;
              return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                while (1) switch (_context17.prev = _context17.next) {
                  case 0:
                    if (!(!info || _classPrivateFieldGet(_systemFonts, this).has(info.loadedName))) {
                      _context17.next = 2;
                      break;
                    }
                    return _context17.abrupt("return");
                  case 2:
                    (0, _util.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
                    if (!this.isFontLoadingAPISupported) {
                      _context17.next = 18;
                      break;
                    }
                    loadedName = info.loadedName, src = info.src, style = info.style;
                    fontFace = new FontFace(loadedName, src, style);
                    this.addNativeFontFace(fontFace);
                    _context17.prev = 7;
                    _context17.next = 10;
                    return fontFace.load();
                  case 10:
                    _classPrivateFieldGet(_systemFonts, this).add(loadedName);
                    _context17.next = 17;
                    break;
                  case 13:
                    _context17.prev = 13;
                    _context17.t0 = _context17["catch"](7);
                    (0, _util.warn)("Cannot load system font: ".concat(info.baseFontName, ", installing it could help to improve PDF rendering."));
                    this.removeNativeFontFace(fontFace);
                  case 17:
                    return _context17.abrupt("return");
                  case 18:
                    (0, _util.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
                  case 19:
                  case "end":
                    return _context17.stop();
                }
              }, _callee17, this, [[7, 13]]);
            }));
            function loadSystemFont(_x12) {
              return _loadSystemFont.apply(this, arguments);
            }
            return loadSystemFont;
          }()
        }, {
          key: "bind",
          value: function () {
            var _bind = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(font) {
              var _this40 = this;
              var nativeFontFace, rule;
              return _regeneratorRuntime().wrap(function _callee18$(_context18) {
                while (1) switch (_context18.prev = _context18.next) {
                  case 0:
                    if (!(font.attached || font.missingFile && !font.systemFontInfo)) {
                      _context18.next = 2;
                      break;
                    }
                    return _context18.abrupt("return");
                  case 2:
                    font.attached = true;
                    if (!font.systemFontInfo) {
                      _context18.next = 7;
                      break;
                    }
                    _context18.next = 6;
                    return this.loadSystemFont(font.systemFontInfo);
                  case 6:
                    return _context18.abrupt("return");
                  case 7:
                    if (!this.isFontLoadingAPISupported) {
                      _context18.next = 22;
                      break;
                    }
                    nativeFontFace = font.createNativeFontFace();
                    if (!nativeFontFace) {
                      _context18.next = 21;
                      break;
                    }
                    this.addNativeFontFace(nativeFontFace);
                    _context18.prev = 11;
                    _context18.next = 14;
                    return nativeFontFace.loaded;
                  case 14:
                    _context18.next = 21;
                    break;
                  case 16:
                    _context18.prev = 16;
                    _context18.t0 = _context18["catch"](11);
                    (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context18.t0, "'."));
                    font.disableFontFace = true;
                    throw _context18.t0;
                  case 21:
                    return _context18.abrupt("return");
                  case 22:
                    rule = font.createFontFaceRule();
                    if (!rule) {
                      _context18.next = 29;
                      break;
                    }
                    this.insertRule(rule);
                    if (!this.isSyncFontLoadingSupported) {
                      _context18.next = 27;
                      break;
                    }
                    return _context18.abrupt("return");
                  case 27:
                    _context18.next = 29;
                    return new Promise(function (resolve) {
                      var request = _this40._queueLoadingCallback(resolve);
                      _this40._prepareFontLoadEvent(font, request);
                    });
                  case 29:
                  case "end":
                    return _context18.stop();
                }
              }, _callee18, this, [[11, 16]]);
            }));
            function bind(_x13) {
              return _bind.apply(this, arguments);
            }
            return bind;
          }()
        }, {
          key: "isFontLoadingAPISupported",
          get: function get() {
            var _this$_document;
            var hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
            return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
          }
        }, {
          key: "isSyncFontLoadingSupported",
          get: function get() {
            var supported = false;
            if (_util.isNodeJS) {
              supported = true;
            } else if (typeof navigator !== "undefined" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
              supported = true;
            }
            return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
          }
        }, {
          key: "_queueLoadingCallback",
          value: function _queueLoadingCallback(callback) {
            function completeRequest() {
              (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
              request.done = true;
              while (loadingRequests.length > 0 && loadingRequests[0].done) {
                var otherRequest = loadingRequests.shift();
                setTimeout(otherRequest.callback, 0);
              }
            }
            var loadingRequests = this.loadingRequests;
            var request = {
              done: false,
              complete: completeRequest,
              callback: callback
            };
            loadingRequests.push(request);
            return request;
          }
        }, {
          key: "_loadTestFont",
          get: function get() {
            var testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
            return (0, _util.shadow)(this, "_loadTestFont", testFont);
          }
        }, {
          key: "_prepareFontLoadEvent",
          value: function _prepareFontLoadEvent(font, request) {
            function int32(data, offset) {
              return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
            }
            function spliceString(s, offset, remove, insert) {
              var chunk1 = s.substring(0, offset);
              var chunk2 = s.substring(offset + remove);
              return chunk1 + insert + chunk2;
            }
            var i, ii;
            var canvas = this._document.createElement("canvas");
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext("2d");
            var called = 0;
            function isFontReady(name, callback) {
              if (++called > 30) {
                (0, _util.warn)("Load test font never loaded.");
                callback();
                return;
              }
              ctx.font = "30px " + name;
              ctx.fillText(".", 0, 20);
              var imageData = ctx.getImageData(0, 0, 1, 1);
              if (imageData.data[3] > 0) {
                callback();
                return;
              }
              setTimeout(isFontReady.bind(null, name, callback));
            }
            var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
            var data = this._loadTestFont;
            var COMMENT_OFFSET = 976;
            data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
            var CFF_CHECKSUM_OFFSET = 16;
            var XXXX_VALUE = 0x58585858;
            var checksum = int32(data, CFF_CHECKSUM_OFFSET);
            for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
              checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
            }
            if (i < loadTestFontId.length) {
              checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
            }
            data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
            var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
            var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}");
            this.insertRule(rule);
            var div = this._document.createElement("div");
            div.style.visibility = "hidden";
            div.style.width = div.style.height = "10px";
            div.style.position = "absolute";
            div.style.top = div.style.left = "0px";
            for (var _i10 = 0, _arr = [font.loadedName, loadTestFontId]; _i10 < _arr.length; _i10++) {
              var name = _arr[_i10];
              var span = this._document.createElement("span");
              span.textContent = "Hi";
              span.style.fontFamily = name;
              div.append(span);
            }
            this._document.body.append(div);
            isFontReady(loadTestFontId, function () {
              div.remove();
              request.complete();
            });
          }
        }]);
      }();
      exports.FontLoader = FontLoader;
      var FontFaceObject = /*#__PURE__*/function () {
        function FontFaceObject(translatedData, _ref47) {
          var _ref47$isEvalSupporte = _ref47.isEvalSupported,
            isEvalSupported = _ref47$isEvalSupporte === void 0 ? true : _ref47$isEvalSupporte,
            _ref47$disableFontFac = _ref47.disableFontFace,
            disableFontFace = _ref47$disableFontFac === void 0 ? false : _ref47$disableFontFac,
            _ref47$ignoreErrors = _ref47.ignoreErrors,
            ignoreErrors = _ref47$ignoreErrors === void 0 ? false : _ref47$ignoreErrors,
            _ref47$inspectFont = _ref47.inspectFont,
            inspectFont = _ref47$inspectFont === void 0 ? null : _ref47$inspectFont;
          _classCallCheck(this, FontFaceObject);
          this.compiledGlyphs = Object.create(null);
          for (var i in translatedData) {
            this[i] = translatedData[i];
          }
          this.isEvalSupported = isEvalSupported !== false;
          this.disableFontFace = disableFontFace === true;
          this.ignoreErrors = ignoreErrors === true;
          this._inspectFont = inspectFont;
        }
        return _createClass(FontFaceObject, [{
          key: "createNativeFontFace",
          value: function createNativeFontFace() {
            var _this$_inspectFont;
            if (!this.data || this.disableFontFace) {
              return null;
            }
            var nativeFontFace;
            if (!this.cssFontInfo) {
              nativeFontFace = new FontFace(this.loadedName, this.data, {});
            } else {
              var css = {
                weight: this.cssFontInfo.fontWeight
              };
              if (this.cssFontInfo.italicAngle) {
                css.style = "oblique ".concat(this.cssFontInfo.italicAngle, "deg");
              }
              nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
            }
            (_this$_inspectFont = this._inspectFont) === null || _this$_inspectFont === void 0 || _this$_inspectFont.call(this, this);
            return nativeFontFace;
          }
        }, {
          key: "createFontFaceRule",
          value: function createFontFaceRule() {
            var _this$_inspectFont2;
            if (!this.data || this.disableFontFace) {
              return null;
            }
            var data = (0, _util.bytesToString)(this.data);
            var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
            var rule;
            if (!this.cssFontInfo) {
              rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}");
            } else {
              var css = "font-weight: ".concat(this.cssFontInfo.fontWeight, ";");
              if (this.cssFontInfo.italicAngle) {
                css += "font-style: oblique ".concat(this.cssFontInfo.italicAngle, "deg;");
              }
              rule = "@font-face {font-family:\"".concat(this.cssFontInfo.fontFamily, "\";").concat(css, "src:").concat(url, "}");
            }
            (_this$_inspectFont2 = this._inspectFont) === null || _this$_inspectFont2 === void 0 || _this$_inspectFont2.call(this, this, url);
            return rule;
          }
        }, {
          key: "getPathGenerator",
          value: function getPathGenerator(objs, character) {
            if (this.compiledGlyphs[character] !== undefined) {
              return this.compiledGlyphs[character];
            }
            var cmds;
            try {
              cmds = objs.get(this.loadedName + "_path_" + character);
            } catch (ex) {
              if (!this.ignoreErrors) {
                throw ex;
              }
              (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\"."));
              return this.compiledGlyphs[character] = function (c, size) {};
            }
            if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {
              var jsBuf = [];
              var _iterator59 = _createForOfIteratorHelper(cmds),
                _step59;
              try {
                for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
                  var current = _step59.value;
                  var args = current.args !== undefined ? current.args.join(",") : "";
                  jsBuf.push("c.", current.cmd, "(", args, ");\n");
                }
              } catch (err) {
                _iterator59.e(err);
              } finally {
                _iterator59.f();
              }
              return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
            }
            return this.compiledGlyphs[character] = function (c, size) {
              var _iterator60 = _createForOfIteratorHelper(cmds),
                _step60;
              try {
                for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
                  var _current = _step60.value;
                  if (_current.cmd === "scale") {
                    _current.args = [size, -size];
                  }
                  c[_current.cmd].apply(c, _current.args);
                }
              } catch (err) {
                _iterator60.e(err);
              } finally {
                _iterator60.f();
              }
            };
          }
        }]);
      }();
      exports.FontFaceObject = FontFaceObject;

      /***/
    }), (/* 10 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NodeStandardFontDataFactory = exports.NodeFilterFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;
      var _base_factory = __w_pdfjs_require__(7);
      var _util = __w_pdfjs_require__(1);
      ;
      ;
      var fetchData = function fetchData(url) {
        return new Promise(function (resolve, reject) {
          var fs = require("fs");
          fs.readFile(url, function (error, data) {
            if (error || !data) {
              reject(new Error(error));
              return;
            }
            resolve(new Uint8Array(data));
          });
        });
      };
      var NodeFilterFactory = /*#__PURE__*/function (_base_factory$BaseFil2) {
        function NodeFilterFactory() {
          _classCallCheck(this, NodeFilterFactory);
          return _callSuper(this, NodeFilterFactory, arguments);
        }
        _inherits(NodeFilterFactory, _base_factory$BaseFil2);
        return _createClass(NodeFilterFactory);
      }(_base_factory.BaseFilterFactory);
      exports.NodeFilterFactory = NodeFilterFactory;
      var NodeCanvasFactory = /*#__PURE__*/function (_base_factory$BaseCan2) {
        function NodeCanvasFactory() {
          _classCallCheck(this, NodeCanvasFactory);
          return _callSuper(this, NodeCanvasFactory, arguments);
        }
        _inherits(NodeCanvasFactory, _base_factory$BaseCan2);
        return _createClass(NodeCanvasFactory, [{
          key: "_createCanvas",
          value: function _createCanvas(width, height) {
            var Canvas = require("canvas");
            return Canvas.createCanvas(width, height);
          }
        }]);
      }(_base_factory.BaseCanvasFactory);
      exports.NodeCanvasFactory = NodeCanvasFactory;
      var NodeCMapReaderFactory = /*#__PURE__*/function (_base_factory$BaseCMa2) {
        function NodeCMapReaderFactory() {
          _classCallCheck(this, NodeCMapReaderFactory);
          return _callSuper(this, NodeCMapReaderFactory, arguments);
        }
        _inherits(NodeCMapReaderFactory, _base_factory$BaseCMa2);
        return _createClass(NodeCMapReaderFactory, [{
          key: "_fetchData",
          value: function _fetchData(url, compressionType) {
            return fetchData(url).then(function (data) {
              return {
                cMapData: data,
                compressionType: compressionType
              };
            });
          }
        }]);
      }(_base_factory.BaseCMapReaderFactory);
      exports.NodeCMapReaderFactory = NodeCMapReaderFactory;
      var NodeStandardFontDataFactory = /*#__PURE__*/function (_base_factory$BaseSta2) {
        function NodeStandardFontDataFactory() {
          _classCallCheck(this, NodeStandardFontDataFactory);
          return _callSuper(this, NodeStandardFontDataFactory, arguments);
        }
        _inherits(NodeStandardFontDataFactory, _base_factory$BaseSta2);
        return _createClass(NodeStandardFontDataFactory, [{
          key: "_fetchData",
          value: function _fetchData(url) {
            return fetchData(url);
          }
        }]);
      }(_base_factory.BaseStandardFontDataFactory);
      exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

      /***/
    }), (/* 11 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CanvasGraphics = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      var _pattern_helper = __w_pdfjs_require__(12);
      var _image_utils = __w_pdfjs_require__(13);
      var MIN_FONT_SIZE = 16;
      var MAX_FONT_SIZE = 100;
      var MAX_GROUP_SIZE = 4096;
      var EXECUTION_TIME = 15;
      var EXECUTION_STEPS = 10;
      var MAX_SIZE_TO_COMPILE = 1000;
      var FULL_CHUNK_HEIGHT = 16;
      function mirrorContextOperations(ctx, destCtx) {
        if (ctx._removeMirroring) {
          throw new Error("Context is already forwarding operations.");
        }
        ctx.__originalSave = ctx.save;
        ctx.__originalRestore = ctx.restore;
        ctx.__originalRotate = ctx.rotate;
        ctx.__originalScale = ctx.scale;
        ctx.__originalTranslate = ctx.translate;
        ctx.__originalTransform = ctx.transform;
        ctx.__originalSetTransform = ctx.setTransform;
        ctx.__originalResetTransform = ctx.resetTransform;
        ctx.__originalClip = ctx.clip;
        ctx.__originalMoveTo = ctx.moveTo;
        ctx.__originalLineTo = ctx.lineTo;
        ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
        ctx.__originalRect = ctx.rect;
        ctx.__originalClosePath = ctx.closePath;
        ctx.__originalBeginPath = ctx.beginPath;
        ctx._removeMirroring = function () {
          ctx.save = ctx.__originalSave;
          ctx.restore = ctx.__originalRestore;
          ctx.rotate = ctx.__originalRotate;
          ctx.scale = ctx.__originalScale;
          ctx.translate = ctx.__originalTranslate;
          ctx.transform = ctx.__originalTransform;
          ctx.setTransform = ctx.__originalSetTransform;
          ctx.resetTransform = ctx.__originalResetTransform;
          ctx.clip = ctx.__originalClip;
          ctx.moveTo = ctx.__originalMoveTo;
          ctx.lineTo = ctx.__originalLineTo;
          ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
          ctx.rect = ctx.__originalRect;
          ctx.closePath = ctx.__originalClosePath;
          ctx.beginPath = ctx.__originalBeginPath;
          delete ctx._removeMirroring;
        };
        ctx.save = function ctxSave() {
          destCtx.save();
          this.__originalSave();
        };
        ctx.restore = function ctxRestore() {
          destCtx.restore();
          this.__originalRestore();
        };
        ctx.translate = function ctxTranslate(x, y) {
          destCtx.translate(x, y);
          this.__originalTranslate(x, y);
        };
        ctx.scale = function ctxScale(x, y) {
          destCtx.scale(x, y);
          this.__originalScale(x, y);
        };
        ctx.transform = function ctxTransform(a, b, c, d, e, f) {
          destCtx.transform(a, b, c, d, e, f);
          this.__originalTransform(a, b, c, d, e, f);
        };
        ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
          destCtx.setTransform(a, b, c, d, e, f);
          this.__originalSetTransform(a, b, c, d, e, f);
        };
        ctx.resetTransform = function ctxResetTransform() {
          destCtx.resetTransform();
          this.__originalResetTransform();
        };
        ctx.rotate = function ctxRotate(angle) {
          destCtx.rotate(angle);
          this.__originalRotate(angle);
        };
        ctx.clip = function ctxRotate(rule) {
          destCtx.clip(rule);
          this.__originalClip(rule);
        };
        ctx.moveTo = function (x, y) {
          destCtx.moveTo(x, y);
          this.__originalMoveTo(x, y);
        };
        ctx.lineTo = function (x, y) {
          destCtx.lineTo(x, y);
          this.__originalLineTo(x, y);
        };
        ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
          destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
          this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        };
        ctx.rect = function (x, y, width, height) {
          destCtx.rect(x, y, width, height);
          this.__originalRect(x, y, width, height);
        };
        ctx.closePath = function () {
          destCtx.closePath();
          this.__originalClosePath();
        };
        ctx.beginPath = function () {
          destCtx.beginPath();
          this.__originalBeginPath();
        };
      }
      var CachedCanvases = /*#__PURE__*/function () {
        function CachedCanvases(canvasFactory) {
          _classCallCheck(this, CachedCanvases);
          this.canvasFactory = canvasFactory;
          this.cache = Object.create(null);
        }
        return _createClass(CachedCanvases, [{
          key: "getCanvas",
          value: function getCanvas(id, width, height) {
            var canvasEntry;
            if (this.cache[id] !== undefined) {
              canvasEntry = this.cache[id];
              this.canvasFactory.reset(canvasEntry, width, height);
            } else {
              canvasEntry = this.canvasFactory.create(width, height);
              this.cache[id] = canvasEntry;
            }
            return canvasEntry;
          }
        }, {
          key: "delete",
          value: function _delete(id) {
            delete this.cache[id];
          }
        }, {
          key: "clear",
          value: function clear() {
            for (var id in this.cache) {
              var canvasEntry = this.cache[id];
              this.canvasFactory.destroy(canvasEntry);
              delete this.cache[id];
            }
          }
        }]);
      }();
      function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
        var _ref48 = (0, _display_utils.getCurrentTransform)(ctx),
          _ref49 = _slicedToArray(_ref48, 6),
          a = _ref49[0],
          b = _ref49[1],
          c = _ref49[2],
          d = _ref49[3],
          tx = _ref49[4],
          ty = _ref49[5];
        if (b === 0 && c === 0) {
          var tlX = destX * a + tx;
          var rTlX = Math.round(tlX);
          var tlY = destY * d + ty;
          var rTlY = Math.round(tlY);
          var brX = (destX + destW) * a + tx;
          var rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
          var brY = (destY + destH) * d + ty;
          var rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
          ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
          ctx.setTransform(a, b, c, d, tx, ty);
          return [rWidth, rHeight];
        }
        if (a === 0 && d === 0) {
          var _tlX = destY * c + tx;
          var _rTlX = Math.round(_tlX);
          var _tlY = destX * b + ty;
          var _rTlY = Math.round(_tlY);
          var _brX = (destY + destH) * c + tx;
          var _rWidth = Math.abs(Math.round(_brX) - _rTlX) || 1;
          var _brY = (destX + destW) * b + ty;
          var _rHeight = Math.abs(Math.round(_brY) - _rTlY) || 1;
          ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, _rTlX, _rTlY);
          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, _rHeight, _rWidth);
          ctx.setTransform(a, b, c, d, tx, ty);
          return [_rHeight, _rWidth];
        }
        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
        var scaleX = Math.hypot(a, b);
        var scaleY = Math.hypot(c, d);
        return [scaleX * destW, scaleY * destH];
      }
      function compileType3Glyph(imgData) {
        var width = imgData.width,
          height = imgData.height;
        if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
          return null;
        }
        var POINT_TO_PROCESS_LIMIT = 1000;
        var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
        var width1 = width + 1;
        var points = new Uint8Array(width1 * (height + 1));
        var i, j, j0;
        var lineSize = width + 7 & ~7;
        var data = new Uint8Array(lineSize * height),
          pos = 0;
        var _iterator61 = _createForOfIteratorHelper(imgData.data),
          _step61;
        try {
          for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
            var elem = _step61.value;
            var mask = 128;
            while (mask > 0) {
              data[pos++] = elem & mask ? 0 : 255;
              mask >>= 1;
            }
          }
        } catch (err) {
          _iterator61.e(err);
        } finally {
          _iterator61.f();
        }
        var count = 0;
        pos = 0;
        if (data[pos] !== 0) {
          points[0] = 1;
          ++count;
        }
        for (j = 1; j < width; j++) {
          if (data[pos] !== data[pos + 1]) {
            points[j] = data[pos] ? 2 : 1;
            ++count;
          }
          pos++;
        }
        if (data[pos] !== 0) {
          points[j] = 2;
          ++count;
        }
        for (i = 1; i < height; i++) {
          pos = i * lineSize;
          j0 = i * width1;
          if (data[pos - lineSize] !== data[pos]) {
            points[j0] = data[pos] ? 1 : 8;
            ++count;
          }
          var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
          for (j = 1; j < width; j++) {
            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
            if (POINT_TYPES[sum]) {
              points[j0 + j] = POINT_TYPES[sum];
              ++count;
            }
            pos++;
          }
          if (data[pos - lineSize] !== data[pos]) {
            points[j0 + j] = data[pos] ? 2 : 4;
            ++count;
          }
          if (count > POINT_TO_PROCESS_LIMIT) {
            return null;
          }
        }
        pos = lineSize * (height - 1);
        j0 = i * width1;
        if (data[pos] !== 0) {
          points[j0] = 8;
          ++count;
        }
        for (j = 1; j < width; j++) {
          if (data[pos] !== data[pos + 1]) {
            points[j0 + j] = data[pos] ? 4 : 8;
            ++count;
          }
          pos++;
        }
        if (data[pos] !== 0) {
          points[j0 + j] = 4;
          ++count;
        }
        if (count > POINT_TO_PROCESS_LIMIT) {
          return null;
        }
        var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
        var path = new Path2D();
        for (i = 0; count && i <= height; i++) {
          var p = i * width1;
          var end = p + width;
          while (p < end && !points[p]) {
            p++;
          }
          if (p === end) {
            continue;
          }
          path.moveTo(p % width1, i);
          var p0 = p;
          var type = points[p];
          do {
            var step = steps[type];
            do {
              p += step;
            } while (!points[p]);
            var pp = points[p];
            if (pp !== 5 && pp !== 10) {
              type = pp;
              points[p] = 0;
            } else {
              type = pp & 0x33 * type >> 4;
              points[p] &= type >> 2 | type << 2;
            }
            path.lineTo(p % width1, p / width1 | 0);
            if (!points[p]) {
              --count;
            }
          } while (p0 !== p);
          --i;
        }
        data = null;
        points = null;
        var drawOutline = function drawOutline(c) {
          c.save();
          c.scale(1 / width, -1 / height);
          c.translate(0, -height);
          c.fill(path);
          c.beginPath();
          c.restore();
        };
        return drawOutline;
      }
      var CanvasExtraState = /*#__PURE__*/function () {
        function CanvasExtraState(width, height) {
          _classCallCheck(this, CanvasExtraState);
          this.alphaIsShape = false;
          this.fontSize = 0;
          this.fontSizeScale = 1;
          this.textMatrix = _util.IDENTITY_MATRIX;
          this.textMatrixScale = 1;
          this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
          this.leading = 0;
          this.x = 0;
          this.y = 0;
          this.lineX = 0;
          this.lineY = 0;
          this.charSpacing = 0;
          this.wordSpacing = 0;
          this.textHScale = 1;
          this.textRenderingMode = _util.TextRenderingMode.FILL;
          this.textRise = 0;
          this.fillColor = "#000000";
          this.strokeColor = "#000000";
          this.patternFill = false;
          this.fillAlpha = 1;
          this.strokeAlpha = 1;
          this.lineWidth = 1;
          this.activeSMask = null;
          this.transferMaps = "none";
          this.startNewPathAndClipBox([0, 0, width, height]);
        }
        return _createClass(CanvasExtraState, [{
          key: "clone",
          value: function clone() {
            var clone = Object.create(this);
            clone.clipBox = this.clipBox.slice();
            return clone;
          }
        }, {
          key: "setCurrentPoint",
          value: function setCurrentPoint(x, y) {
            this.x = x;
            this.y = y;
          }
        }, {
          key: "updatePathMinMax",
          value: function updatePathMinMax(transform, x, y) {
            var _util$Util$applyTrans = _util.Util.applyTransform([x, y], transform);
            var _util$Util$applyTrans2 = _slicedToArray(_util$Util$applyTrans, 2);
            x = _util$Util$applyTrans2[0];
            y = _util$Util$applyTrans2[1];
            this.minX = Math.min(this.minX, x);
            this.minY = Math.min(this.minY, y);
            this.maxX = Math.max(this.maxX, x);
            this.maxY = Math.max(this.maxY, y);
          }
        }, {
          key: "updateRectMinMax",
          value: function updateRectMinMax(transform, rect) {
            var p1 = _util.Util.applyTransform(rect, transform);
            var p2 = _util.Util.applyTransform(rect.slice(2), transform);
            this.minX = Math.min(this.minX, p1[0], p2[0]);
            this.minY = Math.min(this.minY, p1[1], p2[1]);
            this.maxX = Math.max(this.maxX, p1[0], p2[0]);
            this.maxY = Math.max(this.maxY, p1[1], p2[1]);
          }
        }, {
          key: "updateScalingPathMinMax",
          value: function updateScalingPathMinMax(transform, minMax) {
            _util.Util.scaleMinMax(transform, minMax);
            this.minX = Math.min(this.minX, minMax[0]);
            this.maxX = Math.max(this.maxX, minMax[1]);
            this.minY = Math.min(this.minY, minMax[2]);
            this.maxY = Math.max(this.maxY, minMax[3]);
          }
        }, {
          key: "updateCurvePathMinMax",
          value: function updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
            var box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
            if (minMax) {
              minMax[0] = Math.min(minMax[0], box[0], box[2]);
              minMax[1] = Math.max(minMax[1], box[0], box[2]);
              minMax[2] = Math.min(minMax[2], box[1], box[3]);
              minMax[3] = Math.max(minMax[3], box[1], box[3]);
              return;
            }
            this.updateRectMinMax(transform, box);
          }
        }, {
          key: "getPathBoundingBox",
          value: function getPathBoundingBox() {
            var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
            var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var box = [this.minX, this.minY, this.maxX, this.maxY];
            if (pathType === _pattern_helper.PathType.STROKE) {
              if (!transform) {
                (0, _util.unreachable)("Stroke bounding box must include transform.");
              }
              var scale = _util.Util.singularValueDecompose2dScale(transform);
              var xStrokePad = scale[0] * this.lineWidth / 2;
              var yStrokePad = scale[1] * this.lineWidth / 2;
              box[0] -= xStrokePad;
              box[1] -= yStrokePad;
              box[2] += xStrokePad;
              box[3] += yStrokePad;
            }
            return box;
          }
        }, {
          key: "updateClipFromPath",
          value: function updateClipFromPath() {
            var intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());
            this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
          }
        }, {
          key: "isEmptyClip",
          value: function isEmptyClip() {
            return this.minX === Infinity;
          }
        }, {
          key: "startNewPathAndClipBox",
          value: function startNewPathAndClipBox(box) {
            this.clipBox = box;
            this.minX = Infinity;
            this.minY = Infinity;
            this.maxX = 0;
            this.maxY = 0;
          }
        }, {
          key: "getClippedPathBoundingBox",
          value: function getClippedPathBoundingBox() {
            var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
            var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
          }
        }]);
      }();
      function putBinaryImageData(ctx, imgData) {
        if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
          ctx.putImageData(imgData, 0, 0);
          return;
        }
        var height = imgData.height,
          width = imgData.width;
        var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
        var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
        var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
        var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
        var srcPos = 0,
          destPos;
        var src = imgData.data;
        var dest = chunkImgData.data;
        var i, j, thisChunkHeight, elemsInThisChunk;
        if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
          var srcLength = src.byteLength;
          var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
          var dest32DataLength = dest32.length;
          var fullSrcDiff = width + 7 >> 3;
          var white = 0xffffffff;
          var black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
          for (i = 0; i < totalChunks; i++) {
            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
            destPos = 0;
            for (j = 0; j < thisChunkHeight; j++) {
              var srcDiff = srcLength - srcPos;
              var k = 0;
              var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
              var kEndUnrolled = kEnd & ~7;
              var mask = 0;
              var srcByte = 0;
              for (; k < kEndUnrolled; k += 8) {
                srcByte = src[srcPos++];
                dest32[destPos++] = srcByte & 128 ? white : black;
                dest32[destPos++] = srcByte & 64 ? white : black;
                dest32[destPos++] = srcByte & 32 ? white : black;
                dest32[destPos++] = srcByte & 16 ? white : black;
                dest32[destPos++] = srcByte & 8 ? white : black;
                dest32[destPos++] = srcByte & 4 ? white : black;
                dest32[destPos++] = srcByte & 2 ? white : black;
                dest32[destPos++] = srcByte & 1 ? white : black;
              }
              for (; k < kEnd; k++) {
                if (mask === 0) {
                  srcByte = src[srcPos++];
                  mask = 128;
                }
                dest32[destPos++] = srcByte & mask ? white : black;
                mask >>= 1;
              }
            }
            while (destPos < dest32DataLength) {
              dest32[destPos++] = 0;
            }
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
          j = 0;
          elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
          for (i = 0; i < fullChunks; i++) {
            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
            srcPos += elemsInThisChunk;
            ctx.putImageData(chunkImgData, 0, j);
            j += FULL_CHUNK_HEIGHT;
          }
          if (i < totalChunks) {
            elemsInThisChunk = width * partialChunkHeight * 4;
            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
            ctx.putImageData(chunkImgData, 0, j);
          }
        } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
          thisChunkHeight = FULL_CHUNK_HEIGHT;
          elemsInThisChunk = width * thisChunkHeight;
          for (i = 0; i < totalChunks; i++) {
            if (i >= fullChunks) {
              thisChunkHeight = partialChunkHeight;
              elemsInThisChunk = width * thisChunkHeight;
            }
            destPos = 0;
            for (j = elemsInThisChunk; j--;) {
              dest[destPos++] = src[srcPos++];
              dest[destPos++] = src[srcPos++];
              dest[destPos++] = src[srcPos++];
              dest[destPos++] = 255;
            }
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        } else {
          throw new Error("bad image kind: ".concat(imgData.kind));
        }
      }
      function putBinaryImageMask(ctx, imgData) {
        if (imgData.bitmap) {
          ctx.drawImage(imgData.bitmap, 0, 0);
          return;
        }
        var height = imgData.height,
          width = imgData.width;
        var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
        var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
        var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
        var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
        var srcPos = 0;
        var src = imgData.data;
        var dest = chunkImgData.data;
        for (var i = 0; i < totalChunks; i++) {
          var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
          var _ref50 = (0, _image_utils.convertBlackAndWhiteToRGBA)({
            src: src,
            srcPos: srcPos,
            dest: dest,
            width: width,
            height: thisChunkHeight,
            nonBlackColor: 0
          });
          srcPos = _ref50.srcPos;
          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
        }
      }
      function copyCtxState(sourceCtx, destCtx) {
        var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
        for (var _i11 = 0, _properties = properties; _i11 < _properties.length; _i11++) {
          var property = _properties[_i11];
          if (sourceCtx[property] !== undefined) {
            destCtx[property] = sourceCtx[property];
          }
        }
        if (sourceCtx.setLineDash !== undefined) {
          destCtx.setLineDash(sourceCtx.getLineDash());
          destCtx.lineDashOffset = sourceCtx.lineDashOffset;
        }
      }
      function resetCtxToDefault(ctx) {
        ctx.strokeStyle = ctx.fillStyle = "#000000";
        ctx.fillRule = "nonzero";
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 10;
        ctx.globalCompositeOperation = "source-over";
        ctx.font = "10px sans-serif";
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([]);
          ctx.lineDashOffset = 0;
        }
        if (!_util.isNodeJS) {
          var filter = ctx.filter;
          if (filter !== "none" && filter !== "") {
            ctx.filter = "none";
          }
        }
      }
      function composeSMaskBackdrop(bytes, r0, g0, b0) {
        var length = bytes.length;
        for (var i = 3; i < length; i += 4) {
          var alpha = bytes[i];
          if (alpha === 0) {
            bytes[i - 3] = r0;
            bytes[i - 2] = g0;
            bytes[i - 1] = b0;
          } else if (alpha < 255) {
            var alpha_ = 255 - alpha;
            bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
            bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
            bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
          }
        }
      }
      function composeSMaskAlpha(maskData, layerData, transferMap) {
        var length = maskData.length;
        var scale = 1 / 255;
        for (var i = 3; i < length; i += 4) {
          var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
          layerData[i] = layerData[i] * alpha * scale | 0;
        }
      }
      function composeSMaskLuminosity(maskData, layerData, transferMap) {
        var length = maskData.length;
        for (var i = 3; i < length; i += 4) {
          var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
          layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
        }
      }
      function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
        var hasBackdrop = !!backdrop;
        var r0 = hasBackdrop ? backdrop[0] : 0;
        var g0 = hasBackdrop ? backdrop[1] : 0;
        var b0 = hasBackdrop ? backdrop[2] : 0;
        var composeFn = subtype === "Luminosity" ? composeSMaskLuminosity : composeSMaskAlpha;
        var PIXELS_TO_PROCESS = 1048576;
        var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
        for (var row = 0; row < height; row += chunkSize) {
          var chunkHeight = Math.min(chunkSize, height - row);
          var maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
          var layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
          if (hasBackdrop) {
            composeSMaskBackdrop(maskData.data, r0, g0, b0);
          }
          composeFn(maskData.data, layerData.data, transferMap);
          layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
        }
      }
      function composeSMask(ctx, smask, layerCtx, layerBox) {
        var layerOffsetX = layerBox[0];
        var layerOffsetY = layerBox[1];
        var layerWidth = layerBox[2] - layerOffsetX;
        var layerHeight = layerBox[3] - layerOffsetY;
        if (layerWidth === 0 || layerHeight === 0) {
          return;
        }
        genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(layerCtx.canvas, 0, 0);
        ctx.restore();
      }
      function getImageSmoothingEnabled(transform, interpolate) {
        var scale = _util.Util.singularValueDecompose2dScale(transform);
        scale[0] = Math.fround(scale[0]);
        scale[1] = Math.fround(scale[1]);
        var actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
        if (interpolate !== undefined) {
          return interpolate;
        } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
          return true;
        }
        return false;
      }
      var LINE_CAP_STYLES = ["butt", "round", "square"];
      var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
      var NORMAL_CLIP = {};
      var EO_CLIP = {};
      var _CanvasGraphics_brand = /*#__PURE__*/new WeakSet();
      var CanvasGraphics = /*#__PURE__*/function () {
        function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, _ref51, annotationCanvasMap, pageColors) {
          var optionalContentConfig = _ref51.optionalContentConfig,
            _ref51$markedContentS = _ref51.markedContentStack,
            markedContentStack = _ref51$markedContentS === void 0 ? null : _ref51$markedContentS;
          _classCallCheck(this, CanvasGraphics);
          _classPrivateMethodInitSpec(this, _CanvasGraphics_brand);
          this.ctx = canvasCtx;
          this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
          this.stateStack = [];
          this.pendingClip = null;
          this.pendingEOFill = false;
          this.res = null;
          this.xobjs = null;
          this.commonObjs = commonObjs;
          this.objs = objs;
          this.canvasFactory = canvasFactory;
          this.filterFactory = filterFactory;
          this.groupStack = [];
          this.processingType3 = null;
          this.baseTransform = null;
          this.baseTransformStack = [];
          this.groupLevel = 0;
          this.smaskStack = [];
          this.smaskCounter = 0;
          this.tempSMask = null;
          this.suspendedCtx = null;
          this.contentVisible = true;
          this.markedContentStack = markedContentStack || [];
          this.optionalContentConfig = optionalContentConfig;
          this.cachedCanvases = new CachedCanvases(this.canvasFactory);
          this.cachedPatterns = new Map();
          this.annotationCanvasMap = annotationCanvasMap;
          this.viewportScale = 1;
          this.outputScaleX = 1;
          this.outputScaleY = 1;
          this.pageColors = pageColors;
          this._cachedScaleForStroking = [-1, 0];
          this._cachedGetSinglePixelWidth = null;
          this._cachedBitmapsMap = new Map();
        }
        return _createClass(CanvasGraphics, [{
          key: "getObject",
          value: function getObject(data) {
            var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (typeof data === "string") {
              return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
            }
            return fallback;
          }
        }, {
          key: "beginDrawing",
          value: function beginDrawing(_ref52) {
            var _this$ctx3;
            var transform = _ref52.transform,
              viewport = _ref52.viewport,
              _ref52$transparency = _ref52.transparency,
              transparency = _ref52$transparency === void 0 ? false : _ref52$transparency,
              _ref52$background = _ref52.background,
              background = _ref52$background === void 0 ? null : _ref52$background;
            var width = this.ctx.canvas.width;
            var height = this.ctx.canvas.height;
            var savedFillStyle = this.ctx.fillStyle;
            this.ctx.fillStyle = background || "#ffffff";
            this.ctx.fillRect(0, 0, width, height);
            this.ctx.fillStyle = savedFillStyle;
            if (transparency) {
              var _this$ctx;
              var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
              this.compositeCtx = this.ctx;
              this.transparentCanvas = transparentCanvas.canvas;
              this.ctx = transparentCanvas.context;
              this.ctx.save();
              (_this$ctx = this.ctx).transform.apply(_this$ctx, _toConsumableArray((0, _display_utils.getCurrentTransform)(this.compositeCtx)));
            }
            this.ctx.save();
            resetCtxToDefault(this.ctx);
            if (transform) {
              var _this$ctx2;
              (_this$ctx2 = this.ctx).transform.apply(_this$ctx2, _toConsumableArray(transform));
              this.outputScaleX = transform[0];
              this.outputScaleY = transform[0];
            }
            (_this$ctx3 = this.ctx).transform.apply(_this$ctx3, _toConsumableArray(viewport.transform));
            this.viewportScale = viewport.scale;
            this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);
          }
        }, {
          key: "executeOperatorList",
          value: function executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
            var argsArray = operatorList.argsArray;
            var fnArray = operatorList.fnArray;
            var i = executionStartIdx || 0;
            var argsArrayLen = argsArray.length;
            if (argsArrayLen === i) {
              return i;
            }
            var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
            var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
            var steps = 0;
            var commonObjs = this.commonObjs;
            var objs = this.objs;
            var fnId;
            while (true) {
              if (stepper !== undefined && i === stepper.nextBreakPoint) {
                stepper.breakIt(i, continueCallback);
                return i;
              }
              fnId = fnArray[i];
              if (fnId !== _util.OPS.dependency) {
                this[fnId].apply(this, argsArray[i]);
              } else {
                var _iterator62 = _createForOfIteratorHelper(argsArray[i]),
                  _step62;
                try {
                  for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
                    var depObjId = _step62.value;
                    var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                    if (!objsPool.has(depObjId)) {
                      objsPool.get(depObjId, continueCallback);
                      return i;
                    }
                  }
                } catch (err) {
                  _iterator62.e(err);
                } finally {
                  _iterator62.f();
                }
              }
              i++;
              if (i === argsArrayLen) {
                return i;
              }
              if (chunkOperations && ++steps > EXECUTION_STEPS) {
                if (Date.now() > endTime) {
                  continueCallback();
                  return i;
                }
                steps = 0;
              }
            }
          }
        }, {
          key: "endDrawing",
          value: function endDrawing() {
            _assertClassBrand(_CanvasGraphics_brand, this, _restoreInitialState).call(this);
            this.cachedCanvases.clear();
            this.cachedPatterns.clear();
            var _iterator63 = _createForOfIteratorHelper(this._cachedBitmapsMap.values()),
              _step63;
            try {
              for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
                var cache = _step63.value;
                var _iterator64 = _createForOfIteratorHelper(cache.values()),
                  _step64;
                try {
                  for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {
                    var canvas = _step64.value;
                    if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                      canvas.width = canvas.height = 0;
                    }
                  }
                } catch (err) {
                  _iterator64.e(err);
                } finally {
                  _iterator64.f();
                }
                cache.clear();
              }
            } catch (err) {
              _iterator63.e(err);
            } finally {
              _iterator63.f();
            }
            this._cachedBitmapsMap.clear();
            _assertClassBrand(_CanvasGraphics_brand, this, _drawFilter).call(this);
          }
        }, {
          key: "_scaleImage",
          value: function _scaleImage(img, inverseTransform) {
            var width = img.width;
            var height = img.height;
            var widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
            var heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
            var paintWidth = width,
              paintHeight = height;
            var tmpCanvasId = "prescale1";
            var tmpCanvas, tmpCtx;
            while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
              var newWidth = paintWidth,
                newHeight = paintHeight;
              if (widthScale > 2 && paintWidth > 1) {
                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
                widthScale /= paintWidth / newWidth;
              }
              if (heightScale > 2 && paintHeight > 1) {
                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
                heightScale /= paintHeight / newHeight;
              }
              tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
              tmpCtx = tmpCanvas.context;
              tmpCtx.clearRect(0, 0, newWidth, newHeight);
              tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
              img = tmpCanvas.canvas;
              paintWidth = newWidth;
              paintHeight = newHeight;
              tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
            }
            return {
              img: img,
              paintWidth: paintWidth,
              paintHeight: paintHeight
            };
          }
        }, {
          key: "_createMaskCanvas",
          value: function _createMaskCanvas(img) {
            var ctx = this.ctx;
            var width = img.width,
              height = img.height;
            var fillColor = this.current.fillColor;
            var isPatternFill = this.current.patternFill;
            var currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
            var cache, cacheKey, scaled, maskCanvas;
            if ((img.bitmap || img.data) && img.count > 1) {
              var mainKey = img.bitmap || img.data.buffer;
              cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
              cache = this._cachedBitmapsMap.get(mainKey);
              if (!cache) {
                cache = new Map();
                this._cachedBitmapsMap.set(mainKey, cache);
              }
              var cachedImage = cache.get(cacheKey);
              if (cachedImage && !isPatternFill) {
                var _offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                var _offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                return {
                  canvas: cachedImage,
                  offsetX: _offsetX,
                  offsetY: _offsetY
                };
              }
              scaled = cachedImage;
            }
            if (!scaled) {
              maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
              putBinaryImageMask(maskCanvas.context, img);
            }
            var maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
            maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
            var cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);
            var cord2 = _util.Util.applyTransform([width, height], maskToCanvas);
            var rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
            var drawnWidth = Math.round(rect[2] - rect[0]) || 1;
            var drawnHeight = Math.round(rect[3] - rect[1]) || 1;
            var fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
            var fillCtx = fillCanvas.context;
            var offsetX = Math.min(cord1[0], cord2[0]);
            var offsetY = Math.min(cord1[1], cord2[1]);
            fillCtx.translate(-offsetX, -offsetY);
            fillCtx.transform.apply(fillCtx, _toConsumableArray(maskToCanvas));
            if (!scaled) {
              scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));
              scaled = scaled.img;
              if (cache && isPatternFill) {
                cache.set(cacheKey, scaled);
              }
            }
            fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);
            drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
            fillCtx.globalCompositeOperation = "source-in";
            var inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
            fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
            fillCtx.fillRect(0, 0, width, height);
            if (cache && !isPatternFill) {
              this.cachedCanvases.delete("fillCanvas");
              cache.set(cacheKey, fillCanvas.canvas);
            }
            return {
              canvas: fillCanvas.canvas,
              offsetX: Math.round(offsetX),
              offsetY: Math.round(offsetY)
            };
          }
        }, {
          key: "setLineWidth",
          value: function setLineWidth(width) {
            if (width !== this.current.lineWidth) {
              this._cachedScaleForStroking[0] = -1;
            }
            this.current.lineWidth = width;
            this.ctx.lineWidth = width;
          }
        }, {
          key: "setLineCap",
          value: function setLineCap(style) {
            this.ctx.lineCap = LINE_CAP_STYLES[style];
          }
        }, {
          key: "setLineJoin",
          value: function setLineJoin(style) {
            this.ctx.lineJoin = LINE_JOIN_STYLES[style];
          }
        }, {
          key: "setMiterLimit",
          value: function setMiterLimit(limit) {
            this.ctx.miterLimit = limit;
          }
        }, {
          key: "setDash",
          value: function setDash(dashArray, dashPhase) {
            var ctx = this.ctx;
            if (ctx.setLineDash !== undefined) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashPhase;
            }
          }
        }, {
          key: "setRenderingIntent",
          value: function setRenderingIntent(intent) {}
        }, {
          key: "setFlatness",
          value: function setFlatness(flatness) {}
        }, {
          key: "setGState",
          value: function setGState(states) {
            var _iterator65 = _createForOfIteratorHelper(states),
              _step65;
            try {
              for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
                var _step65$value = _slicedToArray(_step65.value, 2),
                  key = _step65$value[0],
                  value = _step65$value[1];
                switch (key) {
                  case "LW":
                    this.setLineWidth(value);
                    break;
                  case "LC":
                    this.setLineCap(value);
                    break;
                  case "LJ":
                    this.setLineJoin(value);
                    break;
                  case "ML":
                    this.setMiterLimit(value);
                    break;
                  case "D":
                    this.setDash(value[0], value[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(value);
                    break;
                  case "FL":
                    this.setFlatness(value);
                    break;
                  case "Font":
                    this.setFont(value[0], value[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = value;
                    break;
                  case "ca":
                    this.current.fillAlpha = value;
                    this.ctx.globalAlpha = value;
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = value;
                    break;
                  case "SMask":
                    this.current.activeSMask = value ? this.tempSMask : null;
                    this.tempSMask = null;
                    this.checkSMaskState();
                    break;
                  case "TR":
                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
                    break;
                }
              }
            } catch (err) {
              _iterator65.e(err);
            } finally {
              _iterator65.f();
            }
          }
        }, {
          key: "inSMaskMode",
          get: function get() {
            return !!this.suspendedCtx;
          }
        }, {
          key: "checkSMaskState",
          value: function checkSMaskState() {
            var inSMaskMode = this.inSMaskMode;
            if (this.current.activeSMask && !inSMaskMode) {
              this.beginSMaskMode();
            } else if (!this.current.activeSMask && inSMaskMode) {
              this.endSMaskMode();
            }
          }
        }, {
          key: "beginSMaskMode",
          value: function beginSMaskMode() {
            if (this.inSMaskMode) {
              throw new Error("beginSMaskMode called while already in smask mode");
            }
            var drawnWidth = this.ctx.canvas.width;
            var drawnHeight = this.ctx.canvas.height;
            var cacheId = "smaskGroupAt" + this.groupLevel;
            var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
            this.suspendedCtx = this.ctx;
            this.ctx = scratchCanvas.context;
            var ctx = this.ctx;
            ctx.setTransform.apply(ctx, _toConsumableArray((0, _display_utils.getCurrentTransform)(this.suspendedCtx)));
            copyCtxState(this.suspendedCtx, ctx);
            mirrorContextOperations(ctx, this.suspendedCtx);
            this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
          }
        }, {
          key: "endSMaskMode",
          value: function endSMaskMode() {
            if (!this.inSMaskMode) {
              throw new Error("endSMaskMode called while not in smask mode");
            }
            this.ctx._removeMirroring();
            copyCtxState(this.ctx, this.suspendedCtx);
            this.ctx = this.suspendedCtx;
            this.suspendedCtx = null;
          }
        }, {
          key: "compose",
          value: function compose(dirtyBox) {
            if (!this.current.activeSMask) {
              return;
            }
            if (!dirtyBox) {
              dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
            } else {
              dirtyBox[0] = Math.floor(dirtyBox[0]);
              dirtyBox[1] = Math.floor(dirtyBox[1]);
              dirtyBox[2] = Math.ceil(dirtyBox[2]);
              dirtyBox[3] = Math.ceil(dirtyBox[3]);
            }
            var smask = this.current.activeSMask;
            var suspendedCtx = this.suspendedCtx;
            composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            this.ctx.restore();
          }
        }, {
          key: "save",
          value: function save() {
            if (this.inSMaskMode) {
              copyCtxState(this.ctx, this.suspendedCtx);
              this.suspendedCtx.save();
            } else {
              this.ctx.save();
            }
            var old = this.current;
            this.stateStack.push(old);
            this.current = old.clone();
          }
        }, {
          key: "restore",
          value: function restore() {
            if (this.stateStack.length === 0 && this.inSMaskMode) {
              this.endSMaskMode();
            }
            if (this.stateStack.length !== 0) {
              this.current = this.stateStack.pop();
              if (this.inSMaskMode) {
                this.suspendedCtx.restore();
                copyCtxState(this.suspendedCtx, this.ctx);
              } else {
                this.ctx.restore();
              }
              this.checkSMaskState();
              this.pendingClip = null;
              this._cachedScaleForStroking[0] = -1;
              this._cachedGetSinglePixelWidth = null;
            }
          }
        }, {
          key: "transform",
          value: function transform(a, b, c, d, e, f) {
            this.ctx.transform(a, b, c, d, e, f);
            this._cachedScaleForStroking[0] = -1;
            this._cachedGetSinglePixelWidth = null;
          }
        }, {
          key: "constructPath",
          value: function constructPath(ops, args, minMax) {
            var ctx = this.ctx;
            var current = this.current;
            var x = current.x,
              y = current.y;
            var startX, startY;
            var currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
            var isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
            var minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
            for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
              switch (ops[i] | 0) {
                case _util.OPS.rectangle:
                  x = args[j++];
                  y = args[j++];
                  var width = args[j++];
                  var height = args[j++];
                  var xw = x + width;
                  var yh = y + height;
                  ctx.moveTo(x, y);
                  if (width === 0 || height === 0) {
                    ctx.lineTo(xw, yh);
                  } else {
                    ctx.lineTo(xw, y);
                    ctx.lineTo(xw, yh);
                    ctx.lineTo(x, yh);
                  }
                  if (!isScalingMatrix) {
                    current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                  }
                  ctx.closePath();
                  break;
                case _util.OPS.moveTo:
                  x = args[j++];
                  y = args[j++];
                  ctx.moveTo(x, y);
                  if (!isScalingMatrix) {
                    current.updatePathMinMax(currentTransform, x, y);
                  }
                  break;
                case _util.OPS.lineTo:
                  x = args[j++];
                  y = args[j++];
                  ctx.lineTo(x, y);
                  if (!isScalingMatrix) {
                    current.updatePathMinMax(currentTransform, x, y);
                  }
                  break;
                case _util.OPS.curveTo:
                  startX = x;
                  startY = y;
                  x = args[j + 4];
                  y = args[j + 5];
                  ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                  current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                  j += 6;
                  break;
                case _util.OPS.curveTo2:
                  startX = x;
                  startY = y;
                  ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                  current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                  x = args[j + 2];
                  y = args[j + 3];
                  j += 4;
                  break;
                case _util.OPS.curveTo3:
                  startX = x;
                  startY = y;
                  x = args[j + 2];
                  y = args[j + 3];
                  ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                  current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                  j += 4;
                  break;
                case _util.OPS.closePath:
                  ctx.closePath();
                  break;
              }
            }
            if (isScalingMatrix) {
              current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
            }
            current.setCurrentPoint(x, y);
          }
        }, {
          key: "closePath",
          value: function closePath() {
            this.ctx.closePath();
          }
        }, {
          key: "stroke",
          value: function stroke() {
            var consumePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var ctx = this.ctx;
            var strokeColor = this.current.strokeColor;
            ctx.globalAlpha = this.current.strokeAlpha;
            if (this.contentVisible) {
              if (_typeof(strokeColor) === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
                ctx.save();
                ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                this.rescaleAndStroke(false);
                ctx.restore();
              } else {
                this.rescaleAndStroke(true);
              }
            }
            if (consumePath) {
              this.consumePath(this.current.getClippedPathBoundingBox());
            }
            ctx.globalAlpha = this.current.fillAlpha;
          }
        }, {
          key: "closeStroke",
          value: function closeStroke() {
            this.closePath();
            this.stroke();
          }
        }, {
          key: "fill",
          value: function fill() {
            var consumePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var ctx = this.ctx;
            var fillColor = this.current.fillColor;
            var isPatternFill = this.current.patternFill;
            var needRestore = false;
            if (isPatternFill) {
              ctx.save();
              ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
              needRestore = true;
            }
            var intersect = this.current.getClippedPathBoundingBox();
            if (this.contentVisible && intersect !== null) {
              if (this.pendingEOFill) {
                ctx.fill("evenodd");
                this.pendingEOFill = false;
              } else {
                ctx.fill();
              }
            }
            if (needRestore) {
              ctx.restore();
            }
            if (consumePath) {
              this.consumePath(intersect);
            }
          }
        }, {
          key: "eoFill",
          value: function eoFill() {
            this.pendingEOFill = true;
            this.fill();
          }
        }, {
          key: "fillStroke",
          value: function fillStroke() {
            this.fill(false);
            this.stroke(false);
            this.consumePath();
          }
        }, {
          key: "eoFillStroke",
          value: function eoFillStroke() {
            this.pendingEOFill = true;
            this.fillStroke();
          }
        }, {
          key: "closeFillStroke",
          value: function closeFillStroke() {
            this.closePath();
            this.fillStroke();
          }
        }, {
          key: "closeEOFillStroke",
          value: function closeEOFillStroke() {
            this.pendingEOFill = true;
            this.closePath();
            this.fillStroke();
          }
        }, {
          key: "endPath",
          value: function endPath() {
            this.consumePath();
          }
        }, {
          key: "clip",
          value: function clip() {
            this.pendingClip = NORMAL_CLIP;
          }
        }, {
          key: "eoClip",
          value: function eoClip() {
            this.pendingClip = EO_CLIP;
          }
        }, {
          key: "beginText",
          value: function beginText() {
            this.current.textMatrix = _util.IDENTITY_MATRIX;
            this.current.textMatrixScale = 1;
            this.current.x = this.current.lineX = 0;
            this.current.y = this.current.lineY = 0;
          }
        }, {
          key: "endText",
          value: function endText() {
            var paths = this.pendingTextPaths;
            var ctx = this.ctx;
            if (paths === undefined) {
              ctx.beginPath();
              return;
            }
            ctx.save();
            ctx.beginPath();
            var _iterator66 = _createForOfIteratorHelper(paths),
              _step66;
            try {
              for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
                var path = _step66.value;
                ctx.setTransform.apply(ctx, _toConsumableArray(path.transform));
                ctx.translate(path.x, path.y);
                path.addToPath(ctx, path.fontSize);
              }
            } catch (err) {
              _iterator66.e(err);
            } finally {
              _iterator66.f();
            }
            ctx.restore();
            ctx.clip();
            ctx.beginPath();
            delete this.pendingTextPaths;
          }
        }, {
          key: "setCharSpacing",
          value: function setCharSpacing(spacing) {
            this.current.charSpacing = spacing;
          }
        }, {
          key: "setWordSpacing",
          value: function setWordSpacing(spacing) {
            this.current.wordSpacing = spacing;
          }
        }, {
          key: "setHScale",
          value: function setHScale(scale) {
            this.current.textHScale = scale / 100;
          }
        }, {
          key: "setLeading",
          value: function setLeading(leading) {
            this.current.leading = -leading;
          }
        }, {
          key: "setFont",
          value: function setFont(fontRefName, size) {
            var _fontObj$systemFontIn;
            var fontObj = this.commonObjs.get(fontRefName);
            var current = this.current;
            if (!fontObj) {
              throw new Error("Can't find font for ".concat(fontRefName));
            }
            current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
            if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
              (0, _util.warn)("Invalid font matrix for font " + fontRefName);
            }
            if (size < 0) {
              size = -size;
              current.fontDirection = -1;
            } else {
              current.fontDirection = 1;
            }
            this.current.font = fontObj;
            this.current.fontSize = size;
            if (fontObj.isType3Font) {
              return;
            }
            var name = fontObj.loadedName || "sans-serif";
            var typeface = ((_fontObj$systemFontIn = fontObj.systemFontInfo) === null || _fontObj$systemFontIn === void 0 ? void 0 : _fontObj$systemFontIn.css) || "\"".concat(name, "\", ").concat(fontObj.fallbackName);
            var bold = "normal";
            if (fontObj.black) {
              bold = "900";
            } else if (fontObj.bold) {
              bold = "bold";
            }
            var italic = fontObj.italic ? "italic" : "normal";
            var browserFontSize = size;
            if (size < MIN_FONT_SIZE) {
              browserFontSize = MIN_FONT_SIZE;
            } else if (size > MAX_FONT_SIZE) {
              browserFontSize = MAX_FONT_SIZE;
            }
            this.current.fontSizeScale = size / browserFontSize;
            this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
          }
        }, {
          key: "setTextRenderingMode",
          value: function setTextRenderingMode(mode) {
            this.current.textRenderingMode = mode;
          }
        }, {
          key: "setTextRise",
          value: function setTextRise(rise) {
            this.current.textRise = rise;
          }
        }, {
          key: "moveText",
          value: function moveText(x, y) {
            this.current.x = this.current.lineX += x;
            this.current.y = this.current.lineY += y;
          }
        }, {
          key: "setLeadingMoveText",
          value: function setLeadingMoveText(x, y) {
            this.setLeading(-y);
            this.moveText(x, y);
          }
        }, {
          key: "setTextMatrix",
          value: function setTextMatrix(a, b, c, d, e, f) {
            this.current.textMatrix = [a, b, c, d, e, f];
            this.current.textMatrixScale = Math.hypot(a, b);
            this.current.x = this.current.lineX = 0;
            this.current.y = this.current.lineY = 0;
          }
        }, {
          key: "nextLine",
          value: function nextLine() {
            this.moveText(0, this.current.leading);
          }
        }, {
          key: "paintChar",
          value: function paintChar(character, x, y, patternTransform) {
            var ctx = this.ctx;
            var current = this.current;
            var font = current.font;
            var textRenderingMode = current.textRenderingMode;
            var fontSize = current.fontSize / current.fontSizeScale;
            var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
            var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
            var patternFill = current.patternFill && !font.missingFile;
            var addToPath;
            if (font.disableFontFace || isAddToPathSet || patternFill) {
              addToPath = font.getPathGenerator(this.commonObjs, character);
            }
            if (font.disableFontFace || patternFill) {
              ctx.save();
              ctx.translate(x, y);
              ctx.beginPath();
              addToPath(ctx, fontSize);
              if (patternTransform) {
                ctx.setTransform.apply(ctx, _toConsumableArray(patternTransform));
              }
              if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.fill();
              }
              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.stroke();
              }
              ctx.restore();
            } else {
              if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.fillText(character, x, y);
              }
              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.strokeText(character, x, y);
              }
            }
            if (isAddToPathSet) {
              var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
              paths.push({
                transform: (0, _display_utils.getCurrentTransform)(ctx),
                x: x,
                y: y,
                fontSize: fontSize,
                addToPath: addToPath
              });
            }
          }
        }, {
          key: "isFontSubpixelAAEnabled",
          get: function get() {
            var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10),
              ctx = _this$cachedCanvases$.context;
            ctx.scale(1.5, 1);
            ctx.fillText("I", 0, 10);
            var data = ctx.getImageData(0, 0, 10, 10).data;
            var enabled = false;
            for (var i = 3; i < data.length; i += 4) {
              if (data[i] > 0 && data[i] < 255) {
                enabled = true;
                break;
              }
            }
            return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
          }
        }, {
          key: "showText",
          value: function showText(glyphs) {
            var current = this.current;
            var font = current.font;
            if (font.isType3Font) {
              return this.showType3Text(glyphs);
            }
            var fontSize = current.fontSize;
            if (fontSize === 0) {
              return undefined;
            }
            var ctx = this.ctx;
            var fontSizeScale = current.fontSizeScale;
            var charSpacing = current.charSpacing;
            var wordSpacing = current.wordSpacing;
            var fontDirection = current.fontDirection;
            var textHScale = current.textHScale * fontDirection;
            var glyphsLength = glyphs.length;
            var vertical = font.vertical;
            var spacingDir = vertical ? 1 : -1;
            var defaultVMetrics = font.defaultVMetrics;
            var widthAdvanceScale = fontSize * current.fontMatrix[0];
            var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
            ctx.save();
            ctx.transform.apply(ctx, _toConsumableArray(current.textMatrix));
            ctx.translate(current.x, current.y + current.textRise);
            if (fontDirection > 0) {
              ctx.scale(textHScale, -1);
            } else {
              ctx.scale(textHScale, 1);
            }
            var patternTransform;
            if (current.patternFill) {
              ctx.save();
              var pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
              patternTransform = (0, _display_utils.getCurrentTransform)(ctx);
              ctx.restore();
              ctx.fillStyle = pattern;
            }
            var lineWidth = current.lineWidth;
            var scale = current.textMatrixScale;
            if (scale === 0 || lineWidth === 0) {
              var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                lineWidth = this.getSinglePixelWidth();
              }
            } else {
              lineWidth /= scale;
            }
            if (fontSizeScale !== 1.0) {
              ctx.scale(fontSizeScale, fontSizeScale);
              lineWidth /= fontSizeScale;
            }
            ctx.lineWidth = lineWidth;
            if (font.isInvalidPDFjsFont) {
              var chars = [];
              var width = 0;
              var _iterator67 = _createForOfIteratorHelper(glyphs),
                _step67;
              try {
                for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {
                  var glyph = _step67.value;
                  chars.push(glyph.unicode);
                  width += glyph.width;
                }
              } catch (err) {
                _iterator67.e(err);
              } finally {
                _iterator67.f();
              }
              ctx.fillText(chars.join(""), 0, 0);
              current.x += width * widthAdvanceScale * textHScale;
              ctx.restore();
              this.compose();
              return undefined;
            }
            var x = 0,
              i;
            for (i = 0; i < glyphsLength; ++i) {
              var _glyph = glyphs[i];
              if (typeof _glyph === "number") {
                x += spacingDir * _glyph * fontSize / 1000;
                continue;
              }
              var restoreNeeded = false;
              var spacing = (_glyph.isSpace ? wordSpacing : 0) + charSpacing;
              var character = _glyph.fontChar;
              var accent = _glyph.accent;
              var scaledX = void 0,
                scaledY = void 0;
              var _width2 = _glyph.width;
              if (vertical) {
                var vmetric = _glyph.vmetric || defaultVMetrics;
                var vx = -(_glyph.vmetric ? vmetric[1] : _width2 * 0.5) * widthAdvanceScale;
                var vy = vmetric[2] * widthAdvanceScale;
                _width2 = vmetric ? -vmetric[0] : _width2;
                scaledX = vx / fontSizeScale;
                scaledY = (x + vy) / fontSizeScale;
              } else {
                scaledX = x / fontSizeScale;
                scaledY = 0;
              }
              if (font.remeasure && _width2 > 0) {
                var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
                if (_width2 < measuredWidth && this.isFontSubpixelAAEnabled) {
                  var characterScaleX = _width2 / measuredWidth;
                  restoreNeeded = true;
                  ctx.save();
                  ctx.scale(characterScaleX, 1);
                  scaledX /= characterScaleX;
                } else if (_width2 !== measuredWidth) {
                  scaledX += (_width2 - measuredWidth) / 2000 * fontSize / fontSizeScale;
                }
              }
              if (this.contentVisible && (_glyph.isInFont || font.missingFile)) {
                if (simpleFillText && !accent) {
                  ctx.fillText(character, scaledX, scaledY);
                } else {
                  this.paintChar(character, scaledX, scaledY, patternTransform);
                  if (accent) {
                    var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                    var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                    this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                  }
                }
              }
              var charWidth = vertical ? _width2 * widthAdvanceScale - spacing * fontDirection : _width2 * widthAdvanceScale + spacing * fontDirection;
              x += charWidth;
              if (restoreNeeded) {
                ctx.restore();
              }
            }
            if (vertical) {
              current.y -= x;
            } else {
              current.x += x * textHScale;
            }
            ctx.restore();
            this.compose();
            return undefined;
          }
        }, {
          key: "showType3Text",
          value: function showType3Text(glyphs) {
            var ctx = this.ctx;
            var current = this.current;
            var font = current.font;
            var fontSize = current.fontSize;
            var fontDirection = current.fontDirection;
            var spacingDir = font.vertical ? 1 : -1;
            var charSpacing = current.charSpacing;
            var wordSpacing = current.wordSpacing;
            var textHScale = current.textHScale * fontDirection;
            var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
            var glyphsLength = glyphs.length;
            var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
            var i, glyph, width, spacingLength;
            if (isTextInvisible || fontSize === 0) {
              return;
            }
            this._cachedScaleForStroking[0] = -1;
            this._cachedGetSinglePixelWidth = null;
            ctx.save();
            ctx.transform.apply(ctx, _toConsumableArray(current.textMatrix));
            ctx.translate(current.x, current.y);
            ctx.scale(textHScale, fontDirection);
            for (i = 0; i < glyphsLength; ++i) {
              glyph = glyphs[i];
              if (typeof glyph === "number") {
                spacingLength = spacingDir * glyph * fontSize / 1000;
                this.ctx.translate(spacingLength, 0);
                current.x += spacingLength * textHScale;
                continue;
              }
              var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
              var operatorList = font.charProcOperatorList[glyph.operatorListId];
              if (!operatorList) {
                (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available."));
                continue;
              }
              if (this.contentVisible) {
                this.processingType3 = glyph;
                this.save();
                ctx.scale(fontSize, fontSize);
                ctx.transform.apply(ctx, _toConsumableArray(fontMatrix));
                this.executeOperatorList(operatorList);
                this.restore();
              }
              var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);
              width = transformed[0] * fontSize + spacing;
              ctx.translate(width, 0);
              current.x += width * textHScale;
            }
            ctx.restore();
            this.processingType3 = null;
          }
        }, {
          key: "setCharWidth",
          value: function setCharWidth(xWidth, yWidth) {}
        }, {
          key: "setCharWidthAndBounds",
          value: function setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
            this.ctx.rect(llx, lly, urx - llx, ury - lly);
            this.ctx.clip();
            this.endPath();
          }
        }, {
          key: "getColorN_Pattern",
          value: function getColorN_Pattern(IR) {
            var _this41 = this;
            var pattern;
            if (IR[0] === "TilingPattern") {
              var color = IR[1];
              var baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);
              var canvasGraphicsFactory = {
                createCanvasGraphics: function createCanvasGraphics(ctx) {
                  return new CanvasGraphics(ctx, _this41.commonObjs, _this41.objs, _this41.canvasFactory, _this41.filterFactory, {
                    optionalContentConfig: _this41.optionalContentConfig,
                    markedContentStack: _this41.markedContentStack
                  });
                }
              };
              pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
            } else {
              pattern = this._getPattern(IR[1], IR[2]);
            }
            return pattern;
          }
        }, {
          key: "setStrokeColorN",
          value: function setStrokeColorN() {
            this.current.strokeColor = this.getColorN_Pattern(arguments);
          }
        }, {
          key: "setFillColorN",
          value: function setFillColorN() {
            this.current.fillColor = this.getColorN_Pattern(arguments);
            this.current.patternFill = true;
          }
        }, {
          key: "setStrokeRGBColor",
          value: function setStrokeRGBColor(r, g, b) {
            var color = _util.Util.makeHexColor(r, g, b);
            this.ctx.strokeStyle = color;
            this.current.strokeColor = color;
          }
        }, {
          key: "setFillRGBColor",
          value: function setFillRGBColor(r, g, b) {
            var color = _util.Util.makeHexColor(r, g, b);
            this.ctx.fillStyle = color;
            this.current.fillColor = color;
            this.current.patternFill = false;
          }
        }, {
          key: "_getPattern",
          value: function _getPattern(objId) {
            var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var pattern;
            if (this.cachedPatterns.has(objId)) {
              pattern = this.cachedPatterns.get(objId);
            } else {
              pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));
              this.cachedPatterns.set(objId, pattern);
            }
            if (matrix) {
              pattern.matrix = matrix;
            }
            return pattern;
          }
        }, {
          key: "shadingFill",
          value: function shadingFill(objId) {
            if (!this.contentVisible) {
              return;
            }
            var ctx = this.ctx;
            this.save();
            var pattern = this._getPattern(objId);
            ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
            var inv = (0, _display_utils.getCurrentTransformInverse)(ctx);
            if (inv) {
              var _ctx$canvas = ctx.canvas,
                width = _ctx$canvas.width,
                height = _ctx$canvas.height;
              var _util$Util$getAxialAl = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv),
                _util$Util$getAxialAl2 = _slicedToArray(_util$Util$getAxialAl, 4),
                x0 = _util$Util$getAxialAl2[0],
                y0 = _util$Util$getAxialAl2[1],
                x1 = _util$Util$getAxialAl2[2],
                y1 = _util$Util$getAxialAl2[3];
              this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
            } else {
              this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
            }
            this.compose(this.current.getClippedPathBoundingBox());
            this.restore();
          }
        }, {
          key: "beginInlineImage",
          value: function beginInlineImage() {
            (0, _util.unreachable)("Should not call beginInlineImage");
          }
        }, {
          key: "beginImageData",
          value: function beginImageData() {
            (0, _util.unreachable)("Should not call beginImageData");
          }
        }, {
          key: "paintFormXObjectBegin",
          value: function paintFormXObjectBegin(matrix, bbox) {
            if (!this.contentVisible) {
              return;
            }
            this.save();
            this.baseTransformStack.push(this.baseTransform);
            if (Array.isArray(matrix) && matrix.length === 6) {
              this.transform.apply(this, _toConsumableArray(matrix));
            }
            this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);
            if (bbox) {
              var width = bbox[2] - bbox[0];
              var height = bbox[3] - bbox[1];
              this.ctx.rect(bbox[0], bbox[1], width, height);
              this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);
              this.clip();
              this.endPath();
            }
          }
        }, {
          key: "paintFormXObjectEnd",
          value: function paintFormXObjectEnd() {
            if (!this.contentVisible) {
              return;
            }
            this.restore();
            this.baseTransform = this.baseTransformStack.pop();
          }
        }, {
          key: "beginGroup",
          value: function beginGroup(group) {
            if (!this.contentVisible) {
              return;
            }
            this.save();
            if (this.inSMaskMode) {
              this.endSMaskMode();
              this.current.activeSMask = null;
            }
            var currentCtx = this.ctx;
            if (!group.isolated) {
              (0, _util.info)("TODO: Support non-isolated groups.");
            }
            if (group.knockout) {
              (0, _util.warn)("Knockout groups not supported.");
            }
            var currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);
            if (group.matrix) {
              currentCtx.transform.apply(currentCtx, _toConsumableArray(group.matrix));
            }
            if (!group.bbox) {
              throw new Error("Bounding box is required.");
            }
            var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));
            var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
            bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
            var offsetX = Math.floor(bounds[0]);
            var offsetY = Math.floor(bounds[1]);
            var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
            var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
            var scaleX = 1,
              scaleY = 1;
            if (drawnWidth > MAX_GROUP_SIZE) {
              scaleX = drawnWidth / MAX_GROUP_SIZE;
              drawnWidth = MAX_GROUP_SIZE;
            }
            if (drawnHeight > MAX_GROUP_SIZE) {
              scaleY = drawnHeight / MAX_GROUP_SIZE;
              drawnHeight = MAX_GROUP_SIZE;
            }
            this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
            var cacheId = "groupAt" + this.groupLevel;
            if (group.smask) {
              cacheId += "_smask_" + this.smaskCounter++ % 2;
            }
            var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
            var groupCtx = scratchCanvas.context;
            groupCtx.scale(1 / scaleX, 1 / scaleY);
            groupCtx.translate(-offsetX, -offsetY);
            groupCtx.transform.apply(groupCtx, _toConsumableArray(currentTransform));
            if (group.smask) {
              this.smaskStack.push({
                canvas: scratchCanvas.canvas,
                context: groupCtx,
                offsetX: offsetX,
                offsetY: offsetY,
                scaleX: scaleX,
                scaleY: scaleY,
                subtype: group.smask.subtype,
                backdrop: group.smask.backdrop,
                transferMap: group.smask.transferMap || null,
                startTransformInverse: null
              });
            } else {
              currentCtx.setTransform(1, 0, 0, 1, 0, 0);
              currentCtx.translate(offsetX, offsetY);
              currentCtx.scale(scaleX, scaleY);
              currentCtx.save();
            }
            copyCtxState(currentCtx, groupCtx);
            this.ctx = groupCtx;
            this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            this.groupStack.push(currentCtx);
            this.groupLevel++;
          }
        }, {
          key: "endGroup",
          value: function endGroup(group) {
            if (!this.contentVisible) {
              return;
            }
            this.groupLevel--;
            var groupCtx = this.ctx;
            var ctx = this.groupStack.pop();
            this.ctx = ctx;
            this.ctx.imageSmoothingEnabled = false;
            if (group.smask) {
              this.tempSMask = this.smaskStack.pop();
              this.restore();
            } else {
              var _this$ctx4;
              this.ctx.restore();
              var currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);
              this.restore();
              this.ctx.save();
              (_this$ctx4 = this.ctx).setTransform.apply(_this$ctx4, _toConsumableArray(currentMtx));
              var dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
              this.ctx.drawImage(groupCtx.canvas, 0, 0);
              this.ctx.restore();
              this.compose(dirtyBox);
            }
          }
        }, {
          key: "beginAnnotation",
          value: function beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
            _assertClassBrand(_CanvasGraphics_brand, this, _restoreInitialState).call(this);
            resetCtxToDefault(this.ctx);
            this.ctx.save();
            this.save();
            if (this.baseTransform) {
              var _this$ctx5;
              (_this$ctx5 = this.ctx).setTransform.apply(_this$ctx5, _toConsumableArray(this.baseTransform));
            }
            if (Array.isArray(rect) && rect.length === 4) {
              var width = rect[2] - rect[0];
              var height = rect[3] - rect[1];
              if (hasOwnCanvas && this.annotationCanvasMap) {
                transform = transform.slice();
                transform[4] -= rect[0];
                transform[5] -= rect[1];
                rect = rect.slice();
                rect[0] = rect[1] = 0;
                rect[2] = width;
                rect[3] = height;
                var _util$Util$singularVa = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx)),
                  _util$Util$singularVa2 = _slicedToArray(_util$Util$singularVa, 2),
                  scaleX = _util$Util$singularVa2[0],
                  scaleY = _util$Util$singularVa2[1];
                var viewportScale = this.viewportScale;
                var canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                var canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                var _this$annotationCanva = this.annotationCanvas,
                  canvas = _this$annotationCanva.canvas,
                  context = _this$annotationCanva.context;
                this.annotationCanvasMap.set(id, canvas);
                this.annotationCanvas.savedCtx = this.ctx;
                this.ctx = context;
                this.ctx.save();
                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                resetCtxToDefault(this.ctx);
              } else {
                resetCtxToDefault(this.ctx);
                this.ctx.rect(rect[0], rect[1], width, height);
                this.ctx.clip();
                this.endPath();
              }
            }
            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
            this.transform.apply(this, _toConsumableArray(transform));
            this.transform.apply(this, _toConsumableArray(matrix));
          }
        }, {
          key: "endAnnotation",
          value: function endAnnotation() {
            if (this.annotationCanvas) {
              this.ctx.restore();
              _assertClassBrand(_CanvasGraphics_brand, this, _drawFilter).call(this);
              this.ctx = this.annotationCanvas.savedCtx;
              delete this.annotationCanvas.savedCtx;
              delete this.annotationCanvas;
            }
          }
        }, {
          key: "paintImageMaskXObject",
          value: function paintImageMaskXObject(img) {
            if (!this.contentVisible) {
              return;
            }
            var count = img.count;
            img = this.getObject(img.data, img);
            img.count = count;
            var ctx = this.ctx;
            var glyph = this.processingType3;
            if (glyph) {
              if (glyph.compiled === undefined) {
                glyph.compiled = compileType3Glyph(img);
              }
              if (glyph.compiled) {
                glyph.compiled(ctx);
                return;
              }
            }
            var mask = this._createMaskCanvas(img);
            var maskCanvas = mask.canvas;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
            ctx.restore();
            this.compose();
          }
        }, {
          key: "paintImageMaskXObjectRepeat",
          value: function paintImageMaskXObjectRepeat(img, scaleX) {
            var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var scaleY = arguments.length > 4 ? arguments[4] : undefined;
            var positions = arguments.length > 5 ? arguments[5] : undefined;
            if (!this.contentVisible) {
              return;
            }
            img = this.getObject(img.data, img);
            var ctx = this.ctx;
            ctx.save();
            var currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
            ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
            var mask = this._createMaskCanvas(img);
            ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
            for (var i = 0, ii = positions.length; i < ii; i += 2) {
              var trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
              var _util$Util$applyTrans3 = _util.Util.applyTransform([0, 0], trans),
                _util$Util$applyTrans4 = _slicedToArray(_util$Util$applyTrans3, 2),
                x = _util$Util$applyTrans4[0],
                y = _util$Util$applyTrans4[1];
              ctx.drawImage(mask.canvas, x, y);
            }
            ctx.restore();
            this.compose();
          }
        }, {
          key: "paintImageMaskXObjectGroup",
          value: function paintImageMaskXObjectGroup(images) {
            if (!this.contentVisible) {
              return;
            }
            var ctx = this.ctx;
            var fillColor = this.current.fillColor;
            var isPatternFill = this.current.patternFill;
            var _iterator68 = _createForOfIteratorHelper(images),
              _step68;
            try {
              for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {
                var image = _step68.value;
                var data = image.data,
                  width = image.width,
                  height = image.height,
                  transform = image.transform;
                var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                var maskCtx = maskCanvas.context;
                maskCtx.save();
                var img = this.getObject(data, image);
                putBinaryImageMask(maskCtx, img);
                maskCtx.globalCompositeOperation = "source-in";
                maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                maskCtx.fillRect(0, 0, width, height);
                maskCtx.restore();
                ctx.save();
                ctx.transform.apply(ctx, _toConsumableArray(transform));
                ctx.scale(1, -1);
                drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                ctx.restore();
              }
            } catch (err) {
              _iterator68.e(err);
            } finally {
              _iterator68.f();
            }
            this.compose();
          }
        }, {
          key: "paintImageXObject",
          value: function paintImageXObject(objId) {
            if (!this.contentVisible) {
              return;
            }
            var imgData = this.getObject(objId);
            if (!imgData) {
              (0, _util.warn)("Dependent image isn't ready yet");
              return;
            }
            this.paintInlineImageXObject(imgData);
          }
        }, {
          key: "paintImageXObjectRepeat",
          value: function paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
            if (!this.contentVisible) {
              return;
            }
            var imgData = this.getObject(objId);
            if (!imgData) {
              (0, _util.warn)("Dependent image isn't ready yet");
              return;
            }
            var width = imgData.width;
            var height = imgData.height;
            var map = [];
            for (var i = 0, ii = positions.length; i < ii; i += 2) {
              map.push({
                transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                x: 0,
                y: 0,
                w: width,
                h: height
              });
            }
            this.paintInlineImageXObjectGroup(imgData, map);
          }
        }, {
          key: "applyTransferMapsToCanvas",
          value: function applyTransferMapsToCanvas(ctx) {
            if (this.current.transferMaps !== "none") {
              ctx.filter = this.current.transferMaps;
              ctx.drawImage(ctx.canvas, 0, 0);
              ctx.filter = "none";
            }
            return ctx.canvas;
          }
        }, {
          key: "applyTransferMapsToBitmap",
          value: function applyTransferMapsToBitmap(imgData) {
            if (this.current.transferMaps === "none") {
              return imgData.bitmap;
            }
            var bitmap = imgData.bitmap,
              width = imgData.width,
              height = imgData.height;
            var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
            var tmpCtx = tmpCanvas.context;
            tmpCtx.filter = this.current.transferMaps;
            tmpCtx.drawImage(bitmap, 0, 0);
            tmpCtx.filter = "none";
            return tmpCanvas.canvas;
          }
        }, {
          key: "paintInlineImageXObject",
          value: function paintInlineImageXObject(imgData) {
            if (!this.contentVisible) {
              return;
            }
            var width = imgData.width;
            var height = imgData.height;
            var ctx = this.ctx;
            this.save();
            if (!_util.isNodeJS) {
              var filter = ctx.filter;
              if (filter !== "none" && filter !== "") {
                ctx.filter = "none";
              }
            }
            ctx.scale(1 / width, -1 / height);
            var imgToPaint;
            if (imgData.bitmap) {
              imgToPaint = this.applyTransferMapsToBitmap(imgData);
            } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
              imgToPaint = imgData;
            } else {
              var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
              var tmpCtx = tmpCanvas.context;
              putBinaryImageData(tmpCtx, imgData);
              imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
            }
            var scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));
            ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);
            drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
            this.compose();
            this.restore();
          }
        }, {
          key: "paintInlineImageXObjectGroup",
          value: function paintInlineImageXObjectGroup(imgData, map) {
            if (!this.contentVisible) {
              return;
            }
            var ctx = this.ctx;
            var imgToPaint;
            if (imgData.bitmap) {
              imgToPaint = imgData.bitmap;
            } else {
              var w = imgData.width;
              var h = imgData.height;
              var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
              var tmpCtx = tmpCanvas.context;
              putBinaryImageData(tmpCtx, imgData);
              imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
            }
            var _iterator69 = _createForOfIteratorHelper(map),
              _step69;
            try {
              for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {
                var entry = _step69.value;
                ctx.save();
                ctx.transform.apply(ctx, _toConsumableArray(entry.transform));
                ctx.scale(1, -1);
                drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                ctx.restore();
              }
            } catch (err) {
              _iterator69.e(err);
            } finally {
              _iterator69.f();
            }
            this.compose();
          }
        }, {
          key: "paintSolidColorImageMask",
          value: function paintSolidColorImageMask() {
            if (!this.contentVisible) {
              return;
            }
            this.ctx.fillRect(0, 0, 1, 1);
            this.compose();
          }
        }, {
          key: "markPoint",
          value: function markPoint(tag) {}
        }, {
          key: "markPointProps",
          value: function markPointProps(tag, properties) {}
        }, {
          key: "beginMarkedContent",
          value: function beginMarkedContent(tag) {
            this.markedContentStack.push({
              visible: true
            });
          }
        }, {
          key: "beginMarkedContentProps",
          value: function beginMarkedContentProps(tag, properties) {
            if (tag === "OC") {
              this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(properties)
              });
            } else {
              this.markedContentStack.push({
                visible: true
              });
            }
            this.contentVisible = this.isContentVisible();
          }
        }, {
          key: "endMarkedContent",
          value: function endMarkedContent() {
            this.markedContentStack.pop();
            this.contentVisible = this.isContentVisible();
          }
        }, {
          key: "beginCompat",
          value: function beginCompat() {}
        }, {
          key: "endCompat",
          value: function endCompat() {}
        }, {
          key: "consumePath",
          value: function consumePath(clipBox) {
            var isEmpty = this.current.isEmptyClip();
            if (this.pendingClip) {
              this.current.updateClipFromPath();
            }
            if (!this.pendingClip) {
              this.compose(clipBox);
            }
            var ctx = this.ctx;
            if (this.pendingClip) {
              if (!isEmpty) {
                if (this.pendingClip === EO_CLIP) {
                  ctx.clip("evenodd");
                } else {
                  ctx.clip();
                }
              }
              this.pendingClip = null;
            }
            this.current.startNewPathAndClipBox(this.current.clipBox);
            ctx.beginPath();
          }
        }, {
          key: "getSinglePixelWidth",
          value: function getSinglePixelWidth() {
            if (!this._cachedGetSinglePixelWidth) {
              var m = (0, _display_utils.getCurrentTransform)(this.ctx);
              if (m[1] === 0 && m[2] === 0) {
                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
              } else {
                var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                var normX = Math.hypot(m[0], m[2]);
                var normY = Math.hypot(m[1], m[3]);
                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
              }
            }
            return this._cachedGetSinglePixelWidth;
          }
        }, {
          key: "getScaleForStroking",
          value: function getScaleForStroking() {
            if (this._cachedScaleForStroking[0] === -1) {
              var lineWidth = this.current.lineWidth;
              var _this$ctx$getTransfor = this.ctx.getTransform(),
                a = _this$ctx$getTransfor.a,
                b = _this$ctx$getTransfor.b,
                c = _this$ctx$getTransfor.c,
                d = _this$ctx$getTransfor.d;
              var scaleX, scaleY;
              if (b === 0 && c === 0) {
                var normX = Math.abs(a);
                var normY = Math.abs(d);
                if (normX === normY) {
                  if (lineWidth === 0) {
                    scaleX = scaleY = 1 / normX;
                  } else {
                    var scaledLineWidth = normX * lineWidth;
                    scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
                  }
                } else if (lineWidth === 0) {
                  scaleX = 1 / normX;
                  scaleY = 1 / normY;
                } else {
                  var scaledXLineWidth = normX * lineWidth;
                  var scaledYLineWidth = normY * lineWidth;
                  scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                  scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                }
              } else {
                var absDet = Math.abs(a * d - b * c);
                var _normX = Math.hypot(a, b);
                var _normY = Math.hypot(c, d);
                if (lineWidth === 0) {
                  scaleX = _normY / absDet;
                  scaleY = _normX / absDet;
                } else {
                  var baseArea = lineWidth * absDet;
                  scaleX = _normY > baseArea ? _normY / baseArea : 1;
                  scaleY = _normX > baseArea ? _normX / baseArea : 1;
                }
              }
              this._cachedScaleForStroking[0] = scaleX;
              this._cachedScaleForStroking[1] = scaleY;
            }
            return this._cachedScaleForStroking;
          }
        }, {
          key: "rescaleAndStroke",
          value: function rescaleAndStroke(saveRestore) {
            var ctx = this.ctx;
            var lineWidth = this.current.lineWidth;
            var _this$getScaleForStro = this.getScaleForStroking(),
              _this$getScaleForStro2 = _slicedToArray(_this$getScaleForStro, 2),
              scaleX = _this$getScaleForStro2[0],
              scaleY = _this$getScaleForStro2[1];
            ctx.lineWidth = lineWidth || 1;
            if (scaleX === 1 && scaleY === 1) {
              ctx.stroke();
              return;
            }
            var dashes = ctx.getLineDash();
            if (saveRestore) {
              ctx.save();
            }
            ctx.scale(scaleX, scaleY);
            if (dashes.length > 0) {
              var scale = Math.max(scaleX, scaleY);
              ctx.setLineDash(dashes.map(function (x) {
                return x / scale;
              }));
              ctx.lineDashOffset /= scale;
            }
            ctx.stroke();
            if (saveRestore) {
              ctx.restore();
            }
          }
        }, {
          key: "isContentVisible",
          value: function isContentVisible() {
            for (var i = this.markedContentStack.length - 1; i >= 0; i--) {
              if (!this.markedContentStack[i].visible) {
                return false;
              }
            }
            return true;
          }
        }]);
      }();
      function _restoreInitialState() {
        while (this.stateStack.length || this.inSMaskMode) {
          this.restore();
        }
        this.ctx.restore();
        if (this.transparentCanvas) {
          this.ctx = this.compositeCtx;
          this.ctx.save();
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.ctx.drawImage(this.transparentCanvas, 0, 0);
          this.ctx.restore();
          this.transparentCanvas = null;
        }
      }
      function _drawFilter() {
        if (this.pageColors) {
          var hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
          if (hcmFilterId !== "none") {
            var savedFilter = this.ctx.filter;
            this.ctx.filter = hcmFilterId;
            this.ctx.drawImage(this.ctx.canvas, 0, 0);
            this.ctx.filter = savedFilter;
          }
        }
      }
      exports.CanvasGraphics = CanvasGraphics;
      for (var op in _util.OPS) {
        if (CanvasGraphics.prototype[op] !== undefined) {
          CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
        }
      }

      /***/
    }), (/* 12 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TilingPattern = exports.PathType = void 0;
      exports.getShadingPattern = getShadingPattern;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      var PathType = {
        FILL: "Fill",
        STROKE: "Stroke",
        SHADING: "Shading"
      };
      exports.PathType = PathType;
      function applyBoundingBox(ctx, bbox) {
        if (!bbox) {
          return;
        }
        var width = bbox[2] - bbox[0];
        var height = bbox[3] - bbox[1];
        var region = new Path2D();
        region.rect(bbox[0], bbox[1], width, height);
        ctx.clip(region);
      }
      var BaseShadingPattern = /*#__PURE__*/function () {
        function BaseShadingPattern() {
          _classCallCheck(this, BaseShadingPattern);
          if (this.constructor === BaseShadingPattern) {
            (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
          }
        }
        return _createClass(BaseShadingPattern, [{
          key: "getPattern",
          value: function getPattern() {
            (0, _util.unreachable)("Abstract method `getPattern` called.");
          }
        }]);
      }();
      var RadialAxialShadingPattern = /*#__PURE__*/function (_BaseShadingPattern) {
        function RadialAxialShadingPattern(IR) {
          var _this42;
          _classCallCheck(this, RadialAxialShadingPattern);
          _this42 = _callSuper(this, RadialAxialShadingPattern);
          _this42._type = IR[1];
          _this42._bbox = IR[2];
          _this42._colorStops = IR[3];
          _this42._p0 = IR[4];
          _this42._p1 = IR[5];
          _this42._r0 = IR[6];
          _this42._r1 = IR[7];
          _this42.matrix = null;
          return _this42;
        }
        _inherits(RadialAxialShadingPattern, _BaseShadingPattern);
        return _createClass(RadialAxialShadingPattern, [{
          key: "_createGradient",
          value: function _createGradient(ctx) {
            var grad;
            if (this._type === "axial") {
              grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
            } else if (this._type === "radial") {
              grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
            }
            var _iterator70 = _createForOfIteratorHelper(this._colorStops),
              _step70;
            try {
              for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
                var colorStop = _step70.value;
                grad.addColorStop(colorStop[0], colorStop[1]);
              }
            } catch (err) {
              _iterator70.e(err);
            } finally {
              _iterator70.f();
            }
            return grad;
          }
        }, {
          key: "getPattern",
          value: function getPattern(ctx, owner, inverse, pathType) {
            var pattern;
            if (pathType === PathType.STROKE || pathType === PathType.FILL) {
              var ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
              var width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
              var height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
              var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
              var tmpCtx = tmpCanvas.context;
              tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
              tmpCtx.beginPath();
              tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
              tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
              inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
              tmpCtx.transform.apply(tmpCtx, _toConsumableArray(owner.baseTransform));
              if (this.matrix) {
                tmpCtx.transform.apply(tmpCtx, _toConsumableArray(this.matrix));
              }
              applyBoundingBox(tmpCtx, this._bbox);
              tmpCtx.fillStyle = this._createGradient(tmpCtx);
              tmpCtx.fill();
              pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
              var domMatrix = new DOMMatrix(inverse);
              pattern.setTransform(domMatrix);
            } else {
              applyBoundingBox(ctx, this._bbox);
              pattern = this._createGradient(ctx);
            }
            return pattern;
          }
        }]);
      }(BaseShadingPattern);
      function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
        var coords = context.coords,
          colors = context.colors;
        var bytes = data.data,
          rowSize = data.width * 4;
        var tmp;
        if (coords[p1 + 1] > coords[p2 + 1]) {
          tmp = p1;
          p1 = p2;
          p2 = tmp;
          tmp = c1;
          c1 = c2;
          c2 = tmp;
        }
        if (coords[p2 + 1] > coords[p3 + 1]) {
          tmp = p2;
          p2 = p3;
          p3 = tmp;
          tmp = c2;
          c2 = c3;
          c3 = tmp;
        }
        if (coords[p1 + 1] > coords[p2 + 1]) {
          tmp = p1;
          p1 = p2;
          p2 = tmp;
          tmp = c1;
          c1 = c2;
          c2 = tmp;
        }
        var x1 = (coords[p1] + context.offsetX) * context.scaleX;
        var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
        var x2 = (coords[p2] + context.offsetX) * context.scaleX;
        var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
        var x3 = (coords[p3] + context.offsetX) * context.scaleX;
        var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
        if (y1 >= y3) {
          return;
        }
        var c1r = colors[c1],
          c1g = colors[c1 + 1],
          c1b = colors[c1 + 2];
        var c2r = colors[c2],
          c2g = colors[c2 + 1],
          c2b = colors[c2 + 2];
        var c3r = colors[c3],
          c3g = colors[c3 + 1],
          c3b = colors[c3 + 2];
        var minY = Math.round(y1),
          maxY = Math.round(y3);
        var xa, car, cag, cab;
        var xb, cbr, cbg, cbb;
        for (var y = minY; y <= maxY; y++) {
          if (y < y2) {
            var _k = y < y1 ? 0 : (y1 - y) / (y1 - y2);
            xa = x1 - (x1 - x2) * _k;
            car = c1r - (c1r - c2r) * _k;
            cag = c1g - (c1g - c2g) * _k;
            cab = c1b - (c1b - c2b) * _k;
          } else {
            var _k2 = void 0;
            if (y > y3) {
              _k2 = 1;
            } else if (y2 === y3) {
              _k2 = 0;
            } else {
              _k2 = (y2 - y) / (y2 - y3);
            }
            xa = x2 - (x2 - x3) * _k2;
            car = c2r - (c2r - c3r) * _k2;
            cag = c2g - (c2g - c3g) * _k2;
            cab = c2b - (c2b - c3b) * _k2;
          }
          var k = void 0;
          if (y < y1) {
            k = 0;
          } else if (y > y3) {
            k = 1;
          } else {
            k = (y1 - y) / (y1 - y3);
          }
          xb = x1 - (x1 - x3) * k;
          cbr = c1r - (c1r - c3r) * k;
          cbg = c1g - (c1g - c3g) * k;
          cbb = c1b - (c1b - c3b) * k;
          var x1_ = Math.round(Math.min(xa, xb));
          var x2_ = Math.round(Math.max(xa, xb));
          var j = rowSize * y + x1_ * 4;
          for (var x = x1_; x <= x2_; x++) {
            k = (xa - x) / (xa - xb);
            if (k < 0) {
              k = 0;
            } else if (k > 1) {
              k = 1;
            }
            bytes[j++] = car - (car - cbr) * k | 0;
            bytes[j++] = cag - (cag - cbg) * k | 0;
            bytes[j++] = cab - (cab - cbb) * k | 0;
            bytes[j++] = 255;
          }
        }
      }
      function drawFigure(data, figure, context) {
        var ps = figure.coords;
        var cs = figure.colors;
        var i, ii;
        switch (figure.type) {
          case "lattice":
            var verticesPerRow = figure.verticesPerRow;
            var rows = Math.floor(ps.length / verticesPerRow) - 1;
            var cols = verticesPerRow - 1;
            for (i = 0; i < rows; i++) {
              var q = i * verticesPerRow;
              for (var j = 0; j < cols; j++, q++) {
                drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
              }
            }
            break;
          case "triangles":
            for (i = 0, ii = ps.length; i < ii; i += 3) {
              drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
            }
            break;
          default:
            throw new Error("illegal figure");
        }
      }
      var MeshShadingPattern = /*#__PURE__*/function (_BaseShadingPattern2) {
        function MeshShadingPattern(IR) {
          var _this43;
          _classCallCheck(this, MeshShadingPattern);
          _this43 = _callSuper(this, MeshShadingPattern);
          _this43._coords = IR[2];
          _this43._colors = IR[3];
          _this43._figures = IR[4];
          _this43._bounds = IR[5];
          _this43._bbox = IR[7];
          _this43._background = IR[8];
          _this43.matrix = null;
          return _this43;
        }
        _inherits(MeshShadingPattern, _BaseShadingPattern2);
        return _createClass(MeshShadingPattern, [{
          key: "_createMeshCanvas",
          value: function _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
            var EXPECTED_SCALE = 1.1;
            var MAX_PATTERN_SIZE = 3000;
            var BORDER_SIZE = 2;
            var offsetX = Math.floor(this._bounds[0]);
            var offsetY = Math.floor(this._bounds[1]);
            var boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
            var boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
            var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
            var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
            var scaleX = boundsWidth / width;
            var scaleY = boundsHeight / height;
            var context = {
              coords: this._coords,
              colors: this._colors,
              offsetX: -offsetX,
              offsetY: -offsetY,
              scaleX: 1 / scaleX,
              scaleY: 1 / scaleY
            };
            var paddedWidth = width + BORDER_SIZE * 2;
            var paddedHeight = height + BORDER_SIZE * 2;
            var tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
            var tmpCtx = tmpCanvas.context;
            var data = tmpCtx.createImageData(width, height);
            if (backgroundColor) {
              var bytes = data.data;
              for (var i = 0, ii = bytes.length; i < ii; i += 4) {
                bytes[i] = backgroundColor[0];
                bytes[i + 1] = backgroundColor[1];
                bytes[i + 2] = backgroundColor[2];
                bytes[i + 3] = 255;
              }
            }
            var _iterator71 = _createForOfIteratorHelper(this._figures),
              _step71;
            try {
              for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
                var figure = _step71.value;
                drawFigure(data, figure, context);
              }
            } catch (err) {
              _iterator71.e(err);
            } finally {
              _iterator71.f();
            }
            tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
            var canvas = tmpCanvas.canvas;
            return {
              canvas: canvas,
              offsetX: offsetX - BORDER_SIZE * scaleX,
              offsetY: offsetY - BORDER_SIZE * scaleY,
              scaleX: scaleX,
              scaleY: scaleY
            };
          }
        }, {
          key: "getPattern",
          value: function getPattern(ctx, owner, inverse, pathType) {
            applyBoundingBox(ctx, this._bbox);
            var scale;
            if (pathType === PathType.SHADING) {
              scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));
            } else {
              scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);
              if (this.matrix) {
                var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
                scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
              }
            }
            var temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
            if (pathType !== PathType.SHADING) {
              ctx.setTransform.apply(ctx, _toConsumableArray(owner.baseTransform));
              if (this.matrix) {
                ctx.transform.apply(ctx, _toConsumableArray(this.matrix));
              }
            }
            ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
            ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
            return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
          }
        }]);
      }(BaseShadingPattern);
      var DummyShadingPattern = /*#__PURE__*/function (_BaseShadingPattern3) {
        function DummyShadingPattern() {
          _classCallCheck(this, DummyShadingPattern);
          return _callSuper(this, DummyShadingPattern, arguments);
        }
        _inherits(DummyShadingPattern, _BaseShadingPattern3);
        return _createClass(DummyShadingPattern, [{
          key: "getPattern",
          value: function getPattern() {
            return "hotpink";
          }
        }]);
      }(BaseShadingPattern);
      function getShadingPattern(IR) {
        switch (IR[0]) {
          case "RadialAxial":
            return new RadialAxialShadingPattern(IR);
          case "Mesh":
            return new MeshShadingPattern(IR);
          case "Dummy":
            return new DummyShadingPattern();
        }
        throw new Error("Unknown IR type: ".concat(IR[0]));
      }
      var PaintType = {
        COLORED: 1,
        UNCOLORED: 2
      };
      var TilingPattern = /*#__PURE__*/function () {
        function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
          _classCallCheck(this, TilingPattern);
          this.operatorList = IR[2];
          this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
          this.bbox = IR[4];
          this.xstep = IR[5];
          this.ystep = IR[6];
          this.paintType = IR[7];
          this.tilingType = IR[8];
          this.color = color;
          this.ctx = ctx;
          this.canvasGraphicsFactory = canvasGraphicsFactory;
          this.baseTransform = baseTransform;
        }
        return _createClass(TilingPattern, [{
          key: "createPatternCanvas",
          value: function createPatternCanvas(owner) {
            var operatorList = this.operatorList;
            var bbox = this.bbox;
            var xstep = this.xstep;
            var ystep = this.ystep;
            var paintType = this.paintType;
            var tilingType = this.tilingType;
            var color = this.color;
            var canvasGraphicsFactory = this.canvasGraphicsFactory;
            (0, _util.info)("TilingType: " + tilingType);
            var x0 = bbox[0],
              y0 = bbox[1],
              x1 = bbox[2],
              y1 = bbox[3];
            var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
            var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);
            var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
            var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
            var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
            var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
            var tmpCtx = tmpCanvas.context;
            var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
            graphics.groupLevel = owner.groupLevel;
            this.setFillAndStrokeStyleToContext(graphics, paintType, color);
            var adjustedX0 = x0;
            var adjustedY0 = y0;
            var adjustedX1 = x1;
            var adjustedY1 = y1;
            if (x0 < 0) {
              adjustedX0 = 0;
              adjustedX1 += Math.abs(x0);
            }
            if (y0 < 0) {
              adjustedY0 = 0;
              adjustedY1 += Math.abs(y0);
            }
            tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
            graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
            tmpCtx.save();
            this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
            graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);
            graphics.executeOperatorList(operatorList);
            graphics.endDrawing();
            return {
              canvas: tmpCanvas.canvas,
              scaleX: dimx.scale,
              scaleY: dimy.scale,
              offsetX: adjustedX0,
              offsetY: adjustedY0
            };
          }
        }, {
          key: "getSizeAndScale",
          value: function getSizeAndScale(step, realOutputSize, scale) {
            step = Math.abs(step);
            var maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
            var size = Math.ceil(step * scale);
            if (size >= maxSize) {
              size = maxSize;
            } else {
              scale = size / step;
            }
            return {
              scale: scale,
              size: size
            };
          }
        }, {
          key: "clipBbox",
          value: function clipBbox(graphics, x0, y0, x1, y1) {
            var bboxWidth = x1 - x0;
            var bboxHeight = y1 - y0;
            graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
            graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
            graphics.clip();
            graphics.endPath();
          }
        }, {
          key: "setFillAndStrokeStyleToContext",
          value: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
            var context = graphics.ctx,
              current = graphics.current;
            switch (paintType) {
              case PaintType.COLORED:
                var ctx = this.ctx;
                context.fillStyle = ctx.fillStyle;
                context.strokeStyle = ctx.strokeStyle;
                current.fillColor = ctx.fillStyle;
                current.strokeColor = ctx.strokeStyle;
                break;
              case PaintType.UNCOLORED:
                var cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);
                context.fillStyle = cssColor;
                context.strokeStyle = cssColor;
                current.fillColor = cssColor;
                current.strokeColor = cssColor;
                break;
              default:
                throw new _util.FormatError("Unsupported paint type: ".concat(paintType));
            }
          }
        }, {
          key: "getPattern",
          value: function getPattern(ctx, owner, inverse, pathType) {
            var matrix = inverse;
            if (pathType !== PathType.SHADING) {
              matrix = _util.Util.transform(matrix, owner.baseTransform);
              if (this.matrix) {
                matrix = _util.Util.transform(matrix, this.matrix);
              }
            }
            var temporaryPatternCanvas = this.createPatternCanvas(owner);
            var domMatrix = new DOMMatrix(matrix);
            domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
            domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
            var pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
            pattern.setTransform(domMatrix);
            return pattern;
          }
        }]);
      }();
      _defineProperty(TilingPattern, "MAX_PATTERN_SIZE", 3000);
      exports.TilingPattern = TilingPattern;

      /***/
    }), (/* 13 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
      exports.convertToRGBA = convertToRGBA;
      exports.grayToRGBA = grayToRGBA;
      var _util = __w_pdfjs_require__(1);
      function convertToRGBA(params) {
        switch (params.kind) {
          case _util.ImageKind.GRAYSCALE_1BPP:
            return convertBlackAndWhiteToRGBA(params);
          case _util.ImageKind.RGB_24BPP:
            return convertRGBToRGBA(params);
        }
        return null;
      }
      function convertBlackAndWhiteToRGBA(_ref53) {
        var src = _ref53.src,
          _ref53$srcPos = _ref53.srcPos,
          srcPos = _ref53$srcPos === void 0 ? 0 : _ref53$srcPos,
          dest = _ref53.dest,
          width = _ref53.width,
          height = _ref53.height,
          _ref53$nonBlackColor = _ref53.nonBlackColor,
          nonBlackColor = _ref53$nonBlackColor === void 0 ? 0xffffffff : _ref53$nonBlackColor,
          _ref53$inverseDecode = _ref53.inverseDecode,
          inverseDecode = _ref53$inverseDecode === void 0 ? false : _ref53$inverseDecode;
        var black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
        var _ref54 = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor],
          _ref55 = _slicedToArray(_ref54, 2),
          zeroMapping = _ref55[0],
          oneMapping = _ref55[1];
        var widthInSource = width >> 3;
        var widthRemainder = width & 7;
        var srcLength = src.length;
        dest = new Uint32Array(dest.buffer);
        var destPos = 0;
        for (var i = 0; i < height; i++) {
          for (var max = srcPos + widthInSource; srcPos < max; srcPos++) {
            var _elem = srcPos < srcLength ? src[srcPos] : 255;
            dest[destPos++] = _elem & 128 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 64 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 32 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 16 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 8 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 4 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 2 ? oneMapping : zeroMapping;
            dest[destPos++] = _elem & 1 ? oneMapping : zeroMapping;
          }
          if (widthRemainder === 0) {
            continue;
          }
          var elem = srcPos < srcLength ? src[srcPos++] : 255;
          for (var j = 0; j < widthRemainder; j++) {
            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
          }
        }
        return {
          srcPos: srcPos,
          destPos: destPos
        };
      }
      function convertRGBToRGBA(_ref56) {
        var src = _ref56.src,
          _ref56$srcPos = _ref56.srcPos,
          srcPos = _ref56$srcPos === void 0 ? 0 : _ref56$srcPos,
          dest = _ref56.dest,
          _ref56$destPos = _ref56.destPos,
          destPos = _ref56$destPos === void 0 ? 0 : _ref56$destPos,
          width = _ref56.width,
          height = _ref56.height;
        var i = 0;
        var len32 = src.length >> 2;
        var src32 = new Uint32Array(src.buffer, srcPos, len32);
        if (_util.FeatureTest.isLittleEndian) {
          for (; i < len32 - 2; i += 3, destPos += 4) {
            var s1 = src32[i];
            var s2 = src32[i + 1];
            var s3 = src32[i + 2];
            dest[destPos] = s1 | 0xff000000;
            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;
            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;
            dest[destPos + 3] = s3 >>> 8 | 0xff000000;
          }
          for (var j = i * 4, jj = src.length; j < jj; j += 3) {
            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;
          }
        } else {
          for (; i < len32 - 2; i += 3, destPos += 4) {
            var _s = src32[i];
            var _s2 = src32[i + 1];
            var _s3 = src32[i + 2];
            dest[destPos] = _s | 0xff;
            dest[destPos + 1] = _s << 24 | _s2 >>> 8 | 0xff;
            dest[destPos + 2] = _s2 << 16 | _s3 >>> 16 | 0xff;
            dest[destPos + 3] = _s3 << 8 | 0xff;
          }
          for (var _j = i * 4, _jj = src.length; _j < _jj; _j += 3) {
            dest[destPos++] = src[_j] << 24 | src[_j + 1] << 16 | src[_j + 2] << 8 | 0xff;
          }
        }
        return {
          srcPos: srcPos,
          destPos: destPos
        };
      }
      function grayToRGBA(src, dest) {
        if (_util.FeatureTest.isLittleEndian) {
          for (var i = 0, ii = src.length; i < ii; i++) {
            dest[i] = src[i] * 0x10101 | 0xff000000;
          }
        } else {
          for (var _i12 = 0, _ii = src.length; _i12 < _ii; _i12++) {
            dest[_i12] = src[_i12] * 0x1010100 | 0x000000ff;
          }
        }
      }

      /***/
    }), (/* 14 */
    /***/function (__unused_webpack_module, exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GlobalWorkerOptions = void 0;
      var GlobalWorkerOptions = Object.create(null);
      exports.GlobalWorkerOptions = GlobalWorkerOptions;
      GlobalWorkerOptions.workerPort = null;
      GlobalWorkerOptions.workerSrc = "";

      /***/
    }), (/* 15 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MessageHandler = void 0;
      var _util = __w_pdfjs_require__(1);
      var CallbackKind = {
        UNKNOWN: 0,
        DATA: 1,
        ERROR: 2
      };
      var StreamKind = {
        UNKNOWN: 0,
        CANCEL: 1,
        CANCEL_COMPLETE: 2,
        CLOSE: 3,
        ENQUEUE: 4,
        ERROR: 5,
        PULL: 6,
        PULL_COMPLETE: 7,
        START_COMPLETE: 8
      };
      function wrapReason(reason) {
        if (!(reason instanceof Error || _typeof(reason) === "object" && reason !== null)) {
          (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
        }
        switch (reason.name) {
          case "AbortException":
            return new _util.AbortException(reason.message);
          case "MissingPDFException":
            return new _util.MissingPDFException(reason.message);
          case "PasswordException":
            return new _util.PasswordException(reason.message, reason.code);
          case "UnexpectedResponseException":
            return new _util.UnexpectedResponseException(reason.message, reason.status);
          case "UnknownErrorException":
            return new _util.UnknownErrorException(reason.message, reason.details);
          default:
            return new _util.UnknownErrorException(reason.message, reason.toString());
        }
      }
      var _MessageHandler_brand = /*#__PURE__*/new WeakSet();
      var MessageHandler = /*#__PURE__*/function () {
        function MessageHandler(_sourceName, _targetName, _comObj) {
          var _this44 = this;
          _classCallCheck(this, MessageHandler);
          _classPrivateMethodInitSpec(this, _MessageHandler_brand);
          this.sourceName = _sourceName;
          this.targetName = _targetName;
          this.comObj = _comObj;
          this.callbackId = 1;
          this.streamId = 1;
          this.streamSinks = Object.create(null);
          this.streamControllers = Object.create(null);
          this.callbackCapabilities = Object.create(null);
          this.actionHandler = Object.create(null);
          this._onComObjOnMessage = function (event) {
            var data = event.data;
            if (data.targetName !== _this44.sourceName) {
              return;
            }
            if (data.stream) {
              _assertClassBrand(_MessageHandler_brand, _this44, _processStreamMessage).call(_this44, data);
              return;
            }
            if (data.callback) {
              var callbackId = data.callbackId;
              var capability = _this44.callbackCapabilities[callbackId];
              if (!capability) {
                throw new Error("Cannot resolve callback ".concat(callbackId));
              }
              delete _this44.callbackCapabilities[callbackId];
              if (data.callback === CallbackKind.DATA) {
                capability.resolve(data.data);
              } else if (data.callback === CallbackKind.ERROR) {
                capability.reject(wrapReason(data.reason));
              } else {
                throw new Error("Unexpected callback case");
              }
              return;
            }
            var action = _this44.actionHandler[data.action];
            if (!action) {
              throw new Error("Unknown action from worker: ".concat(data.action));
            }
            if (data.callbackId) {
              var cbSourceName = _this44.sourceName;
              var cbTargetName = data.sourceName;
              new Promise(function (resolve) {
                resolve(action(data.data));
              }).then(function (result) {
                _comObj.postMessage({
                  sourceName: cbSourceName,
                  targetName: cbTargetName,
                  callback: CallbackKind.DATA,
                  callbackId: data.callbackId,
                  data: result
                });
              }, function (reason) {
                _comObj.postMessage({
                  sourceName: cbSourceName,
                  targetName: cbTargetName,
                  callback: CallbackKind.ERROR,
                  callbackId: data.callbackId,
                  reason: wrapReason(reason)
                });
              });
              return;
            }
            if (data.streamId) {
              _assertClassBrand(_MessageHandler_brand, _this44, _createStreamSink).call(_this44, data);
              return;
            }
            action(data.data);
          };
          _comObj.addEventListener("message", this._onComObjOnMessage);
        }
        return _createClass(MessageHandler, [{
          key: "on",
          value: function on(actionName, handler) {
            var ah = this.actionHandler;
            if (ah[actionName]) {
              throw new Error("There is already an actionName called \"".concat(actionName, "\""));
            }
            ah[actionName] = handler;
          }
        }, {
          key: "send",
          value: function send(actionName, data, transfers) {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: actionName,
              data: data
            }, transfers);
          }
        }, {
          key: "sendWithPromise",
          value: function sendWithPromise(actionName, data, transfers) {
            var callbackId = this.callbackId++;
            var capability = new _util.PromiseCapability();
            this.callbackCapabilities[callbackId] = capability;
            try {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: actionName,
                callbackId: callbackId,
                data: data
              }, transfers);
            } catch (ex) {
              capability.reject(ex);
            }
            return capability.promise;
          }
        }, {
          key: "sendWithStream",
          value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
            var _this45 = this;
            var streamId = this.streamId++,
              sourceName = this.sourceName,
              targetName = this.targetName,
              comObj = this.comObj;
            return new ReadableStream({
              start: function start(controller) {
                var startCapability = new _util.PromiseCapability();
                _this45.streamControllers[streamId] = {
                  controller: controller,
                  startCall: startCapability,
                  pullCall: null,
                  cancelCall: null,
                  isClosed: false
                };
                comObj.postMessage({
                  sourceName: sourceName,
                  targetName: targetName,
                  action: actionName,
                  streamId: streamId,
                  data: data,
                  desiredSize: controller.desiredSize
                }, transfers);
                return startCapability.promise;
              },
              pull: function pull(controller) {
                var pullCapability = new _util.PromiseCapability();
                _this45.streamControllers[streamId].pullCall = pullCapability;
                comObj.postMessage({
                  sourceName: sourceName,
                  targetName: targetName,
                  stream: StreamKind.PULL,
                  streamId: streamId,
                  desiredSize: controller.desiredSize
                });
                return pullCapability.promise;
              },
              cancel: function cancel(reason) {
                (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
                var cancelCapability = new _util.PromiseCapability();
                _this45.streamControllers[streamId].cancelCall = cancelCapability;
                _this45.streamControllers[streamId].isClosed = true;
                comObj.postMessage({
                  sourceName: sourceName,
                  targetName: targetName,
                  stream: StreamKind.CANCEL,
                  streamId: streamId,
                  reason: wrapReason(reason)
                });
                return cancelCapability.promise;
              }
            }, queueingStrategy);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.comObj.removeEventListener("message", this._onComObjOnMessage);
          }
        }]);
      }();
      function _createStreamSink(data) {
        var streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
        var self = this,
          action = this.actionHandler[data.action];
        var streamSink = {
          enqueue: function enqueue(chunk) {
            var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var transfers = arguments.length > 2 ? arguments[2] : undefined;
            if (this.isCancelled) {
              return;
            }
            var lastDesiredSize = this.desiredSize;
            this.desiredSize -= size;
            if (lastDesiredSize > 0 && this.desiredSize <= 0) {
              this.sinkCapability = new _util.PromiseCapability();
              this.ready = this.sinkCapability.promise;
            }
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.ENQUEUE,
              streamId: streamId,
              chunk: chunk
            }, transfers);
          },
          close: function close() {
            if (this.isCancelled) {
              return;
            }
            this.isCancelled = true;
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.CLOSE,
              streamId: streamId
            });
            delete self.streamSinks[streamId];
          },
          error: function error(reason) {
            (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
            if (this.isCancelled) {
              return;
            }
            this.isCancelled = true;
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.ERROR,
              streamId: streamId,
              reason: wrapReason(reason)
            });
          },
          sinkCapability: new _util.PromiseCapability(),
          onPull: null,
          onCancel: null,
          isCancelled: false,
          desiredSize: data.desiredSize,
          ready: null
        };
        streamSink.sinkCapability.resolve();
        streamSink.ready = streamSink.sinkCapability.promise;
        this.streamSinks[streamId] = streamSink;
        new Promise(function (resolve) {
          resolve(action(data.data, streamSink));
        }).then(function () {
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.START_COMPLETE,
            streamId: streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.START_COMPLETE,
            streamId: streamId,
            reason: wrapReason(reason)
          });
        });
      }
      function _processStreamMessage(data) {
        var streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
        var streamController = this.streamControllers[streamId],
          streamSink = this.streamSinks[streamId];
        switch (data.stream) {
          case StreamKind.START_COMPLETE:
            if (data.success) {
              streamController.startCall.resolve();
            } else {
              streamController.startCall.reject(wrapReason(data.reason));
            }
            break;
          case StreamKind.PULL_COMPLETE:
            if (data.success) {
              streamController.pullCall.resolve();
            } else {
              streamController.pullCall.reject(wrapReason(data.reason));
            }
            break;
          case StreamKind.PULL:
            if (!streamSink) {
              comObj.postMessage({
                sourceName: sourceName,
                targetName: targetName,
                stream: StreamKind.PULL_COMPLETE,
                streamId: streamId,
                success: true
              });
              break;
            }
            if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
              streamSink.sinkCapability.resolve();
            }
            streamSink.desiredSize = data.desiredSize;
            new Promise(function (resolve) {
              var _streamSink$onPull;
              resolve((_streamSink$onPull = streamSink.onPull) === null || _streamSink$onPull === void 0 ? void 0 : _streamSink$onPull.call(streamSink));
            }).then(function () {
              comObj.postMessage({
                sourceName: sourceName,
                targetName: targetName,
                stream: StreamKind.PULL_COMPLETE,
                streamId: streamId,
                success: true
              });
            }, function (reason) {
              comObj.postMessage({
                sourceName: sourceName,
                targetName: targetName,
                stream: StreamKind.PULL_COMPLETE,
                streamId: streamId,
                reason: wrapReason(reason)
              });
            });
            break;
          case StreamKind.ENQUEUE:
            (0, _util.assert)(streamController, "enqueue should have stream controller");
            if (streamController.isClosed) {
              break;
            }
            streamController.controller.enqueue(data.chunk);
            break;
          case StreamKind.CLOSE:
            (0, _util.assert)(streamController, "close should have stream controller");
            if (streamController.isClosed) {
              break;
            }
            streamController.isClosed = true;
            streamController.controller.close();
            _assertClassBrand(_MessageHandler_brand, this, _deleteStreamController).call(this, streamController, streamId);
            break;
          case StreamKind.ERROR:
            (0, _util.assert)(streamController, "error should have stream controller");
            streamController.controller.error(wrapReason(data.reason));
            _assertClassBrand(_MessageHandler_brand, this, _deleteStreamController).call(this, streamController, streamId);
            break;
          case StreamKind.CANCEL_COMPLETE:
            if (data.success) {
              streamController.cancelCall.resolve();
            } else {
              streamController.cancelCall.reject(wrapReason(data.reason));
            }
            _assertClassBrand(_MessageHandler_brand, this, _deleteStreamController).call(this, streamController, streamId);
            break;
          case StreamKind.CANCEL:
            if (!streamSink) {
              break;
            }
            new Promise(function (resolve) {
              var _streamSink$onCancel;
              resolve((_streamSink$onCancel = streamSink.onCancel) === null || _streamSink$onCancel === void 0 ? void 0 : _streamSink$onCancel.call(streamSink, wrapReason(data.reason)));
            }).then(function () {
              comObj.postMessage({
                sourceName: sourceName,
                targetName: targetName,
                stream: StreamKind.CANCEL_COMPLETE,
                streamId: streamId,
                success: true
              });
            }, function (reason) {
              comObj.postMessage({
                sourceName: sourceName,
                targetName: targetName,
                stream: StreamKind.CANCEL_COMPLETE,
                streamId: streamId,
                reason: wrapReason(reason)
              });
            });
            streamSink.sinkCapability.reject(wrapReason(data.reason));
            streamSink.isCancelled = true;
            delete this.streamSinks[streamId];
            break;
          default:
            throw new Error("Unexpected stream case");
        }
      }
      function _deleteStreamController(_x14, _x15) {
        return _deleteStreamController2.apply(this, arguments);
      }
      function _deleteStreamController2() {
        _deleteStreamController2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(streamController, streamId) {
          var _streamController$sta, _streamController$pul, _streamController$can;
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return Promise.allSettled([(_streamController$sta = streamController.startCall) === null || _streamController$sta === void 0 ? void 0 : _streamController$sta.promise, (_streamController$pul = streamController.pullCall) === null || _streamController$pul === void 0 ? void 0 : _streamController$pul.promise, (_streamController$can = streamController.cancelCall) === null || _streamController$can === void 0 ? void 0 : _streamController$can.promise]);
              case 2:
                delete this.streamControllers[streamId];
              case 3:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));
        return _deleteStreamController2.apply(this, arguments);
      }
      exports.MessageHandler = MessageHandler;

      /***/
    }), (/* 16 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Metadata = void 0;
      var _util = __w_pdfjs_require__(1);
      var _metadataMap = /*#__PURE__*/new WeakMap();
      var _data2 = /*#__PURE__*/new WeakMap();
      var Metadata = /*#__PURE__*/function () {
        function Metadata(_ref57) {
          var parsedData = _ref57.parsedData,
            rawData = _ref57.rawData;
          _classCallCheck(this, Metadata);
          _classPrivateFieldInitSpec(this, _metadataMap, void 0);
          _classPrivateFieldInitSpec(this, _data2, void 0);
          _classPrivateFieldSet(_metadataMap, this, parsedData);
          _classPrivateFieldSet(_data2, this, rawData);
        }
        return _createClass(Metadata, [{
          key: "getRaw",
          value: function getRaw() {
            return _classPrivateFieldGet(_data2, this);
          }
        }, {
          key: "get",
          value: function get(name) {
            var _classPrivateFieldGet20;
            return (_classPrivateFieldGet20 = _classPrivateFieldGet(_metadataMap, this).get(name)) !== null && _classPrivateFieldGet20 !== void 0 ? _classPrivateFieldGet20 : null;
          }
        }, {
          key: "getAll",
          value: function getAll() {
            return (0, _util.objectFromMap)(_classPrivateFieldGet(_metadataMap, this));
          }
        }, {
          key: "has",
          value: function has(name) {
            return _classPrivateFieldGet(_metadataMap, this).has(name);
          }
        }]);
      }();
      exports.Metadata = Metadata;

      /***/
    }), (/* 17 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OptionalContentConfig = void 0;
      var _util = __w_pdfjs_require__(1);
      var _murmurhash = __w_pdfjs_require__(8);
      var INTERNAL = Symbol("INTERNAL");
      var _visible = /*#__PURE__*/new WeakMap();
      var OptionalContentGroup = /*#__PURE__*/function () {
        function OptionalContentGroup(name, intent) {
          _classCallCheck(this, OptionalContentGroup);
          _classPrivateFieldInitSpec(this, _visible, true);
          this.name = name;
          this.intent = intent;
        }
        return _createClass(OptionalContentGroup, [{
          key: "visible",
          get: function get() {
            return _classPrivateFieldGet(_visible, this);
          }
        }, {
          key: "_setVisible",
          value: function _setVisible(internal, visible) {
            if (internal !== INTERNAL) {
              (0, _util.unreachable)("Internal method `_setVisible` called.");
            }
            _classPrivateFieldSet(_visible, this, visible);
          }
        }]);
      }();
      var _cachedGetHash = /*#__PURE__*/new WeakMap();
      var _groups = /*#__PURE__*/new WeakMap();
      var _initialHash = /*#__PURE__*/new WeakMap();
      var _order = /*#__PURE__*/new WeakMap();
      var _OptionalContentConfig_brand = /*#__PURE__*/new WeakSet();
      var OptionalContentConfig = /*#__PURE__*/function () {
        function OptionalContentConfig(data) {
          _classCallCheck(this, OptionalContentConfig);
          _classPrivateMethodInitSpec(this, _OptionalContentConfig_brand);
          _classPrivateFieldInitSpec(this, _cachedGetHash, null);
          _classPrivateFieldInitSpec(this, _groups, new Map());
          _classPrivateFieldInitSpec(this, _initialHash, null);
          _classPrivateFieldInitSpec(this, _order, null);
          this.name = null;
          this.creator = null;
          if (data === null) {
            return;
          }
          this.name = data.name;
          this.creator = data.creator;
          _classPrivateFieldSet(_order, this, data.order);
          var _iterator72 = _createForOfIteratorHelper(data.groups),
            _step72;
          try {
            for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {
              var _group = _step72.value;
              _classPrivateFieldGet(_groups, this).set(_group.id, new OptionalContentGroup(_group.name, _group.intent));
            }
          } catch (err) {
            _iterator72.e(err);
          } finally {
            _iterator72.f();
          }
          if (data.baseState === "OFF") {
            var _iterator73 = _createForOfIteratorHelper(_classPrivateFieldGet(_groups, this).values()),
              _step73;
            try {
              for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {
                var group = _step73.value;
                group._setVisible(INTERNAL, false);
              }
            } catch (err) {
              _iterator73.e(err);
            } finally {
              _iterator73.f();
            }
          }
          var _iterator74 = _createForOfIteratorHelper(data.on),
            _step74;
          try {
            for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {
              var on = _step74.value;
              _classPrivateFieldGet(_groups, this).get(on)._setVisible(INTERNAL, true);
            }
          } catch (err) {
            _iterator74.e(err);
          } finally {
            _iterator74.f();
          }
          var _iterator75 = _createForOfIteratorHelper(data.off),
            _step75;
          try {
            for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
              var off = _step75.value;
              _classPrivateFieldGet(_groups, this).get(off)._setVisible(INTERNAL, false);
            }
          } catch (err) {
            _iterator75.e(err);
          } finally {
            _iterator75.f();
          }
          _classPrivateFieldSet(_initialHash, this, this.getHash());
        }
        return _createClass(OptionalContentConfig, [{
          key: "isVisible",
          value: function isVisible(group) {
            if (_classPrivateFieldGet(_groups, this).size === 0) {
              return true;
            }
            if (!group) {
              (0, _util.warn)("Optional content group not defined.");
              return true;
            }
            if (group.type === "OCG") {
              if (!_classPrivateFieldGet(_groups, this).has(group.id)) {
                (0, _util.warn)("Optional content group not found: ".concat(group.id));
                return true;
              }
              return _classPrivateFieldGet(_groups, this).get(group.id).visible;
            } else if (group.type === "OCMD") {
              if (group.expression) {
                return _assertClassBrand(_OptionalContentConfig_brand, this, _evaluateVisibilityExpression).call(this, group.expression);
              }
              if (!group.policy || group.policy === "AnyOn") {
                var _iterator76 = _createForOfIteratorHelper(group.ids),
                  _step76;
                try {
                  for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
                    var id = _step76.value;
                    if (!_classPrivateFieldGet(_groups, this).has(id)) {
                      (0, _util.warn)("Optional content group not found: ".concat(id));
                      return true;
                    }
                    if (_classPrivateFieldGet(_groups, this).get(id).visible) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator76.e(err);
                } finally {
                  _iterator76.f();
                }
                return false;
              } else if (group.policy === "AllOn") {
                var _iterator77 = _createForOfIteratorHelper(group.ids),
                  _step77;
                try {
                  for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {
                    var _id4 = _step77.value;
                    if (!_classPrivateFieldGet(_groups, this).has(_id4)) {
                      (0, _util.warn)("Optional content group not found: ".concat(_id4));
                      return true;
                    }
                    if (!_classPrivateFieldGet(_groups, this).get(_id4).visible) {
                      return false;
                    }
                  }
                } catch (err) {
                  _iterator77.e(err);
                } finally {
                  _iterator77.f();
                }
                return true;
              } else if (group.policy === "AnyOff") {
                var _iterator78 = _createForOfIteratorHelper(group.ids),
                  _step78;
                try {
                  for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
                    var _id5 = _step78.value;
                    if (!_classPrivateFieldGet(_groups, this).has(_id5)) {
                      (0, _util.warn)("Optional content group not found: ".concat(_id5));
                      return true;
                    }
                    if (!_classPrivateFieldGet(_groups, this).get(_id5).visible) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator78.e(err);
                } finally {
                  _iterator78.f();
                }
                return false;
              } else if (group.policy === "AllOff") {
                var _iterator79 = _createForOfIteratorHelper(group.ids),
                  _step79;
                try {
                  for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
                    var _id6 = _step79.value;
                    if (!_classPrivateFieldGet(_groups, this).has(_id6)) {
                      (0, _util.warn)("Optional content group not found: ".concat(_id6));
                      return true;
                    }
                    if (_classPrivateFieldGet(_groups, this).get(_id6).visible) {
                      return false;
                    }
                  }
                } catch (err) {
                  _iterator79.e(err);
                } finally {
                  _iterator79.f();
                }
                return true;
              }
              (0, _util.warn)("Unknown optional content policy ".concat(group.policy, "."));
              return true;
            }
            (0, _util.warn)("Unknown group type ".concat(group.type, "."));
            return true;
          }
        }, {
          key: "setVisibility",
          value: function setVisibility(id) {
            var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            if (!_classPrivateFieldGet(_groups, this).has(id)) {
              (0, _util.warn)("Optional content group not found: ".concat(id));
              return;
            }
            _classPrivateFieldGet(_groups, this).get(id)._setVisible(INTERNAL, !!visible);
            _classPrivateFieldSet(_cachedGetHash, this, null);
          }
        }, {
          key: "hasInitialVisibility",
          get: function get() {
            return _classPrivateFieldGet(_initialHash, this) === null || this.getHash() === _classPrivateFieldGet(_initialHash, this);
          }
        }, {
          key: "getOrder",
          value: function getOrder() {
            if (!_classPrivateFieldGet(_groups, this).size) {
              return null;
            }
            if (_classPrivateFieldGet(_order, this)) {
              return _classPrivateFieldGet(_order, this).slice();
            }
            return _toConsumableArray(_classPrivateFieldGet(_groups, this).keys());
          }
        }, {
          key: "getGroups",
          value: function getGroups() {
            return _classPrivateFieldGet(_groups, this).size > 0 ? (0, _util.objectFromMap)(_classPrivateFieldGet(_groups, this)) : null;
          }
        }, {
          key: "getGroup",
          value: function getGroup(id) {
            return _classPrivateFieldGet(_groups, this).get(id) || null;
          }
        }, {
          key: "getHash",
          value: function getHash() {
            if (_classPrivateFieldGet(_cachedGetHash, this) !== null) {
              return _classPrivateFieldGet(_cachedGetHash, this);
            }
            var hash = new _murmurhash.MurmurHash3_64();
            var _iterator80 = _createForOfIteratorHelper(_classPrivateFieldGet(_groups, this)),
              _step80;
            try {
              for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {
                var _step80$value = _slicedToArray(_step80.value, 2),
                  id = _step80$value[0],
                  group = _step80$value[1];
                hash.update("".concat(id, ":").concat(group.visible));
              }
            } catch (err) {
              _iterator80.e(err);
            } finally {
              _iterator80.f();
            }
            return _classPrivateFieldSet(_cachedGetHash, this, hash.hexdigest());
          }
        }]);
      }();
      function _evaluateVisibilityExpression(array) {
        var length = array.length;
        if (length < 2) {
          return true;
        }
        var operator = array[0];
        for (var i = 1; i < length; i++) {
          var element = array[i];
          var state = void 0;
          if (Array.isArray(element)) {
            state = _assertClassBrand(_OptionalContentConfig_brand, this, _evaluateVisibilityExpression).call(this, element);
          } else if (_classPrivateFieldGet(_groups, this).has(element)) {
            state = _classPrivateFieldGet(_groups, this).get(element).visible;
          } else {
            (0, _util.warn)("Optional content group not found: ".concat(element));
            return true;
          }
          switch (operator) {
            case "And":
              if (!state) {
                return false;
              }
              break;
            case "Or":
              if (state) {
                return true;
              }
              break;
            case "Not":
              return !state;
            default:
              return true;
          }
        }
        return operator === "And";
      }
      exports.OptionalContentConfig = OptionalContentConfig;

      /***/
    }), (/* 18 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFDataTransportStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      var PDFDataTransportStream = /*#__PURE__*/function () {
        function PDFDataTransportStream(_ref58, pdfDataRangeTransport) {
          var _this46 = this;
          var length = _ref58.length,
            initialData = _ref58.initialData,
            _ref58$progressiveDon = _ref58.progressiveDone,
            progressiveDone = _ref58$progressiveDon === void 0 ? false : _ref58$progressiveDon,
            _ref58$contentDisposi = _ref58.contentDispositionFilename,
            contentDispositionFilename = _ref58$contentDisposi === void 0 ? null : _ref58$contentDisposi,
            _ref58$disableRange = _ref58.disableRange,
            disableRange = _ref58$disableRange === void 0 ? false : _ref58$disableRange,
            _ref58$disableStream = _ref58.disableStream,
            disableStream = _ref58$disableStream === void 0 ? false : _ref58$disableStream;
          _classCallCheck(this, PDFDataTransportStream);
          (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
          this._queuedChunks = [];
          this._progressiveDone = progressiveDone;
          this._contentDispositionFilename = contentDispositionFilename;
          if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
            var buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
            this._queuedChunks.push(buffer);
          }
          this._pdfDataRangeTransport = pdfDataRangeTransport;
          this._isStreamingSupported = !disableStream;
          this._isRangeSupported = !disableRange;
          this._contentLength = length;
          this._fullRequestReader = null;
          this._rangeReaders = [];
          this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
            _this46._onReceiveData({
              begin: begin,
              chunk: chunk
            });
          });
          this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {
            _this46._onProgress({
              loaded: loaded,
              total: total
            });
          });
          this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
            _this46._onReceiveData({
              chunk: chunk
            });
          });
          this._pdfDataRangeTransport.addProgressiveDoneListener(function () {
            _this46._onProgressiveDone();
          });
          this._pdfDataRangeTransport.transportReady();
        }
        return _createClass(PDFDataTransportStream, [{
          key: "_onReceiveData",
          value: function _onReceiveData(_ref59) {
            var begin = _ref59.begin,
              chunk = _ref59.chunk;
            var buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
            if (begin === undefined) {
              if (this._fullRequestReader) {
                this._fullRequestReader._enqueue(buffer);
              } else {
                this._queuedChunks.push(buffer);
              }
            } else {
              var found = this._rangeReaders.some(function (rangeReader) {
                if (rangeReader._begin !== begin) {
                  return false;
                }
                rangeReader._enqueue(buffer);
                return true;
              });
              (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
            }
          }
        }, {
          key: "_progressiveDataLength",
          get: function get() {
            var _this$_fullRequestRea, _this$_fullRequestRea2;
            return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
          }
        }, {
          key: "_onProgress",
          value: function _onProgress(evt) {
            if (evt.total === undefined) {
              var _this$_rangeReaders$, _this$_rangeReaders$$;
              (_this$_rangeReaders$ = this._rangeReaders[0]) === null || _this$_rangeReaders$ === void 0 || (_this$_rangeReaders$$ = _this$_rangeReaders$.onProgress) === null || _this$_rangeReaders$$ === void 0 || _this$_rangeReaders$$.call(_this$_rangeReaders$, {
                loaded: evt.loaded
              });
            } else {
              var _this$_fullRequestRea3, _this$_fullRequestRea4;
              (_this$_fullRequestRea3 = this._fullRequestReader) === null || _this$_fullRequestRea3 === void 0 || (_this$_fullRequestRea4 = _this$_fullRequestRea3.onProgress) === null || _this$_fullRequestRea4 === void 0 || _this$_fullRequestRea4.call(_this$_fullRequestRea3, {
                loaded: evt.loaded,
                total: evt.total
              });
            }
          }
        }, {
          key: "_onProgressiveDone",
          value: function _onProgressiveDone() {
            var _this$_fullRequestRea5;
            (_this$_fullRequestRea5 = this._fullRequestReader) === null || _this$_fullRequestRea5 === void 0 || _this$_fullRequestRea5.progressiveDone();
            this._progressiveDone = true;
          }
        }, {
          key: "_removeRangeReader",
          value: function _removeRangeReader(reader) {
            var i = this._rangeReaders.indexOf(reader);
            if (i >= 0) {
              this._rangeReaders.splice(i, 1);
            }
          }
        }, {
          key: "getFullReader",
          value: function getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
            var queuedChunks = this._queuedChunks;
            this._queuedChunks = null;
            return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
          }
        }, {
          key: "getRangeReader",
          value: function getRangeReader(begin, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }
            var reader = new PDFDataTransportStreamRangeReader(this, begin, end);
            this._pdfDataRangeTransport.requestDataRange(begin, end);
            this._rangeReaders.push(reader);
            return reader;
          }
        }, {
          key: "cancelAllRequests",
          value: function cancelAllRequests(reason) {
            var _this$_fullRequestRea6;
            (_this$_fullRequestRea6 = this._fullRequestReader) === null || _this$_fullRequestRea6 === void 0 || _this$_fullRequestRea6.cancel(reason);
            var _iterator81 = _createForOfIteratorHelper(this._rangeReaders.slice(0)),
              _step81;
            try {
              for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
                var reader = _step81.value;
                reader.cancel(reason);
              }
            } catch (err) {
              _iterator81.e(err);
            } finally {
              _iterator81.f();
            }
            this._pdfDataRangeTransport.abort();
          }
        }]);
      }();
      exports.PDFDataTransportStream = PDFDataTransportStream;
      var PDFDataTransportStreamReader = /*#__PURE__*/function () {
        function PDFDataTransportStreamReader(stream, queuedChunks) {
          var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          _classCallCheck(this, PDFDataTransportStreamReader);
          this._stream = stream;
          this._done = progressiveDone || false;
          this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
          this._queuedChunks = queuedChunks || [];
          this._loaded = 0;
          var _iterator82 = _createForOfIteratorHelper(this._queuedChunks),
            _step82;
          try {
            for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {
              var chunk = _step82.value;
              this._loaded += chunk.byteLength;
            }
          } catch (err) {
            _iterator82.e(err);
          } finally {
            _iterator82.f();
          }
          this._requests = [];
          this._headersReady = Promise.resolve();
          stream._fullRequestReader = this;
          this.onProgress = null;
        }
        return _createClass(PDFDataTransportStreamReader, [{
          key: "_enqueue",
          value: function _enqueue(chunk) {
            if (this._done) {
              return;
            }
            if (this._requests.length > 0) {
              var requestCapability = this._requests.shift();
              requestCapability.resolve({
                value: chunk,
                done: false
              });
            } else {
              this._queuedChunks.push(chunk);
            }
            this._loaded += chunk.byteLength;
          }
        }, {
          key: "headersReady",
          get: function get() {
            return this._headersReady;
          }
        }, {
          key: "filename",
          get: function get() {
            return this._filename;
          }
        }, {
          key: "isRangeSupported",
          get: function get() {
            return this._stream._isRangeSupported;
          }
        }, {
          key: "isStreamingSupported",
          get: function get() {
            return this._stream._isStreamingSupported;
          }
        }, {
          key: "contentLength",
          get: function get() {
            return this._stream._contentLength;
          }
        }, {
          key: "read",
          value: function () {
            var _read = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
              var chunk, requestCapability;
              return _regeneratorRuntime().wrap(function _callee20$(_context20) {
                while (1) switch (_context20.prev = _context20.next) {
                  case 0:
                    if (!(this._queuedChunks.length > 0)) {
                      _context20.next = 3;
                      break;
                    }
                    chunk = this._queuedChunks.shift();
                    return _context20.abrupt("return", {
                      value: chunk,
                      done: false
                    });
                  case 3:
                    if (!this._done) {
                      _context20.next = 5;
                      break;
                    }
                    return _context20.abrupt("return", {
                      value: undefined,
                      done: true
                    });
                  case 5:
                    requestCapability = new _util.PromiseCapability();
                    this._requests.push(requestCapability);
                    return _context20.abrupt("return", requestCapability.promise);
                  case 8:
                  case "end":
                    return _context20.stop();
                }
              }, _callee20, this);
            }));
            function read() {
              return _read.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            this._done = true;
            var _iterator83 = _createForOfIteratorHelper(this._requests),
              _step83;
            try {
              for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
                var requestCapability = _step83.value;
                requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }
            } catch (err) {
              _iterator83.e(err);
            } finally {
              _iterator83.f();
            }
            this._requests.length = 0;
          }
        }, {
          key: "progressiveDone",
          value: function progressiveDone() {
            if (this._done) {
              return;
            }
            this._done = true;
          }
        }]);
      }();
      var PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {
        function PDFDataTransportStreamRangeReader(stream, begin, end) {
          _classCallCheck(this, PDFDataTransportStreamRangeReader);
          this._stream = stream;
          this._begin = begin;
          this._end = end;
          this._queuedChunk = null;
          this._requests = [];
          this._done = false;
          this.onProgress = null;
        }
        return _createClass(PDFDataTransportStreamRangeReader, [{
          key: "_enqueue",
          value: function _enqueue(chunk) {
            if (this._done) {
              return;
            }
            if (this._requests.length === 0) {
              this._queuedChunk = chunk;
            } else {
              var requestsCapability = this._requests.shift();
              requestsCapability.resolve({
                value: chunk,
                done: false
              });
              var _iterator84 = _createForOfIteratorHelper(this._requests),
                _step84;
              try {
                for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
                  var requestCapability = _step84.value;
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator84.e(err);
              } finally {
                _iterator84.f();
              }
              this._requests.length = 0;
            }
            this._done = true;
            this._stream._removeRangeReader(this);
          }
        }, {
          key: "isStreamingSupported",
          get: function get() {
            return false;
          }
        }, {
          key: "read",
          value: function () {
            var _read2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
              var chunk, requestCapability;
              return _regeneratorRuntime().wrap(function _callee21$(_context21) {
                while (1) switch (_context21.prev = _context21.next) {
                  case 0:
                    if (!this._queuedChunk) {
                      _context21.next = 4;
                      break;
                    }
                    chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return _context21.abrupt("return", {
                      value: chunk,
                      done: false
                    });
                  case 4:
                    if (!this._done) {
                      _context21.next = 6;
                      break;
                    }
                    return _context21.abrupt("return", {
                      value: undefined,
                      done: true
                    });
                  case 6:
                    requestCapability = new _util.PromiseCapability();
                    this._requests.push(requestCapability);
                    return _context21.abrupt("return", requestCapability.promise);
                  case 9:
                  case "end":
                    return _context21.stop();
                }
              }, _callee21, this);
            }));
            function read() {
              return _read2.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            this._done = true;
            var _iterator85 = _createForOfIteratorHelper(this._requests),
              _step85;
            try {
              for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
                var requestCapability = _step85.value;
                requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }
            } catch (err) {
              _iterator85.e(err);
            } finally {
              _iterator85.f();
            }
            this._requests.length = 0;
            this._stream._removeRangeReader(this);
          }
        }]);
      }();
      /***/
    }), (/* 19 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFFetchStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _network_utils = __w_pdfjs_require__(20);
      ;
      function createFetchOptions(headers, withCredentials, abortController) {
        return {
          method: "GET",
          headers: headers,
          signal: abortController.signal,
          mode: "cors",
          credentials: withCredentials ? "include" : "same-origin",
          redirect: "follow"
        };
      }
      function createHeaders(httpHeaders) {
        var headers = new Headers();
        for (var property in httpHeaders) {
          var value = httpHeaders[property];
          if (value === undefined) {
            continue;
          }
          headers.append(property, value);
        }
        return headers;
      }
      function getArrayBuffer(val) {
        if (val instanceof Uint8Array) {
          return val.buffer;
        }
        if (val instanceof ArrayBuffer) {
          return val;
        }
        (0, _util.warn)("getArrayBuffer - unexpected data format: ".concat(val));
        return new Uint8Array(val).buffer;
      }
      var PDFFetchStream = /*#__PURE__*/function () {
        function PDFFetchStream(source) {
          _classCallCheck(this, PDFFetchStream);
          this.source = source;
          this.isHttp = /^https?:/i.test(source.url);
          this.httpHeaders = this.isHttp && source.httpHeaders || {};
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        return _createClass(PDFFetchStream, [{
          key: "_progressiveDataLength",
          get: function get() {
            var _this$_fullRequestRea7, _this$_fullRequestRea8;
            return (_this$_fullRequestRea7 = (_this$_fullRequestRea8 = this._fullRequestReader) === null || _this$_fullRequestRea8 === void 0 ? void 0 : _this$_fullRequestRea8._loaded) !== null && _this$_fullRequestRea7 !== void 0 ? _this$_fullRequestRea7 : 0;
          }
        }, {
          key: "getFullReader",
          value: function getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFFetchStreamReader(this);
            return this._fullRequestReader;
          }
        }, {
          key: "getRangeReader",
          value: function getRangeReader(begin, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }
            var reader = new PDFFetchStreamRangeReader(this, begin, end);
            this._rangeRequestReaders.push(reader);
            return reader;
          }
        }, {
          key: "cancelAllRequests",
          value: function cancelAllRequests(reason) {
            var _this$_fullRequestRea9;
            (_this$_fullRequestRea9 = this._fullRequestReader) === null || _this$_fullRequestRea9 === void 0 || _this$_fullRequestRea9.cancel(reason);
            var _iterator86 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
              _step86;
            try {
              for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {
                var reader = _step86.value;
                reader.cancel(reason);
              }
            } catch (err) {
              _iterator86.e(err);
            } finally {
              _iterator86.f();
            }
          }
        }]);
      }();
      exports.PDFFetchStream = PDFFetchStream;
      var PDFFetchStreamReader = /*#__PURE__*/function () {
        function PDFFetchStreamReader(stream) {
          var _this47 = this;
          _classCallCheck(this, PDFFetchStreamReader);
          this._stream = stream;
          this._reader = null;
          this._loaded = 0;
          this._filename = null;
          var source = stream.source;
          this._withCredentials = source.withCredentials || false;
          this._contentLength = source.length;
          this._headersCapability = new _util.PromiseCapability();
          this._disableRange = source.disableRange || false;
          this._rangeChunkSize = source.rangeChunkSize;
          if (!this._rangeChunkSize && !this._disableRange) {
            this._disableRange = true;
          }
          this._abortController = new AbortController();
          this._isStreamingSupported = !source.disableStream;
          this._isRangeSupported = !source.disableRange;
          this._headers = createHeaders(this._stream.httpHeaders);
          var url = source.url;
          fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
            if (!(0, _network_utils.validateResponseStatus)(response.status)) {
              throw (0, _network_utils.createResponseStatusError)(response.status, url);
            }
            _this47._reader = response.body.getReader();
            _this47._headersCapability.resolve();
            var getResponseHeader = function getResponseHeader(name) {
              return response.headers.get(name);
            };
            var _ref60 = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader: getResponseHeader,
                isHttp: _this47._stream.isHttp,
                rangeChunkSize: _this47._rangeChunkSize,
                disableRange: _this47._disableRange
              }),
              allowRangeRequests = _ref60.allowRangeRequests,
              suggestedLength = _ref60.suggestedLength;
            _this47._isRangeSupported = allowRangeRequests;
            _this47._contentLength = suggestedLength || _this47._contentLength;
            _this47._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
            if (!_this47._isStreamingSupported && _this47._isRangeSupported) {
              _this47.cancel(new _util.AbortException("Streaming is disabled."));
            }
          }).catch(this._headersCapability.reject);
          this.onProgress = null;
        }
        return _createClass(PDFFetchStreamReader, [{
          key: "headersReady",
          get: function get() {
            return this._headersCapability.promise;
          }
        }, {
          key: "filename",
          get: function get() {
            return this._filename;
          }
        }, {
          key: "contentLength",
          get: function get() {
            return this._contentLength;
          }
        }, {
          key: "isRangeSupported",
          get: function get() {
            return this._isRangeSupported;
          }
        }, {
          key: "isStreamingSupported",
          get: function get() {
            return this._isStreamingSupported;
          }
        }, {
          key: "read",
          value: function () {
            var _read3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
              var _this$onProgress;
              var _yield$this$_reader$r, value, done;
              return _regeneratorRuntime().wrap(function _callee22$(_context22) {
                while (1) switch (_context22.prev = _context22.next) {
                  case 0:
                    _context22.next = 2;
                    return this._headersCapability.promise;
                  case 2:
                    _context22.next = 4;
                    return this._reader.read();
                  case 4:
                    _yield$this$_reader$r = _context22.sent;
                    value = _yield$this$_reader$r.value;
                    done = _yield$this$_reader$r.done;
                    if (!done) {
                      _context22.next = 9;
                      break;
                    }
                    return _context22.abrupt("return", {
                      value: value,
                      done: done
                    });
                  case 9:
                    this._loaded += value.byteLength;
                    (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 || _this$onProgress.call(this, {
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                    return _context22.abrupt("return", {
                      value: getArrayBuffer(value),
                      done: false
                    });
                  case 12:
                  case "end":
                    return _context22.stop();
                }
              }, _callee22, this);
            }));
            function read() {
              return _read3.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            var _this$_reader;
            (_this$_reader = this._reader) === null || _this$_reader === void 0 || _this$_reader.cancel(reason);
            this._abortController.abort();
          }
        }]);
      }();
      var PDFFetchStreamRangeReader = /*#__PURE__*/function () {
        function PDFFetchStreamRangeReader(stream, begin, end) {
          var _this48 = this;
          _classCallCheck(this, PDFFetchStreamRangeReader);
          this._stream = stream;
          this._reader = null;
          this._loaded = 0;
          var source = stream.source;
          this._withCredentials = source.withCredentials || false;
          this._readCapability = new _util.PromiseCapability();
          this._isStreamingSupported = !source.disableStream;
          this._abortController = new AbortController();
          this._headers = createHeaders(this._stream.httpHeaders);
          this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));
          var url = source.url;
          fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
            if (!(0, _network_utils.validateResponseStatus)(response.status)) {
              throw (0, _network_utils.createResponseStatusError)(response.status, url);
            }
            _this48._readCapability.resolve();
            _this48._reader = response.body.getReader();
          }).catch(this._readCapability.reject);
          this.onProgress = null;
        }
        return _createClass(PDFFetchStreamRangeReader, [{
          key: "isStreamingSupported",
          get: function get() {
            return this._isStreamingSupported;
          }
        }, {
          key: "read",
          value: function () {
            var _read4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
              var _this$onProgress2;
              var _yield$this$_reader$r2, value, done;
              return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                while (1) switch (_context23.prev = _context23.next) {
                  case 0:
                    _context23.next = 2;
                    return this._readCapability.promise;
                  case 2:
                    _context23.next = 4;
                    return this._reader.read();
                  case 4:
                    _yield$this$_reader$r2 = _context23.sent;
                    value = _yield$this$_reader$r2.value;
                    done = _yield$this$_reader$r2.done;
                    if (!done) {
                      _context23.next = 9;
                      break;
                    }
                    return _context23.abrupt("return", {
                      value: value,
                      done: done
                    });
                  case 9:
                    this._loaded += value.byteLength;
                    (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 || _this$onProgress2.call(this, {
                      loaded: this._loaded
                    });
                    return _context23.abrupt("return", {
                      value: getArrayBuffer(value),
                      done: false
                    });
                  case 12:
                  case "end":
                    return _context23.stop();
                }
              }, _callee23, this);
            }));
            function read() {
              return _read4.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            var _this$_reader2;
            (_this$_reader2 = this._reader) === null || _this$_reader2 === void 0 || _this$_reader2.cancel(reason);
            this._abortController.abort();
          }
        }]);
      }();
      /***/
    }), (/* 20 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createResponseStatusError = createResponseStatusError;
      exports.extractFilenameFromHeader = extractFilenameFromHeader;
      exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
      exports.validateResponseStatus = validateResponseStatus;
      var _util = __w_pdfjs_require__(1);
      var _content_disposition = __w_pdfjs_require__(21);
      var _display_utils = __w_pdfjs_require__(6);
      function validateRangeRequestCapabilities(_ref61) {
        var getResponseHeader = _ref61.getResponseHeader,
          isHttp = _ref61.isHttp,
          rangeChunkSize = _ref61.rangeChunkSize,
          disableRange = _ref61.disableRange;
        var returnValues = {
          allowRangeRequests: false,
          suggestedLength: undefined
        };
        var length = parseInt(getResponseHeader("Content-Length"), 10);
        if (!Number.isInteger(length)) {
          return returnValues;
        }
        returnValues.suggestedLength = length;
        if (length <= 2 * rangeChunkSize) {
          return returnValues;
        }
        if (disableRange || !isHttp) {
          return returnValues;
        }
        if (getResponseHeader("Accept-Ranges") !== "bytes") {
          return returnValues;
        }
        var contentEncoding = getResponseHeader("Content-Encoding") || "identity";
        if (contentEncoding !== "identity") {
          return returnValues;
        }
        returnValues.allowRangeRequests = true;
        return returnValues;
      }
      function extractFilenameFromHeader(getResponseHeader) {
        var contentDisposition = getResponseHeader("Content-Disposition");
        if (contentDisposition) {
          var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
          if (filename.includes("%")) {
            try {
              filename = decodeURIComponent(filename);
            } catch (_unused12) {}
          }
          if ((0, _display_utils.isPdfFile)(filename)) {
            return filename;
          }
        }
        return null;
      }
      function createResponseStatusError(status, url) {
        if (status === 404 || status === 0 && url.startsWith("file:")) {
          return new _util.MissingPDFException('Missing PDF "' + url + '".');
        }
        return new _util.UnexpectedResponseException("Unexpected server response (".concat(status, ") while retrieving PDF \"").concat(url, "\"."), status);
      }
      function validateResponseStatus(status) {
        return status === 200 || status === 206;
      }

      /***/
    }), (/* 21 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
      var _util = __w_pdfjs_require__(1);
      function getFilenameFromContentDispositionHeader(contentDisposition) {
        var needsEncodingFixup = true;
        var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
        if (tmp) {
          tmp = tmp[1];
          var filename = rfc2616unquote(tmp);
          filename = unescape(filename);
          filename = rfc5987decode(filename);
          filename = rfc2047decode(filename);
          return fixupEncoding(filename);
        }
        tmp = rfc2231getparam(contentDisposition);
        if (tmp) {
          var _filename = rfc2047decode(tmp);
          return fixupEncoding(_filename);
        }
        tmp = toParamRegExp("filename", "i").exec(contentDisposition);
        if (tmp) {
          tmp = tmp[1];
          var _filename2 = rfc2616unquote(tmp);
          _filename2 = rfc2047decode(_filename2);
          return fixupEncoding(_filename2);
        }
        function toParamRegExp(attributePattern, flags) {
          return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
        }
        function textdecode(encoding, value) {
          if (encoding) {
            if (!/^[\x00-\xFF]+$/.test(value)) {
              return value;
            }
            try {
              var decoder = new TextDecoder(encoding, {
                fatal: true
              });
              var buffer = (0, _util.stringToBytes)(value);
              value = decoder.decode(buffer);
              needsEncodingFixup = false;
            } catch (_unused13) {}
          }
          return value;
        }
        function fixupEncoding(value) {
          if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textdecode("utf-8", value);
            if (needsEncodingFixup) {
              value = textdecode("iso-8859-1", value);
            }
          }
          return value;
        }
        function rfc2231getparam(contentDispositionStr) {
          var matches = [];
          var match;
          var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          while ((match = iter.exec(contentDispositionStr)) !== null) {
            var _match = match,
              _match2 = _slicedToArray(_match, 4),
              n = _match2[1],
              quot = _match2[2],
              part = _match2[3];
            n = parseInt(n, 10);
            if (n in matches) {
              if (n === 0) {
                break;
              }
              continue;
            }
            matches[n] = [quot, part];
          }
          var parts = [];
          for (var _n = 0; _n < matches.length; ++_n) {
            if (!(_n in matches)) {
              break;
            }
            var _matches$_n = _slicedToArray(matches[_n], 2),
              _quot = _matches$_n[0],
              _part = _matches$_n[1];
            _part = rfc2616unquote(_part);
            if (_quot) {
              _part = unescape(_part);
              if (_n === 0) {
                _part = rfc5987decode(_part);
              }
            }
            parts.push(_part);
          }
          return parts.join("");
        }
        function rfc2616unquote(value) {
          if (value.startsWith('"')) {
            var parts = value.slice(1).split('\\"');
            for (var i = 0; i < parts.length; ++i) {
              var quotindex = parts[i].indexOf('"');
              if (quotindex !== -1) {
                parts[i] = parts[i].slice(0, quotindex);
                parts.length = i + 1;
              }
              parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
            }
            value = parts.join('"');
          }
          return value;
        }
        function rfc5987decode(extvalue) {
          var encodingend = extvalue.indexOf("'");
          if (encodingend === -1) {
            return extvalue;
          }
          var encoding = extvalue.slice(0, encodingend);
          var langvalue = extvalue.slice(encodingend + 1);
          var value = langvalue.replace(/^[^']*'/, "");
          return textdecode(encoding, value);
        }
        function rfc2047decode(value) {
          if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
          }
          return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
            if (encoding === "q" || encoding === "Q") {
              text = text.replaceAll("_", " ");
              text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {
                return String.fromCharCode(parseInt(hex, 16));
              });
              return textdecode(charset, text);
            }
            try {
              text = atob(text);
            } catch (_unused14) {}
            return textdecode(charset, text);
          });
        }
        return "";
      }

      /***/
    }), (/* 22 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFNetworkStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _network_utils = __w_pdfjs_require__(20);
      ;
      var OK_RESPONSE = 200;
      var PARTIAL_CONTENT_RESPONSE = 206;
      function getArrayBuffer(xhr) {
        var data = xhr.response;
        if (typeof data !== "string") {
          return data;
        }
        return (0, _util.stringToBytes)(data).buffer;
      }
      var NetworkManager = /*#__PURE__*/function () {
        function NetworkManager(url) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _classCallCheck(this, NetworkManager);
          this.url = url;
          this.isHttp = /^https?:/i.test(url);
          this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
          this.withCredentials = args.withCredentials || false;
          this.currXhrId = 0;
          this.pendingRequests = Object.create(null);
        }
        return _createClass(NetworkManager, [{
          key: "requestRange",
          value: function requestRange(begin, end, listeners) {
            var args = {
              begin: begin,
              end: end
            };
            for (var prop in listeners) {
              args[prop] = listeners[prop];
            }
            return this.request(args);
          }
        }, {
          key: "requestFull",
          value: function requestFull(listeners) {
            return this.request(listeners);
          }
        }, {
          key: "request",
          value: function request(args) {
            var xhr = new XMLHttpRequest();
            var xhrId = this.currXhrId++;
            var pendingRequest = this.pendingRequests[xhrId] = {
              xhr: xhr
            };
            xhr.open("GET", this.url);
            xhr.withCredentials = this.withCredentials;
            for (var property in this.httpHeaders) {
              var value = this.httpHeaders[property];
              if (value === undefined) {
                continue;
              }
              xhr.setRequestHeader(property, value);
            }
            if (this.isHttp && "begin" in args && "end" in args) {
              xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
              pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
            } else {
              pendingRequest.expectedStatus = OK_RESPONSE;
            }
            xhr.responseType = "arraybuffer";
            if (args.onError) {
              xhr.onerror = function (evt) {
                args.onError(xhr.status);
              };
            }
            xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
            xhr.onprogress = this.onProgress.bind(this, xhrId);
            pendingRequest.onHeadersReceived = args.onHeadersReceived;
            pendingRequest.onDone = args.onDone;
            pendingRequest.onError = args.onError;
            pendingRequest.onProgress = args.onProgress;
            xhr.send(null);
            return xhrId;
          }
        }, {
          key: "onProgress",
          value: function onProgress(xhrId, evt) {
            var _pendingRequest$onPro;
            var pendingRequest = this.pendingRequests[xhrId];
            if (!pendingRequest) {
              return;
            }
            (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 || _pendingRequest$onPro.call(pendingRequest, evt);
          }
        }, {
          key: "onStateChange",
          value: function onStateChange(xhrId, evt) {
            var pendingRequest = this.pendingRequests[xhrId];
            if (!pendingRequest) {
              return;
            }
            var xhr = pendingRequest.xhr;
            if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
              pendingRequest.onHeadersReceived();
              delete pendingRequest.onHeadersReceived;
            }
            if (xhr.readyState !== 4) {
              return;
            }
            if (!(xhrId in this.pendingRequests)) {
              return;
            }
            delete this.pendingRequests[xhrId];
            if (xhr.status === 0 && this.isHttp) {
              var _pendingRequest$onErr;
              (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 || _pendingRequest$onErr.call(pendingRequest, xhr.status);
              return;
            }
            var xhrStatus = xhr.status || OK_RESPONSE;
            var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
            if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
              var _pendingRequest$onErr2;
              (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 || _pendingRequest$onErr2.call(pendingRequest, xhr.status);
              return;
            }
            var chunk = getArrayBuffer(xhr);
            if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
              var rangeHeader = xhr.getResponseHeader("Content-Range");
              var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
              pendingRequest.onDone({
                begin: parseInt(matches[1], 10),
                chunk: chunk
              });
            } else if (chunk) {
              pendingRequest.onDone({
                begin: 0,
                chunk: chunk
              });
            } else {
              var _pendingRequest$onErr3;
              (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 || _pendingRequest$onErr3.call(pendingRequest, xhr.status);
            }
          }
        }, {
          key: "getRequestXhr",
          value: function getRequestXhr(xhrId) {
            return this.pendingRequests[xhrId].xhr;
          }
        }, {
          key: "isPendingRequest",
          value: function isPendingRequest(xhrId) {
            return xhrId in this.pendingRequests;
          }
        }, {
          key: "abortRequest",
          value: function abortRequest(xhrId) {
            var xhr = this.pendingRequests[xhrId].xhr;
            delete this.pendingRequests[xhrId];
            xhr.abort();
          }
        }]);
      }();
      var PDFNetworkStream = /*#__PURE__*/function () {
        function PDFNetworkStream(source) {
          _classCallCheck(this, PDFNetworkStream);
          this._source = source;
          this._manager = new NetworkManager(source.url, {
            httpHeaders: source.httpHeaders,
            withCredentials: source.withCredentials
          });
          this._rangeChunkSize = source.rangeChunkSize;
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        return _createClass(PDFNetworkStream, [{
          key: "_onRangeRequestReaderClosed",
          value: function _onRangeRequestReaderClosed(reader) {
            var i = this._rangeRequestReaders.indexOf(reader);
            if (i >= 0) {
              this._rangeRequestReaders.splice(i, 1);
            }
          }
        }, {
          key: "getFullReader",
          value: function getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
            return this._fullRequestReader;
          }
        }, {
          key: "getRangeReader",
          value: function getRangeReader(begin, end) {
            var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
            reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
            this._rangeRequestReaders.push(reader);
            return reader;
          }
        }, {
          key: "cancelAllRequests",
          value: function cancelAllRequests(reason) {
            var _this$_fullRequestRea10;
            (_this$_fullRequestRea10 = this._fullRequestReader) === null || _this$_fullRequestRea10 === void 0 || _this$_fullRequestRea10.cancel(reason);
            var _iterator87 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
              _step87;
            try {
              for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {
                var reader = _step87.value;
                reader.cancel(reason);
              }
            } catch (err) {
              _iterator87.e(err);
            } finally {
              _iterator87.f();
            }
          }
        }]);
      }();
      exports.PDFNetworkStream = PDFNetworkStream;
      var PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {
        function PDFNetworkStreamFullRequestReader(manager, source) {
          _classCallCheck(this, PDFNetworkStreamFullRequestReader);
          this._manager = manager;
          var args = {
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
          };
          this._url = source.url;
          this._fullRequestId = manager.requestFull(args);
          this._headersReceivedCapability = new _util.PromiseCapability();
          this._disableRange = source.disableRange || false;
          this._contentLength = source.length;
          this._rangeChunkSize = source.rangeChunkSize;
          if (!this._rangeChunkSize && !this._disableRange) {
            this._disableRange = true;
          }
          this._isStreamingSupported = false;
          this._isRangeSupported = false;
          this._cachedChunks = [];
          this._requests = [];
          this._done = false;
          this._storedError = undefined;
          this._filename = null;
          this.onProgress = null;
        }
        return _createClass(PDFNetworkStreamFullRequestReader, [{
          key: "_onHeadersReceived",
          value: function _onHeadersReceived() {
            var fullRequestXhrId = this._fullRequestId;
            var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
            var getResponseHeader = function getResponseHeader(name) {
              return fullRequestXhr.getResponseHeader(name);
            };
            var _ref62 = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader: getResponseHeader,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              }),
              allowRangeRequests = _ref62.allowRangeRequests,
              suggestedLength = _ref62.suggestedLength;
            if (allowRangeRequests) {
              this._isRangeSupported = true;
            }
            this._contentLength = suggestedLength || this._contentLength;
            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
            if (this._isRangeSupported) {
              this._manager.abortRequest(fullRequestXhrId);
            }
            this._headersReceivedCapability.resolve();
          }
        }, {
          key: "_onDone",
          value: function _onDone(data) {
            if (data) {
              if (this._requests.length > 0) {
                var requestCapability = this._requests.shift();
                requestCapability.resolve({
                  value: data.chunk,
                  done: false
                });
              } else {
                this._cachedChunks.push(data.chunk);
              }
            }
            this._done = true;
            if (this._cachedChunks.length > 0) {
              return;
            }
            var _iterator88 = _createForOfIteratorHelper(this._requests),
              _step88;
            try {
              for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {
                var _requestCapability = _step88.value;
                _requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }
            } catch (err) {
              _iterator88.e(err);
            } finally {
              _iterator88.f();
            }
            this._requests.length = 0;
          }
        }, {
          key: "_onError",
          value: function _onError(status) {
            this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
            this._headersReceivedCapability.reject(this._storedError);
            var _iterator89 = _createForOfIteratorHelper(this._requests),
              _step89;
            try {
              for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {
                var requestCapability = _step89.value;
                requestCapability.reject(this._storedError);
              }
            } catch (err) {
              _iterator89.e(err);
            } finally {
              _iterator89.f();
            }
            this._requests.length = 0;
            this._cachedChunks.length = 0;
          }
        }, {
          key: "_onProgress",
          value: function _onProgress(evt) {
            var _this$onProgress3;
            (_this$onProgress3 = this.onProgress) === null || _this$onProgress3 === void 0 || _this$onProgress3.call(this, {
              loaded: evt.loaded,
              total: evt.lengthComputable ? evt.total : this._contentLength
            });
          }
        }, {
          key: "filename",
          get: function get() {
            return this._filename;
          }
        }, {
          key: "isRangeSupported",
          get: function get() {
            return this._isRangeSupported;
          }
        }, {
          key: "isStreamingSupported",
          get: function get() {
            return this._isStreamingSupported;
          }
        }, {
          key: "contentLength",
          get: function get() {
            return this._contentLength;
          }
        }, {
          key: "headersReady",
          get: function get() {
            return this._headersReceivedCapability.promise;
          }
        }, {
          key: "read",
          value: function () {
            var _read5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
              var chunk, requestCapability;
              return _regeneratorRuntime().wrap(function _callee24$(_context24) {
                while (1) switch (_context24.prev = _context24.next) {
                  case 0:
                    if (!this._storedError) {
                      _context24.next = 2;
                      break;
                    }
                    throw this._storedError;
                  case 2:
                    if (!(this._cachedChunks.length > 0)) {
                      _context24.next = 5;
                      break;
                    }
                    chunk = this._cachedChunks.shift();
                    return _context24.abrupt("return", {
                      value: chunk,
                      done: false
                    });
                  case 5:
                    if (!this._done) {
                      _context24.next = 7;
                      break;
                    }
                    return _context24.abrupt("return", {
                      value: undefined,
                      done: true
                    });
                  case 7:
                    requestCapability = new _util.PromiseCapability();
                    this._requests.push(requestCapability);
                    return _context24.abrupt("return", requestCapability.promise);
                  case 10:
                  case "end":
                    return _context24.stop();
                }
              }, _callee24, this);
            }));
            function read() {
              return _read5.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            this._done = true;
            this._headersReceivedCapability.reject(reason);
            var _iterator90 = _createForOfIteratorHelper(this._requests),
              _step90;
            try {
              for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {
                var requestCapability = _step90.value;
                requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }
            } catch (err) {
              _iterator90.e(err);
            } finally {
              _iterator90.f();
            }
            this._requests.length = 0;
            if (this._manager.isPendingRequest(this._fullRequestId)) {
              this._manager.abortRequest(this._fullRequestId);
            }
            this._fullRequestReader = null;
          }
        }]);
      }();
      var PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {
        function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
          _classCallCheck(this, PDFNetworkStreamRangeRequestReader);
          this._manager = manager;
          var args = {
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
          };
          this._url = manager.url;
          this._requestId = manager.requestRange(begin, end, args);
          this._requests = [];
          this._queuedChunk = null;
          this._done = false;
          this._storedError = undefined;
          this.onProgress = null;
          this.onClosed = null;
        }
        return _createClass(PDFNetworkStreamRangeRequestReader, [{
          key: "_close",
          value: function _close() {
            var _this$onClosed;
            (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 || _this$onClosed.call(this, this);
          }
        }, {
          key: "_onDone",
          value: function _onDone(data) {
            var chunk = data.chunk;
            if (this._requests.length > 0) {
              var requestCapability = this._requests.shift();
              requestCapability.resolve({
                value: chunk,
                done: false
              });
            } else {
              this._queuedChunk = chunk;
            }
            this._done = true;
            var _iterator91 = _createForOfIteratorHelper(this._requests),
              _step91;
            try {
              for (_iterator91.s(); !(_step91 = _iterator91.n()).done;) {
                var _requestCapability2 = _step91.value;
                _requestCapability2.resolve({
                  value: undefined,
                  done: true
                });
              }
            } catch (err) {
              _iterator91.e(err);
            } finally {
              _iterator91.f();
            }
            this._requests.length = 0;
            this._close();
          }
        }, {
          key: "_onError",
          value: function _onError(status) {
            this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
            var _iterator92 = _createForOfIteratorHelper(this._requests),
              _step92;
            try {
              for (_iterator92.s(); !(_step92 = _iterator92.n()).done;) {
                var requestCapability = _step92.value;
                requestCapability.reject(this._storedError);
              }
            } catch (err) {
              _iterator92.e(err);
            } finally {
              _iterator92.f();
            }
            this._requests.length = 0;
            this._queuedChunk = null;
          }
        }, {
          key: "_onProgress",
          value: function _onProgress(evt) {
            if (!this.isStreamingSupported) {
              var _this$onProgress4;
              (_this$onProgress4 = this.onProgress) === null || _this$onProgress4 === void 0 || _this$onProgress4.call(this, {
                loaded: evt.loaded
              });
            }
          }
        }, {
          key: "isStreamingSupported",
          get: function get() {
            return false;
          }
        }, {
          key: "read",
          value: function () {
            var _read6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
              var chunk, requestCapability;
              return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                while (1) switch (_context25.prev = _context25.next) {
                  case 0:
                    if (!this._storedError) {
                      _context25.next = 2;
                      break;
                    }
                    throw this._storedError;
                  case 2:
                    if (!(this._queuedChunk !== null)) {
                      _context25.next = 6;
                      break;
                    }
                    chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return _context25.abrupt("return", {
                      value: chunk,
                      done: false
                    });
                  case 6:
                    if (!this._done) {
                      _context25.next = 8;
                      break;
                    }
                    return _context25.abrupt("return", {
                      value: undefined,
                      done: true
                    });
                  case 8:
                    requestCapability = new _util.PromiseCapability();
                    this._requests.push(requestCapability);
                    return _context25.abrupt("return", requestCapability.promise);
                  case 11:
                  case "end":
                    return _context25.stop();
                }
              }, _callee25, this);
            }));
            function read() {
              return _read6.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            this._done = true;
            var _iterator93 = _createForOfIteratorHelper(this._requests),
              _step93;
            try {
              for (_iterator93.s(); !(_step93 = _iterator93.n()).done;) {
                var requestCapability = _step93.value;
                requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }
            } catch (err) {
              _iterator93.e(err);
            } finally {
              _iterator93.f();
            }
            this._requests.length = 0;
            if (this._manager.isPendingRequest(this._requestId)) {
              this._manager.abortRequest(this._requestId);
            }
            this._close();
          }
        }]);
      }();
      /***/
    }), (/* 23 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFNodeStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _network_utils = __w_pdfjs_require__(20);
      ;
      var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
      function parseUrl(sourceUrl) {
        var url = require("url");
        var parsedUrl = url.parse(sourceUrl);
        if (parsedUrl.protocol === "file:" || parsedUrl.host) {
          return parsedUrl;
        }
        if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
          return url.parse("file:///".concat(sourceUrl));
        }
        if (!parsedUrl.host) {
          parsedUrl.protocol = "file:";
        }
        return parsedUrl;
      }
      var PDFNodeStream = /*#__PURE__*/function () {
        function PDFNodeStream(source) {
          _classCallCheck(this, PDFNodeStream);
          this.source = source;
          this.url = parseUrl(source.url);
          this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
          this.isFsUrl = this.url.protocol === "file:";
          this.httpHeaders = this.isHttp && source.httpHeaders || {};
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        return _createClass(PDFNodeStream, [{
          key: "_progressiveDataLength",
          get: function get() {
            var _this$_fullRequestRea11, _this$_fullRequestRea12;
            return (_this$_fullRequestRea11 = (_this$_fullRequestRea12 = this._fullRequestReader) === null || _this$_fullRequestRea12 === void 0 ? void 0 : _this$_fullRequestRea12._loaded) !== null && _this$_fullRequestRea11 !== void 0 ? _this$_fullRequestRea11 : 0;
          }
        }, {
          key: "getFullReader",
          value: function getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
            this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
            return this._fullRequestReader;
          }
        }, {
          key: "getRangeReader",
          value: function getRangeReader(start, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }
            var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
            this._rangeRequestReaders.push(rangeReader);
            return rangeReader;
          }
        }, {
          key: "cancelAllRequests",
          value: function cancelAllRequests(reason) {
            var _this$_fullRequestRea13;
            (_this$_fullRequestRea13 = this._fullRequestReader) === null || _this$_fullRequestRea13 === void 0 || _this$_fullRequestRea13.cancel(reason);
            var _iterator94 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
              _step94;
            try {
              for (_iterator94.s(); !(_step94 = _iterator94.n()).done;) {
                var reader = _step94.value;
                reader.cancel(reason);
              }
            } catch (err) {
              _iterator94.e(err);
            } finally {
              _iterator94.f();
            }
          }
        }]);
      }();
      exports.PDFNodeStream = PDFNodeStream;
      var BaseFullReader = /*#__PURE__*/function () {
        function BaseFullReader(stream) {
          _classCallCheck(this, BaseFullReader);
          this._url = stream.url;
          this._done = false;
          this._storedError = null;
          this.onProgress = null;
          var source = stream.source;
          this._contentLength = source.length;
          this._loaded = 0;
          this._filename = null;
          this._disableRange = source.disableRange || false;
          this._rangeChunkSize = source.rangeChunkSize;
          if (!this._rangeChunkSize && !this._disableRange) {
            this._disableRange = true;
          }
          this._isStreamingSupported = !source.disableStream;
          this._isRangeSupported = !source.disableRange;
          this._readableStream = null;
          this._readCapability = new _util.PromiseCapability();
          this._headersCapability = new _util.PromiseCapability();
        }
        return _createClass(BaseFullReader, [{
          key: "headersReady",
          get: function get() {
            return this._headersCapability.promise;
          }
        }, {
          key: "filename",
          get: function get() {
            return this._filename;
          }
        }, {
          key: "contentLength",
          get: function get() {
            return this._contentLength;
          }
        }, {
          key: "isRangeSupported",
          get: function get() {
            return this._isRangeSupported;
          }
        }, {
          key: "isStreamingSupported",
          get: function get() {
            return this._isStreamingSupported;
          }
        }, {
          key: "read",
          value: function () {
            var _read7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
              var _this$onProgress5;
              var chunk, buffer;
              return _regeneratorRuntime().wrap(function _callee26$(_context26) {
                while (1) switch (_context26.prev = _context26.next) {
                  case 0:
                    _context26.next = 2;
                    return this._readCapability.promise;
                  case 2:
                    if (!this._done) {
                      _context26.next = 4;
                      break;
                    }
                    return _context26.abrupt("return", {
                      value: undefined,
                      done: true
                    });
                  case 4:
                    if (!this._storedError) {
                      _context26.next = 6;
                      break;
                    }
                    throw this._storedError;
                  case 6:
                    chunk = this._readableStream.read();
                    if (!(chunk === null)) {
                      _context26.next = 10;
                      break;
                    }
                    this._readCapability = new _util.PromiseCapability();
                    return _context26.abrupt("return", this.read());
                  case 10:
                    this._loaded += chunk.length;
                    (_this$onProgress5 = this.onProgress) === null || _this$onProgress5 === void 0 || _this$onProgress5.call(this, {
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                    buffer = new Uint8Array(chunk).buffer;
                    return _context26.abrupt("return", {
                      value: buffer,
                      done: false
                    });
                  case 14:
                  case "end":
                    return _context26.stop();
                }
              }, _callee26, this);
            }));
            function read() {
              return _read7.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            if (!this._readableStream) {
              this._error(reason);
              return;
            }
            this._readableStream.destroy(reason);
          }
        }, {
          key: "_error",
          value: function _error(reason) {
            this._storedError = reason;
            this._readCapability.resolve();
          }
        }, {
          key: "_setReadableStream",
          value: function _setReadableStream(readableStream) {
            var _this49 = this;
            this._readableStream = readableStream;
            readableStream.on("readable", function () {
              _this49._readCapability.resolve();
            });
            readableStream.on("end", function () {
              readableStream.destroy();
              _this49._done = true;
              _this49._readCapability.resolve();
            });
            readableStream.on("error", function (reason) {
              _this49._error(reason);
            });
            if (!this._isStreamingSupported && this._isRangeSupported) {
              this._error(new _util.AbortException("streaming is disabled"));
            }
            if (this._storedError) {
              this._readableStream.destroy(this._storedError);
            }
          }
        }]);
      }();
      var BaseRangeReader = /*#__PURE__*/function () {
        function BaseRangeReader(stream) {
          _classCallCheck(this, BaseRangeReader);
          this._url = stream.url;
          this._done = false;
          this._storedError = null;
          this.onProgress = null;
          this._loaded = 0;
          this._readableStream = null;
          this._readCapability = new _util.PromiseCapability();
          var source = stream.source;
          this._isStreamingSupported = !source.disableStream;
        }
        return _createClass(BaseRangeReader, [{
          key: "isStreamingSupported",
          get: function get() {
            return this._isStreamingSupported;
          }
        }, {
          key: "read",
          value: function () {
            var _read8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
              var _this$onProgress6;
              var chunk, buffer;
              return _regeneratorRuntime().wrap(function _callee27$(_context27) {
                while (1) switch (_context27.prev = _context27.next) {
                  case 0:
                    _context27.next = 2;
                    return this._readCapability.promise;
                  case 2:
                    if (!this._done) {
                      _context27.next = 4;
                      break;
                    }
                    return _context27.abrupt("return", {
                      value: undefined,
                      done: true
                    });
                  case 4:
                    if (!this._storedError) {
                      _context27.next = 6;
                      break;
                    }
                    throw this._storedError;
                  case 6:
                    chunk = this._readableStream.read();
                    if (!(chunk === null)) {
                      _context27.next = 10;
                      break;
                    }
                    this._readCapability = new _util.PromiseCapability();
                    return _context27.abrupt("return", this.read());
                  case 10:
                    this._loaded += chunk.length;
                    (_this$onProgress6 = this.onProgress) === null || _this$onProgress6 === void 0 || _this$onProgress6.call(this, {
                      loaded: this._loaded
                    });
                    buffer = new Uint8Array(chunk).buffer;
                    return _context27.abrupt("return", {
                      value: buffer,
                      done: false
                    });
                  case 14:
                  case "end":
                    return _context27.stop();
                }
              }, _callee27, this);
            }));
            function read() {
              return _read8.apply(this, arguments);
            }
            return read;
          }()
        }, {
          key: "cancel",
          value: function cancel(reason) {
            if (!this._readableStream) {
              this._error(reason);
              return;
            }
            this._readableStream.destroy(reason);
          }
        }, {
          key: "_error",
          value: function _error(reason) {
            this._storedError = reason;
            this._readCapability.resolve();
          }
        }, {
          key: "_setReadableStream",
          value: function _setReadableStream(readableStream) {
            var _this50 = this;
            this._readableStream = readableStream;
            readableStream.on("readable", function () {
              _this50._readCapability.resolve();
            });
            readableStream.on("end", function () {
              readableStream.destroy();
              _this50._done = true;
              _this50._readCapability.resolve();
            });
            readableStream.on("error", function (reason) {
              _this50._error(reason);
            });
            if (this._storedError) {
              this._readableStream.destroy(this._storedError);
            }
          }
        }]);
      }();
      function createRequestOptions(parsedUrl, headers) {
        return {
          protocol: parsedUrl.protocol,
          auth: parsedUrl.auth,
          host: parsedUrl.hostname,
          port: parsedUrl.port,
          path: parsedUrl.path,
          method: "GET",
          headers: headers
        };
      }
      var PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {
        function PDFNodeStreamFullReader(stream) {
          var _this51;
          _classCallCheck(this, PDFNodeStreamFullReader);
          _this51 = _callSuper(this, PDFNodeStreamFullReader, [stream]);
          var handleResponse = function handleResponse(response) {
            if (response.statusCode === 404) {
              var error = new _util.MissingPDFException("Missing PDF \"".concat(_this51._url, "\"."));
              _this51._storedError = error;
              _this51._headersCapability.reject(error);
              return;
            }
            _this51._headersCapability.resolve();
            _this51._setReadableStream(response);
            var getResponseHeader = function getResponseHeader(name) {
              return _this51._readableStream.headers[name.toLowerCase()];
            };
            var _ref63 = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader: getResponseHeader,
                isHttp: stream.isHttp,
                rangeChunkSize: _this51._rangeChunkSize,
                disableRange: _this51._disableRange
              }),
              allowRangeRequests = _ref63.allowRangeRequests,
              suggestedLength = _ref63.suggestedLength;
            _this51._isRangeSupported = allowRangeRequests;
            _this51._contentLength = suggestedLength || _this51._contentLength;
            _this51._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
          };
          _this51._request = null;
          if (_this51._url.protocol === "http:") {
            var http = require("http");
            _this51._request = http.request(createRequestOptions(_this51._url, stream.httpHeaders), handleResponse);
          } else {
            var https = require("https");
            _this51._request = https.request(createRequestOptions(_this51._url, stream.httpHeaders), handleResponse);
          }
          _this51._request.on("error", function (reason) {
            _this51._storedError = reason;
            _this51._headersCapability.reject(reason);
          });
          _this51._request.end();
          return _this51;
        }
        _inherits(PDFNodeStreamFullReader, _BaseFullReader);
        return _createClass(PDFNodeStreamFullReader);
      }(BaseFullReader);
      var PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {
        function PDFNodeStreamRangeReader(stream, start, end) {
          var _this52;
          _classCallCheck(this, PDFNodeStreamRangeReader);
          _this52 = _callSuper(this, PDFNodeStreamRangeReader, [stream]);
          _this52._httpHeaders = {};
          for (var property in stream.httpHeaders) {
            var value = stream.httpHeaders[property];
            if (value === undefined) {
              continue;
            }
            _this52._httpHeaders[property] = value;
          }
          _this52._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1);
          var handleResponse = function handleResponse(response) {
            if (response.statusCode === 404) {
              var error = new _util.MissingPDFException("Missing PDF \"".concat(_this52._url, "\"."));
              _this52._storedError = error;
              return;
            }
            _this52._setReadableStream(response);
          };
          _this52._request = null;
          if (_this52._url.protocol === "http:") {
            var http = require("http");
            _this52._request = http.request(createRequestOptions(_this52._url, _this52._httpHeaders), handleResponse);
          } else {
            var https = require("https");
            _this52._request = https.request(createRequestOptions(_this52._url, _this52._httpHeaders), handleResponse);
          }
          _this52._request.on("error", function (reason) {
            _this52._storedError = reason;
          });
          _this52._request.end();
          return _this52;
        }
        _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);
        return _createClass(PDFNodeStreamRangeReader);
      }(BaseRangeReader);
      var PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {
        function PDFNodeStreamFsFullReader(stream) {
          var _this53;
          _classCallCheck(this, PDFNodeStreamFsFullReader);
          _this53 = _callSuper(this, PDFNodeStreamFsFullReader, [stream]);
          var path = decodeURIComponent(_this53._url.path);
          if (fileUriRegex.test(_this53._url.href)) {
            path = path.replace(/^\//, "");
          }
          var fs = require("fs");
          fs.lstat(path, function (error, stat) {
            if (error) {
              if (error.code === "ENOENT") {
                error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\"."));
              }
              _this53._storedError = error;
              _this53._headersCapability.reject(error);
              return;
            }
            _this53._contentLength = stat.size;
            _this53._setReadableStream(fs.createReadStream(path));
            _this53._headersCapability.resolve();
          });
          return _this53;
        }
        _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);
        return _createClass(PDFNodeStreamFsFullReader);
      }(BaseFullReader);
      var PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {
        function PDFNodeStreamFsRangeReader(stream, start, end) {
          var _this54;
          _classCallCheck(this, PDFNodeStreamFsRangeReader);
          _this54 = _callSuper(this, PDFNodeStreamFsRangeReader, [stream]);
          var path = decodeURIComponent(_this54._url.path);
          if (fileUriRegex.test(_this54._url.href)) {
            path = path.replace(/^\//, "");
          }
          var fs = require("fs");
          _this54._setReadableStream(fs.createReadStream(path, {
            start: start,
            end: end - 1
          }));
          return _this54;
        }
        _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);
        return _createClass(PDFNodeStreamFsRangeReader);
      }(BaseRangeReader);
      /***/
    }), (/* 24 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SVGGraphics = void 0;
      var _display_utils = __w_pdfjs_require__(6);
      var _util = __w_pdfjs_require__(1);
      ;
      var SVG_DEFAULTS = {
        fontStyle: "normal",
        fontWeight: "normal",
        fillColor: "#000000"
      };
      var XML_NS = "http://www.w3.org/XML/1998/namespace";
      var XLINK_NS = "http://www.w3.org/1999/xlink";
      var LINE_CAP_STYLES = ["butt", "round", "square"];
      var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
      var createObjectURL = function createObjectURL(data) {
        var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
          return URL.createObjectURL(new Blob([data], {
            type: contentType
          }));
        }
        var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var buffer = "data:".concat(contentType, ";base64,");
        for (var i = 0, ii = data.length; i < ii; i += 3) {
          var b1 = data[i] & 0xff;
          var b2 = data[i + 1] & 0xff;
          var b3 = data[i + 2] & 0xff;
          var d1 = b1 >> 2,
            d2 = (b1 & 3) << 4 | b2 >> 4;
          var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
          var d4 = i + 2 < ii ? b3 & 0x3f : 64;
          buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
        }
        return buffer;
      };
      var convertImgDataToPng = function () {
        var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
        var CHUNK_WRAPPER_SIZE = 12;
        var crcTable = new Int32Array(256);
        for (var i = 0; i < 256; i++) {
          var c = i;
          for (var h = 0; h < 8; h++) {
            c = c & 1 ? 0xedb88320 ^ c >> 1 & 0x7fffffff : c >> 1 & 0x7fffffff;
          }
          crcTable[i] = c;
        }
        function crc32(data, start, end) {
          var crc = -1;
          for (var _i13 = start; _i13 < end; _i13++) {
            var a = (crc ^ data[_i13]) & 0xff;
            var b = crcTable[a];
            crc = crc >>> 8 ^ b;
          }
          return crc ^ -1;
        }
        function writePngChunk(type, body, data, offset) {
          var p = offset;
          var len = body.length;
          data[p] = len >> 24 & 0xff;
          data[p + 1] = len >> 16 & 0xff;
          data[p + 2] = len >> 8 & 0xff;
          data[p + 3] = len & 0xff;
          p += 4;
          data[p] = type.charCodeAt(0) & 0xff;
          data[p + 1] = type.charCodeAt(1) & 0xff;
          data[p + 2] = type.charCodeAt(2) & 0xff;
          data[p + 3] = type.charCodeAt(3) & 0xff;
          p += 4;
          data.set(body, p);
          p += body.length;
          var crc = crc32(data, offset + 4, p);
          data[p] = crc >> 24 & 0xff;
          data[p + 1] = crc >> 16 & 0xff;
          data[p + 2] = crc >> 8 & 0xff;
          data[p + 3] = crc & 0xff;
        }
        function adler32(data, start, end) {
          var a = 1;
          var b = 0;
          for (var _i14 = start; _i14 < end; ++_i14) {
            a = (a + (data[_i14] & 0xff)) % 65521;
            b = (b + a) % 65521;
          }
          return b << 16 | a;
        }
        function deflateSync(literals) {
          if (!_util.isNodeJS) {
            return deflateSyncUncompressed(literals);
          }
          try {
            var input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);
            var output = require("zlib").deflateSync(input, {
              level: 9
            });
            return output instanceof Uint8Array ? output : new Uint8Array(output);
          } catch (e) {
            (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
          }
          return deflateSyncUncompressed(literals);
        }
        function deflateSyncUncompressed(literals) {
          var len = literals.length;
          var maxBlockLength = 0xffff;
          var deflateBlocks = Math.ceil(len / maxBlockLength);
          var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
          var pi = 0;
          idat[pi++] = 0x78;
          idat[pi++] = 0x9c;
          var pos = 0;
          while (len > maxBlockLength) {
            idat[pi++] = 0x00;
            idat[pi++] = 0xff;
            idat[pi++] = 0xff;
            idat[pi++] = 0x00;
            idat[pi++] = 0x00;
            idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
            pi += maxBlockLength;
            pos += maxBlockLength;
            len -= maxBlockLength;
          }
          idat[pi++] = 0x01;
          idat[pi++] = len & 0xff;
          idat[pi++] = len >> 8 & 0xff;
          idat[pi++] = ~len & 0xffff & 0xff;
          idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
          idat.set(literals.subarray(pos), pi);
          pi += literals.length - pos;
          var adler = adler32(literals, 0, literals.length);
          idat[pi++] = adler >> 24 & 0xff;
          idat[pi++] = adler >> 16 & 0xff;
          idat[pi++] = adler >> 8 & 0xff;
          idat[pi++] = adler & 0xff;
          return idat;
        }
        function encode(imgData, kind, forceDataSchema, isMask) {
          var width = imgData.width;
          var height = imgData.height;
          var bitDepth, colorType, lineSize;
          var bytes = imgData.data;
          switch (kind) {
            case _util.ImageKind.GRAYSCALE_1BPP:
              colorType = 0;
              bitDepth = 1;
              lineSize = width + 7 >> 3;
              break;
            case _util.ImageKind.RGB_24BPP:
              colorType = 2;
              bitDepth = 8;
              lineSize = width * 3;
              break;
            case _util.ImageKind.RGBA_32BPP:
              colorType = 6;
              bitDepth = 8;
              lineSize = width * 4;
              break;
            default:
              throw new Error("invalid format");
          }
          var literals = new Uint8Array((1 + lineSize) * height);
          var offsetLiterals = 0,
            offsetBytes = 0;
          for (var y = 0; y < height; ++y) {
            literals[offsetLiterals++] = 0;
            literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
            offsetBytes += lineSize;
            offsetLiterals += lineSize;
          }
          if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
            offsetLiterals = 0;
            for (var _y2 = 0; _y2 < height; _y2++) {
              offsetLiterals++;
              for (var _i15 = 0; _i15 < lineSize; _i15++) {
                literals[offsetLiterals++] ^= 0xff;
              }
            }
          }
          var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
          var idat = deflateSync(literals);
          var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
          var data = new Uint8Array(pngLength);
          var offset = 0;
          data.set(PNG_HEADER, offset);
          offset += PNG_HEADER.length;
          writePngChunk("IHDR", ihdr, data, offset);
          offset += CHUNK_WRAPPER_SIZE + ihdr.length;
          writePngChunk("IDATA", idat, data, offset);
          offset += CHUNK_WRAPPER_SIZE + idat.length;
          writePngChunk("IEND", new Uint8Array(0), data, offset);
          return createObjectURL(data, "image/png", forceDataSchema);
        }
        return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
          var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
          return encode(imgData, kind, forceDataSchema, isMask);
        };
      }();
      var SVGExtraState = /*#__PURE__*/function () {
        function SVGExtraState() {
          _classCallCheck(this, SVGExtraState);
          this.fontSizeScale = 1;
          this.fontWeight = SVG_DEFAULTS.fontWeight;
          this.fontSize = 0;
          this.textMatrix = _util.IDENTITY_MATRIX;
          this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
          this.leading = 0;
          this.textRenderingMode = _util.TextRenderingMode.FILL;
          this.textMatrixScale = 1;
          this.x = 0;
          this.y = 0;
          this.lineX = 0;
          this.lineY = 0;
          this.charSpacing = 0;
          this.wordSpacing = 0;
          this.textHScale = 1;
          this.textRise = 0;
          this.fillColor = SVG_DEFAULTS.fillColor;
          this.strokeColor = "#000000";
          this.fillAlpha = 1;
          this.strokeAlpha = 1;
          this.lineWidth = 1;
          this.lineJoin = "";
          this.lineCap = "";
          this.miterLimit = 0;
          this.dashArray = [];
          this.dashPhase = 0;
          this.dependencies = [];
          this.activeClipUrl = null;
          this.clipGroup = null;
          this.maskId = "";
        }
        return _createClass(SVGExtraState, [{
          key: "clone",
          value: function clone() {
            return Object.create(this);
          }
        }, {
          key: "setCurrentPoint",
          value: function setCurrentPoint(x, y) {
            this.x = x;
            this.y = y;
          }
        }]);
      }();
      function opListToTree(opList) {
        var opTree = [];
        var tmp = [];
        var _iterator95 = _createForOfIteratorHelper(opList),
          _step95;
        try {
          for (_iterator95.s(); !(_step95 = _iterator95.n()).done;) {
            var opListElement = _step95.value;
            if (opListElement.fn === "save") {
              opTree.push({
                fnId: 92,
                fn: "group",
                items: []
              });
              tmp.push(opTree);
              opTree = opTree.at(-1).items;
              continue;
            }
            if (opListElement.fn === "restore") {
              opTree = tmp.pop();
            } else {
              opTree.push(opListElement);
            }
          }
        } catch (err) {
          _iterator95.e(err);
        } finally {
          _iterator95.f();
        }
        return opTree;
      }
      function pf(value) {
        if (Number.isInteger(value)) {
          return value.toString();
        }
        var s = value.toFixed(10);
        var i = s.length - 1;
        if (s[i] !== "0") {
          return s;
        }
        do {
          i--;
        } while (s[i] === "0");
        return s.substring(0, s[i] === "." ? i : i + 1);
      }
      function pm(m) {
        if (m[4] === 0 && m[5] === 0) {
          if (m[1] === 0 && m[2] === 0) {
            if (m[0] === 1 && m[3] === 1) {
              return "";
            }
            return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
          }
          if (m[0] === m[3] && m[1] === -m[2]) {
            var a = Math.acos(m[0]) * 180 / Math.PI;
            return "rotate(".concat(pf(a), ")");
          }
        } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
          return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
        }
        return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
      }
      var clipCount = 0;
      var maskCount = 0;
      var shadingCount = 0;
      var SVGGraphics = /*#__PURE__*/function () {
        function SVGGraphics(commonObjs, objs) {
          var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          _classCallCheck(this, SVGGraphics);
          (0, _display_utils.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
          this.svgFactory = new _display_utils.DOMSVGFactory();
          this.current = new SVGExtraState();
          this.transformMatrix = _util.IDENTITY_MATRIX;
          this.transformStack = [];
          this.extraStack = [];
          this.commonObjs = commonObjs;
          this.objs = objs;
          this.pendingClip = null;
          this.pendingEOFill = false;
          this.embedFonts = false;
          this.embeddedFonts = Object.create(null);
          this.cssStyle = null;
          this.forceDataSchema = !!forceDataSchema;
          this._operatorIdMapping = [];
          for (var op in _util.OPS) {
            this._operatorIdMapping[_util.OPS[op]] = op;
          }
        }
        return _createClass(SVGGraphics, [{
          key: "getObject",
          value: function getObject(data) {
            var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (typeof data === "string") {
              return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
            }
            return fallback;
          }
        }, {
          key: "save",
          value: function save() {
            this.transformStack.push(this.transformMatrix);
            var old = this.current;
            this.extraStack.push(old);
            this.current = old.clone();
          }
        }, {
          key: "restore",
          value: function restore() {
            this.transformMatrix = this.transformStack.pop();
            this.current = this.extraStack.pop();
            this.pendingClip = null;
            this.tgrp = null;
          }
        }, {
          key: "group",
          value: function group(items) {
            this.save();
            this.executeOpTree(items);
            this.restore();
          }
        }, {
          key: "loadDependencies",
          value: function loadDependencies(operatorList) {
            var _this55 = this;
            var fnArray = operatorList.fnArray;
            var argsArray = operatorList.argsArray;
            for (var i = 0, ii = fnArray.length; i < ii; i++) {
              if (fnArray[i] !== _util.OPS.dependency) {
                continue;
              }
              var _iterator96 = _createForOfIteratorHelper(argsArray[i]),
                _step96;
              try {
                var _loop = function _loop() {
                  var obj = _step96.value;
                  var objsPool = obj.startsWith("g_") ? _this55.commonObjs : _this55.objs;
                  var promise = new Promise(function (resolve) {
                    objsPool.get(obj, resolve);
                  });
                  _this55.current.dependencies.push(promise);
                };
                for (_iterator96.s(); !(_step96 = _iterator96.n()).done;) {
                  _loop();
                }
              } catch (err) {
                _iterator96.e(err);
              } finally {
                _iterator96.f();
              }
            }
            return Promise.all(this.current.dependencies);
          }
        }, {
          key: "transform",
          value: function transform(a, b, c, d, e, f) {
            var transformMatrix = [a, b, c, d, e, f];
            this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
            this.tgrp = null;
          }
        }, {
          key: "getSVG",
          value: function getSVG(operatorList, viewport) {
            var _this56 = this;
            this.viewport = viewport;
            var svgElement = this._initialize(viewport);
            return this.loadDependencies(operatorList).then(function () {
              _this56.transformMatrix = _util.IDENTITY_MATRIX;
              _this56.executeOpTree(_this56.convertOpList(operatorList));
              return svgElement;
            });
          }
        }, {
          key: "convertOpList",
          value: function convertOpList(operatorList) {
            var operatorIdMapping = this._operatorIdMapping;
            var argsArray = operatorList.argsArray;
            var fnArray = operatorList.fnArray;
            var opList = [];
            for (var i = 0, ii = fnArray.length; i < ii; i++) {
              var fnId = fnArray[i];
              opList.push({
                fnId: fnId,
                fn: operatorIdMapping[fnId],
                args: argsArray[i]
              });
            }
            return opListToTree(opList);
          }
        }, {
          key: "executeOpTree",
          value: function executeOpTree(opTree) {
            var _iterator97 = _createForOfIteratorHelper(opTree),
              _step97;
            try {
              for (_iterator97.s(); !(_step97 = _iterator97.n()).done;) {
                var opTreeElement = _step97.value;
                var fn = opTreeElement.fn;
                var fnId = opTreeElement.fnId;
                var args = opTreeElement.args;
                switch (fnId | 0) {
                  case _util.OPS.beginText:
                    this.beginText();
                    break;
                  case _util.OPS.dependency:
                    break;
                  case _util.OPS.setLeading:
                    this.setLeading(args);
                    break;
                  case _util.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(args[0], args[1]);
                    break;
                  case _util.OPS.setFont:
                    this.setFont(args);
                    break;
                  case _util.OPS.showText:
                    this.showText(args[0]);
                    break;
                  case _util.OPS.showSpacedText:
                    this.showText(args[0]);
                    break;
                  case _util.OPS.endText:
                    this.endText();
                    break;
                  case _util.OPS.moveText:
                    this.moveText(args[0], args[1]);
                    break;
                  case _util.OPS.setCharSpacing:
                    this.setCharSpacing(args[0]);
                    break;
                  case _util.OPS.setWordSpacing:
                    this.setWordSpacing(args[0]);
                    break;
                  case _util.OPS.setHScale:
                    this.setHScale(args[0]);
                    break;
                  case _util.OPS.setTextMatrix:
                    this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                    break;
                  case _util.OPS.setTextRise:
                    this.setTextRise(args[0]);
                    break;
                  case _util.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(args[0]);
                    break;
                  case _util.OPS.setLineWidth:
                    this.setLineWidth(args[0]);
                    break;
                  case _util.OPS.setLineJoin:
                    this.setLineJoin(args[0]);
                    break;
                  case _util.OPS.setLineCap:
                    this.setLineCap(args[0]);
                    break;
                  case _util.OPS.setMiterLimit:
                    this.setMiterLimit(args[0]);
                    break;
                  case _util.OPS.setFillRGBColor:
                    this.setFillRGBColor(args[0], args[1], args[2]);
                    break;
                  case _util.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(args[0], args[1], args[2]);
                    break;
                  case _util.OPS.setStrokeColorN:
                    this.setStrokeColorN(args);
                    break;
                  case _util.OPS.setFillColorN:
                    this.setFillColorN(args);
                    break;
                  case _util.OPS.shadingFill:
                    this.shadingFill(args[0]);
                    break;
                  case _util.OPS.setDash:
                    this.setDash(args[0], args[1]);
                    break;
                  case _util.OPS.setRenderingIntent:
                    this.setRenderingIntent(args[0]);
                    break;
                  case _util.OPS.setFlatness:
                    this.setFlatness(args[0]);
                    break;
                  case _util.OPS.setGState:
                    this.setGState(args[0]);
                    break;
                  case _util.OPS.fill:
                    this.fill();
                    break;
                  case _util.OPS.eoFill:
                    this.eoFill();
                    break;
                  case _util.OPS.stroke:
                    this.stroke();
                    break;
                  case _util.OPS.fillStroke:
                    this.fillStroke();
                    break;
                  case _util.OPS.eoFillStroke:
                    this.eoFillStroke();
                    break;
                  case _util.OPS.clip:
                    this.clip("nonzero");
                    break;
                  case _util.OPS.eoClip:
                    this.clip("evenodd");
                    break;
                  case _util.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask();
                    break;
                  case _util.OPS.paintImageXObject:
                    this.paintImageXObject(args[0]);
                    break;
                  case _util.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(args[0]);
                    break;
                  case _util.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(args[0]);
                    break;
                  case _util.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(args[0], args[1]);
                    break;
                  case _util.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd();
                    break;
                  case _util.OPS.closePath:
                    this.closePath();
                    break;
                  case _util.OPS.closeStroke:
                    this.closeStroke();
                    break;
                  case _util.OPS.closeFillStroke:
                    this.closeFillStroke();
                    break;
                  case _util.OPS.closeEOFillStroke:
                    this.closeEOFillStroke();
                    break;
                  case _util.OPS.nextLine:
                    this.nextLine();
                    break;
                  case _util.OPS.transform:
                    this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                    break;
                  case _util.OPS.constructPath:
                    this.constructPath(args[0], args[1]);
                    break;
                  case _util.OPS.endPath:
                    this.endPath();
                    break;
                  case 92:
                    this.group(opTreeElement.items);
                    break;
                  default:
                    (0, _util.warn)("Unimplemented operator ".concat(fn));
                    break;
                }
              }
            } catch (err) {
              _iterator97.e(err);
            } finally {
              _iterator97.f();
            }
          }
        }, {
          key: "setWordSpacing",
          value: function setWordSpacing(wordSpacing) {
            this.current.wordSpacing = wordSpacing;
          }
        }, {
          key: "setCharSpacing",
          value: function setCharSpacing(charSpacing) {
            this.current.charSpacing = charSpacing;
          }
        }, {
          key: "nextLine",
          value: function nextLine() {
            this.moveText(0, this.current.leading);
          }
        }, {
          key: "setTextMatrix",
          value: function setTextMatrix(a, b, c, d, e, f) {
            var current = this.current;
            current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
            current.textMatrixScale = Math.hypot(a, b);
            current.x = current.lineX = 0;
            current.y = current.lineY = 0;
            current.xcoords = [];
            current.ycoords = [];
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
            current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
            current.tspan.setAttributeNS(null, "y", pf(-current.y));
            current.txtElement = this.svgFactory.createElement("svg:text");
            current.txtElement.append(current.tspan);
          }
        }, {
          key: "beginText",
          value: function beginText() {
            var current = this.current;
            current.x = current.lineX = 0;
            current.y = current.lineY = 0;
            current.textMatrix = _util.IDENTITY_MATRIX;
            current.lineMatrix = _util.IDENTITY_MATRIX;
            current.textMatrixScale = 1;
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.txtElement = this.svgFactory.createElement("svg:text");
            current.txtgrp = this.svgFactory.createElement("svg:g");
            current.xcoords = [];
            current.ycoords = [];
          }
        }, {
          key: "moveText",
          value: function moveText(x, y) {
            var current = this.current;
            current.x = current.lineX += x;
            current.y = current.lineY += y;
            current.xcoords = [];
            current.ycoords = [];
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
            current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
            current.tspan.setAttributeNS(null, "y", pf(-current.y));
          }
        }, {
          key: "showText",
          value: function showText(glyphs) {
            var current = this.current;
            var font = current.font;
            var fontSize = current.fontSize;
            if (fontSize === 0) {
              return;
            }
            var fontSizeScale = current.fontSizeScale;
            var charSpacing = current.charSpacing;
            var wordSpacing = current.wordSpacing;
            var fontDirection = current.fontDirection;
            var textHScale = current.textHScale * fontDirection;
            var vertical = font.vertical;
            var spacingDir = vertical ? 1 : -1;
            var defaultVMetrics = font.defaultVMetrics;
            var widthAdvanceScale = fontSize * current.fontMatrix[0];
            var x = 0;
            var _iterator98 = _createForOfIteratorHelper(glyphs),
              _step98;
            try {
              for (_iterator98.s(); !(_step98 = _iterator98.n()).done;) {
                var glyph = _step98.value;
                if (glyph === null) {
                  x += fontDirection * wordSpacing;
                  continue;
                } else if (typeof glyph === "number") {
                  x += spacingDir * glyph * fontSize / 1000;
                  continue;
                }
                var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                var character = glyph.fontChar;
                var scaledX = void 0,
                  scaledY = void 0;
                var width = glyph.width;
                if (vertical) {
                  var vx = void 0;
                  var vmetric = glyph.vmetric || defaultVMetrics;
                  vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                  vx = -vx * widthAdvanceScale;
                  var vy = vmetric[2] * widthAdvanceScale;
                  width = vmetric ? -vmetric[0] : width;
                  scaledX = vx / fontSizeScale;
                  scaledY = (x + vy) / fontSizeScale;
                } else {
                  scaledX = x / fontSizeScale;
                  scaledY = 0;
                }
                if (glyph.isInFont || font.missingFile) {
                  current.xcoords.push(current.x + scaledX);
                  if (vertical) {
                    current.ycoords.push(-current.y + scaledY);
                  }
                  current.tspan.textContent += character;
                } else {}
                var charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
                x += charWidth;
              }
            } catch (err) {
              _iterator98.e(err);
            } finally {
              _iterator98.f();
            }
            current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
            if (vertical) {
              current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
            } else {
              current.tspan.setAttributeNS(null, "y", pf(-current.y));
            }
            if (vertical) {
              current.y -= x;
            } else {
              current.x += x * textHScale;
            }
            current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
            current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
            if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
              current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
            }
            if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
              current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
            }
            var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                current.tspan.setAttributeNS(null, "fill", current.fillColor);
              }
              if (current.fillAlpha < 1) {
                current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
              }
            } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
              current.tspan.setAttributeNS(null, "fill", "transparent");
            } else {
              current.tspan.setAttributeNS(null, "fill", "none");
            }
            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              var lineWidthScale = 1 / (current.textMatrixScale || 1);
              this._setStrokeAttributes(current.tspan, lineWidthScale);
            }
            var textMatrix = current.textMatrix;
            if (current.textRise !== 0) {
              textMatrix = textMatrix.slice();
              textMatrix[5] += current.textRise;
            }
            current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
            current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
            current.txtElement.append(current.tspan);
            current.txtgrp.append(current.txtElement);
            this._ensureTransformGroup().append(current.txtElement);
          }
        }, {
          key: "setLeadingMoveText",
          value: function setLeadingMoveText(x, y) {
            this.setLeading(-y);
            this.moveText(x, y);
          }
        }, {
          key: "addFontStyle",
          value: function addFontStyle(fontObj) {
            if (!fontObj.data) {
              throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
            }
            if (!this.cssStyle) {
              this.cssStyle = this.svgFactory.createElement("svg:style");
              this.cssStyle.setAttributeNS(null, "type", "text/css");
              this.defs.append(this.cssStyle);
            }
            var url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
            this.cssStyle.textContent += "@font-face { font-family: \"".concat(fontObj.loadedName, "\";") + " src: url(".concat(url, "); }\n");
          }
        }, {
          key: "setFont",
          value: function setFont(details) {
            var current = this.current;
            var fontObj = this.commonObjs.get(details[0]);
            var size = details[1];
            current.font = fontObj;
            if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
              this.addFontStyle(fontObj);
              this.embeddedFonts[fontObj.loadedName] = fontObj;
            }
            current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
            var bold = "normal";
            if (fontObj.black) {
              bold = "900";
            } else if (fontObj.bold) {
              bold = "bold";
            }
            var italic = fontObj.italic ? "italic" : "normal";
            if (size < 0) {
              size = -size;
              current.fontDirection = -1;
            } else {
              current.fontDirection = 1;
            }
            current.fontSize = size;
            current.fontFamily = fontObj.loadedName;
            current.fontWeight = bold;
            current.fontStyle = italic;
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.tspan.setAttributeNS(null, "y", pf(-current.y));
            current.xcoords = [];
            current.ycoords = [];
          }
        }, {
          key: "endText",
          value: function endText() {
            var _current$txtElement;
            var current = this.current;
            if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
              current.element = current.txtElement;
              this.clip("nonzero");
              this.endPath();
            }
          }
        }, {
          key: "setLineWidth",
          value: function setLineWidth(width) {
            if (width > 0) {
              this.current.lineWidth = width;
            }
          }
        }, {
          key: "setLineCap",
          value: function setLineCap(style) {
            this.current.lineCap = LINE_CAP_STYLES[style];
          }
        }, {
          key: "setLineJoin",
          value: function setLineJoin(style) {
            this.current.lineJoin = LINE_JOIN_STYLES[style];
          }
        }, {
          key: "setMiterLimit",
          value: function setMiterLimit(limit) {
            this.current.miterLimit = limit;
          }
        }, {
          key: "setStrokeAlpha",
          value: function setStrokeAlpha(strokeAlpha) {
            this.current.strokeAlpha = strokeAlpha;
          }
        }, {
          key: "setStrokeRGBColor",
          value: function setStrokeRGBColor(r, g, b) {
            this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
          }
        }, {
          key: "setFillAlpha",
          value: function setFillAlpha(fillAlpha) {
            this.current.fillAlpha = fillAlpha;
          }
        }, {
          key: "setFillRGBColor",
          value: function setFillRGBColor(r, g, b) {
            this.current.fillColor = _util.Util.makeHexColor(r, g, b);
            this.current.tspan = this.svgFactory.createElement("svg:tspan");
            this.current.xcoords = [];
            this.current.ycoords = [];
          }
        }, {
          key: "setStrokeColorN",
          value: function setStrokeColorN(args) {
            this.current.strokeColor = this._makeColorN_Pattern(args);
          }
        }, {
          key: "setFillColorN",
          value: function setFillColorN(args) {
            this.current.fillColor = this._makeColorN_Pattern(args);
          }
        }, {
          key: "shadingFill",
          value: function shadingFill(args) {
            var _this$viewport = this.viewport,
              width = _this$viewport.width,
              height = _this$viewport.height;
            var inv = _util.Util.inverseTransform(this.transformMatrix);
            var _util$Util$getAxialAl3 = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv),
              _util$Util$getAxialAl4 = _slicedToArray(_util$Util$getAxialAl3, 4),
              x0 = _util$Util$getAxialAl4[0],
              y0 = _util$Util$getAxialAl4[1],
              x1 = _util$Util$getAxialAl4[2],
              y1 = _util$Util$getAxialAl4[3];
            var rect = this.svgFactory.createElement("svg:rect");
            rect.setAttributeNS(null, "x", x0);
            rect.setAttributeNS(null, "y", y0);
            rect.setAttributeNS(null, "width", x1 - x0);
            rect.setAttributeNS(null, "height", y1 - y0);
            rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
            if (this.current.fillAlpha < 1) {
              rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
            }
            this._ensureTransformGroup().append(rect);
          }
        }, {
          key: "_makeColorN_Pattern",
          value: function _makeColorN_Pattern(args) {
            if (args[0] === "TilingPattern") {
              return this._makeTilingPattern(args);
            }
            return this._makeShadingPattern(args);
          }
        }, {
          key: "_makeTilingPattern",
          value: function _makeTilingPattern(args) {
            var color = args[1];
            var operatorList = args[2];
            var matrix = args[3] || _util.IDENTITY_MATRIX;
            var _args$ = _slicedToArray(args[4], 4),
              x0 = _args$[0],
              y0 = _args$[1],
              x1 = _args$[2],
              y1 = _args$[3];
            var xstep = args[5];
            var ystep = args[6];
            var paintType = args[7];
            var tilingId = "shading".concat(shadingCount++);
            var _util$Util$normalizeR = _util.Util.normalizeRect([].concat(_toConsumableArray(_util.Util.applyTransform([x0, y0], matrix)), _toConsumableArray(_util.Util.applyTransform([x1, y1], matrix)))),
              _util$Util$normalizeR2 = _slicedToArray(_util$Util$normalizeR, 4),
              tx0 = _util$Util$normalizeR2[0],
              ty0 = _util$Util$normalizeR2[1],
              tx1 = _util$Util$normalizeR2[2],
              ty1 = _util$Util$normalizeR2[3];
            var _util$Util$singularVa3 = _util.Util.singularValueDecompose2dScale(matrix),
              _util$Util$singularVa4 = _slicedToArray(_util$Util$singularVa3, 2),
              xscale = _util$Util$singularVa4[0],
              yscale = _util$Util$singularVa4[1];
            var txstep = xstep * xscale;
            var tystep = ystep * yscale;
            var tiling = this.svgFactory.createElement("svg:pattern");
            tiling.setAttributeNS(null, "id", tilingId);
            tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
            tiling.setAttributeNS(null, "width", txstep);
            tiling.setAttributeNS(null, "height", tystep);
            tiling.setAttributeNS(null, "x", "".concat(tx0));
            tiling.setAttributeNS(null, "y", "".concat(ty0));
            var svg = this.svg;
            var transformMatrix = this.transformMatrix;
            var fillColor = this.current.fillColor;
            var strokeColor = this.current.strokeColor;
            var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
            this.svg = bbox;
            this.transformMatrix = matrix;
            if (paintType === 2) {
              var _util$Util4;
              var cssColor = (_util$Util4 = _util.Util).makeHexColor.apply(_util$Util4, _toConsumableArray(color));
              this.current.fillColor = cssColor;
              this.current.strokeColor = cssColor;
            }
            this.executeOpTree(this.convertOpList(operatorList));
            this.svg = svg;
            this.transformMatrix = transformMatrix;
            this.current.fillColor = fillColor;
            this.current.strokeColor = strokeColor;
            tiling.append(bbox.childNodes[0]);
            this.defs.append(tiling);
            return "url(#".concat(tilingId, ")");
          }
        }, {
          key: "_makeShadingPattern",
          value: function _makeShadingPattern(args) {
            if (typeof args === "string") {
              args = this.objs.get(args);
            }
            switch (args[0]) {
              case "RadialAxial":
                var shadingId = "shading".concat(shadingCount++);
                var colorStops = args[3];
                var gradient;
                switch (args[1]) {
                  case "axial":
                    var point0 = args[4];
                    var point1 = args[5];
                    gradient = this.svgFactory.createElement("svg:linearGradient");
                    gradient.setAttributeNS(null, "id", shadingId);
                    gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                    gradient.setAttributeNS(null, "x1", point0[0]);
                    gradient.setAttributeNS(null, "y1", point0[1]);
                    gradient.setAttributeNS(null, "x2", point1[0]);
                    gradient.setAttributeNS(null, "y2", point1[1]);
                    break;
                  case "radial":
                    var focalPoint = args[4];
                    var circlePoint = args[5];
                    var focalRadius = args[6];
                    var circleRadius = args[7];
                    gradient = this.svgFactory.createElement("svg:radialGradient");
                    gradient.setAttributeNS(null, "id", shadingId);
                    gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                    gradient.setAttributeNS(null, "cx", circlePoint[0]);
                    gradient.setAttributeNS(null, "cy", circlePoint[1]);
                    gradient.setAttributeNS(null, "r", circleRadius);
                    gradient.setAttributeNS(null, "fx", focalPoint[0]);
                    gradient.setAttributeNS(null, "fy", focalPoint[1]);
                    gradient.setAttributeNS(null, "fr", focalRadius);
                    break;
                  default:
                    throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                }
                var _iterator99 = _createForOfIteratorHelper(colorStops),
                  _step99;
                try {
                  for (_iterator99.s(); !(_step99 = _iterator99.n()).done;) {
                    var colorStop = _step99.value;
                    var stop = this.svgFactory.createElement("svg:stop");
                    stop.setAttributeNS(null, "offset", colorStop[0]);
                    stop.setAttributeNS(null, "stop-color", colorStop[1]);
                    gradient.append(stop);
                  }
                } catch (err) {
                  _iterator99.e(err);
                } finally {
                  _iterator99.f();
                }
                this.defs.append(gradient);
                return "url(#".concat(shadingId, ")");
              case "Mesh":
                (0, _util.warn)("Unimplemented pattern Mesh");
                return null;
              case "Dummy":
                return "hotpink";
              default:
                throw new Error("Unknown IR type: ".concat(args[0]));
            }
          }
        }, {
          key: "setDash",
          value: function setDash(dashArray, dashPhase) {
            this.current.dashArray = dashArray;
            this.current.dashPhase = dashPhase;
          }
        }, {
          key: "constructPath",
          value: function constructPath(ops, args) {
            var current = this.current;
            var x = current.x,
              y = current.y;
            var d = [];
            var j = 0;
            var _iterator100 = _createForOfIteratorHelper(ops),
              _step100;
            try {
              for (_iterator100.s(); !(_step100 = _iterator100.n()).done;) {
                var op = _step100.value;
                switch (op | 0) {
                  case _util.OPS.rectangle:
                    x = args[j++];
                    y = args[j++];
                    var width = args[j++];
                    var height = args[j++];
                    var xw = x + width;
                    var yh = y + height;
                    d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                    break;
                  case _util.OPS.moveTo:
                    x = args[j++];
                    y = args[j++];
                    d.push("M", pf(x), pf(y));
                    break;
                  case _util.OPS.lineTo:
                    x = args[j++];
                    y = args[j++];
                    d.push("L", pf(x), pf(y));
                    break;
                  case _util.OPS.curveTo:
                    x = args[j + 4];
                    y = args[j + 5];
                    d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                    j += 6;
                    break;
                  case _util.OPS.curveTo2:
                    d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                    x = args[j + 2];
                    y = args[j + 3];
                    j += 4;
                    break;
                  case _util.OPS.curveTo3:
                    x = args[j + 2];
                    y = args[j + 3];
                    d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                    j += 4;
                    break;
                  case _util.OPS.closePath:
                    d.push("Z");
                    break;
                }
              }
            } catch (err) {
              _iterator100.e(err);
            } finally {
              _iterator100.f();
            }
            d = d.join(" ");
            if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
              d = current.path.getAttributeNS(null, "d") + d;
            } else {
              current.path = this.svgFactory.createElement("svg:path");
              this._ensureTransformGroup().append(current.path);
            }
            current.path.setAttributeNS(null, "d", d);
            current.path.setAttributeNS(null, "fill", "none");
            current.element = current.path;
            current.setCurrentPoint(x, y);
          }
        }, {
          key: "endPath",
          value: function endPath() {
            var current = this.current;
            current.path = null;
            if (!this.pendingClip) {
              return;
            }
            if (!current.element) {
              this.pendingClip = null;
              return;
            }
            var clipId = "clippath".concat(clipCount++);
            var clipPath = this.svgFactory.createElement("svg:clipPath");
            clipPath.setAttributeNS(null, "id", clipId);
            clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
            var clipElement = current.element.cloneNode(true);
            if (this.pendingClip === "evenodd") {
              clipElement.setAttributeNS(null, "clip-rule", "evenodd");
            } else {
              clipElement.setAttributeNS(null, "clip-rule", "nonzero");
            }
            this.pendingClip = null;
            clipPath.append(clipElement);
            this.defs.append(clipPath);
            if (current.activeClipUrl) {
              current.clipGroup = null;
              var _iterator101 = _createForOfIteratorHelper(this.extraStack),
                _step101;
              try {
                for (_iterator101.s(); !(_step101 = _iterator101.n()).done;) {
                  var prev = _step101.value;
                  prev.clipGroup = null;
                }
              } catch (err) {
                _iterator101.e(err);
              } finally {
                _iterator101.f();
              }
              clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
            }
            current.activeClipUrl = "url(#".concat(clipId, ")");
            this.tgrp = null;
          }
        }, {
          key: "clip",
          value: function clip(type) {
            this.pendingClip = type;
          }
        }, {
          key: "closePath",
          value: function closePath() {
            var current = this.current;
            if (current.path) {
              var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
              current.path.setAttributeNS(null, "d", d);
            }
          }
        }, {
          key: "setLeading",
          value: function setLeading(leading) {
            this.current.leading = -leading;
          }
        }, {
          key: "setTextRise",
          value: function setTextRise(textRise) {
            this.current.textRise = textRise;
          }
        }, {
          key: "setTextRenderingMode",
          value: function setTextRenderingMode(textRenderingMode) {
            this.current.textRenderingMode = textRenderingMode;
          }
        }, {
          key: "setHScale",
          value: function setHScale(scale) {
            this.current.textHScale = scale / 100;
          }
        }, {
          key: "setRenderingIntent",
          value: function setRenderingIntent(intent) {}
        }, {
          key: "setFlatness",
          value: function setFlatness(flatness) {}
        }, {
          key: "setGState",
          value: function setGState(states) {
            var _iterator102 = _createForOfIteratorHelper(states),
              _step102;
            try {
              for (_iterator102.s(); !(_step102 = _iterator102.n()).done;) {
                var _step102$value = _slicedToArray(_step102.value, 2),
                  key = _step102$value[0],
                  value = _step102$value[1];
                switch (key) {
                  case "LW":
                    this.setLineWidth(value);
                    break;
                  case "LC":
                    this.setLineCap(value);
                    break;
                  case "LJ":
                    this.setLineJoin(value);
                    break;
                  case "ML":
                    this.setMiterLimit(value);
                    break;
                  case "D":
                    this.setDash(value[0], value[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(value);
                    break;
                  case "FL":
                    this.setFlatness(value);
                    break;
                  case "Font":
                    this.setFont(value);
                    break;
                  case "CA":
                    this.setStrokeAlpha(value);
                    break;
                  case "ca":
                    this.setFillAlpha(value);
                    break;
                  default:
                    (0, _util.warn)("Unimplemented graphic state operator ".concat(key));
                    break;
                }
              }
            } catch (err) {
              _iterator102.e(err);
            } finally {
              _iterator102.f();
            }
          }
        }, {
          key: "fill",
          value: function fill() {
            var current = this.current;
            if (current.element) {
              current.element.setAttributeNS(null, "fill", current.fillColor);
              current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
              this.endPath();
            }
          }
        }, {
          key: "stroke",
          value: function stroke() {
            var current = this.current;
            if (current.element) {
              this._setStrokeAttributes(current.element);
              current.element.setAttributeNS(null, "fill", "none");
              this.endPath();
            }
          }
        }, {
          key: "_setStrokeAttributes",
          value: function _setStrokeAttributes(element) {
            var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var current = this.current;
            var dashArray = current.dashArray;
            if (lineWidthScale !== 1 && dashArray.length > 0) {
              dashArray = dashArray.map(function (value) {
                return lineWidthScale * value;
              });
            }
            element.setAttributeNS(null, "stroke", current.strokeColor);
            element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
            element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
            element.setAttributeNS(null, "stroke-linecap", current.lineCap);
            element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
            element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
            element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
            element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
          }
        }, {
          key: "eoFill",
          value: function eoFill() {
            var _this$current$element;
            (_this$current$element = this.current.element) === null || _this$current$element === void 0 || _this$current$element.setAttributeNS(null, "fill-rule", "evenodd");
            this.fill();
          }
        }, {
          key: "fillStroke",
          value: function fillStroke() {
            this.stroke();
            this.fill();
          }
        }, {
          key: "eoFillStroke",
          value: function eoFillStroke() {
            var _this$current$element2;
            (_this$current$element2 = this.current.element) === null || _this$current$element2 === void 0 || _this$current$element2.setAttributeNS(null, "fill-rule", "evenodd");
            this.fillStroke();
          }
        }, {
          key: "closeStroke",
          value: function closeStroke() {
            this.closePath();
            this.stroke();
          }
        }, {
          key: "closeFillStroke",
          value: function closeFillStroke() {
            this.closePath();
            this.fillStroke();
          }
        }, {
          key: "closeEOFillStroke",
          value: function closeEOFillStroke() {
            this.closePath();
            this.eoFillStroke();
          }
        }, {
          key: "paintSolidColorImageMask",
          value: function paintSolidColorImageMask() {
            var rect = this.svgFactory.createElement("svg:rect");
            rect.setAttributeNS(null, "x", "0");
            rect.setAttributeNS(null, "y", "0");
            rect.setAttributeNS(null, "width", "1px");
            rect.setAttributeNS(null, "height", "1px");
            rect.setAttributeNS(null, "fill", this.current.fillColor);
            this._ensureTransformGroup().append(rect);
          }
        }, {
          key: "paintImageXObject",
          value: function paintImageXObject(objId) {
            var imgData = this.getObject(objId);
            if (!imgData) {
              (0, _util.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
              return;
            }
            this.paintInlineImageXObject(imgData);
          }
        }, {
          key: "paintInlineImageXObject",
          value: function paintInlineImageXObject(imgData, mask) {
            var width = imgData.width;
            var height = imgData.height;
            var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
            var cliprect = this.svgFactory.createElement("svg:rect");
            cliprect.setAttributeNS(null, "x", "0");
            cliprect.setAttributeNS(null, "y", "0");
            cliprect.setAttributeNS(null, "width", pf(width));
            cliprect.setAttributeNS(null, "height", pf(height));
            this.current.element = cliprect;
            this.clip("nonzero");
            var imgEl = this.svgFactory.createElement("svg:image");
            imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
            imgEl.setAttributeNS(null, "x", "0");
            imgEl.setAttributeNS(null, "y", pf(-height));
            imgEl.setAttributeNS(null, "width", pf(width) + "px");
            imgEl.setAttributeNS(null, "height", pf(height) + "px");
            imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));
            if (mask) {
              mask.append(imgEl);
            } else {
              this._ensureTransformGroup().append(imgEl);
            }
          }
        }, {
          key: "paintImageMaskXObject",
          value: function paintImageMaskXObject(img) {
            var imgData = this.getObject(img.data, img);
            if (imgData.bitmap) {
              (0, _util.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, " + "ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
              return;
            }
            var current = this.current;
            var width = imgData.width;
            var height = imgData.height;
            var fillColor = current.fillColor;
            current.maskId = "mask".concat(maskCount++);
            var mask = this.svgFactory.createElement("svg:mask");
            mask.setAttributeNS(null, "id", current.maskId);
            var rect = this.svgFactory.createElement("svg:rect");
            rect.setAttributeNS(null, "x", "0");
            rect.setAttributeNS(null, "y", "0");
            rect.setAttributeNS(null, "width", pf(width));
            rect.setAttributeNS(null, "height", pf(height));
            rect.setAttributeNS(null, "fill", fillColor);
            rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
            this.defs.append(mask);
            this._ensureTransformGroup().append(rect);
            this.paintInlineImageXObject(imgData, mask);
          }
        }, {
          key: "paintFormXObjectBegin",
          value: function paintFormXObjectBegin(matrix, bbox) {
            if (Array.isArray(matrix) && matrix.length === 6) {
              this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
            }
            if (bbox) {
              var width = bbox[2] - bbox[0];
              var height = bbox[3] - bbox[1];
              var cliprect = this.svgFactory.createElement("svg:rect");
              cliprect.setAttributeNS(null, "x", bbox[0]);
              cliprect.setAttributeNS(null, "y", bbox[1]);
              cliprect.setAttributeNS(null, "width", pf(width));
              cliprect.setAttributeNS(null, "height", pf(height));
              this.current.element = cliprect;
              this.clip("nonzero");
              this.endPath();
            }
          }
        }, {
          key: "paintFormXObjectEnd",
          value: function paintFormXObjectEnd() {}
        }, {
          key: "_initialize",
          value: function _initialize(viewport) {
            var svg = this.svgFactory.create(viewport.width, viewport.height);
            var definitions = this.svgFactory.createElement("svg:defs");
            svg.append(definitions);
            this.defs = definitions;
            var rootGroup = this.svgFactory.createElement("svg:g");
            rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
            svg.append(rootGroup);
            this.svg = rootGroup;
            return svg;
          }
        }, {
          key: "_ensureClipGroup",
          value: function _ensureClipGroup() {
            if (!this.current.clipGroup) {
              var clipGroup = this.svgFactory.createElement("svg:g");
              clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
              this.svg.append(clipGroup);
              this.current.clipGroup = clipGroup;
            }
            return this.current.clipGroup;
          }
        }, {
          key: "_ensureTransformGroup",
          value: function _ensureTransformGroup() {
            if (!this.tgrp) {
              this.tgrp = this.svgFactory.createElement("svg:g");
              this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
              if (this.current.activeClipUrl) {
                this._ensureClipGroup().append(this.tgrp);
              } else {
                this.svg.append(this.tgrp);
              }
            }
            return this.tgrp;
          }
        }]);
      }();
      exports.SVGGraphics = SVGGraphics;

      /***/
    }), (/* 25 */
    /***/function (__unused_webpack_module, exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.XfaText = void 0;
      var XfaText = /*#__PURE__*/function () {
        function XfaText() {
          _classCallCheck(this, XfaText);
        }
        return _createClass(XfaText, null, [{
          key: "textContent",
          value: function textContent(xfa) {
            var items = [];
            var output = {
              items: items,
              styles: Object.create(null)
            };
            function walk(node) {
              var _node$attributes;
              if (!node) {
                return;
              }
              var str = null;
              var name = node.name;
              if (name === "#text") {
                str = node.value;
              } else if (!XfaText.shouldBuildText(name)) {
                return;
              } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
                str = node.attributes.textContent;
              } else if (node.value) {
                str = node.value;
              }
              if (str !== null) {
                items.push({
                  str: str
                });
              }
              if (!node.children) {
                return;
              }
              var _iterator103 = _createForOfIteratorHelper(node.children),
                _step103;
              try {
                for (_iterator103.s(); !(_step103 = _iterator103.n()).done;) {
                  var child = _step103.value;
                  walk(child);
                }
              } catch (err) {
                _iterator103.e(err);
              } finally {
                _iterator103.f();
              }
            }
            walk(xfa);
            return output;
          }
        }, {
          key: "shouldBuildText",
          value: function shouldBuildText(name) {
            return !(name === "textarea" || name === "input" || name === "option" || name === "select");
          }
        }]);
      }();
      exports.XfaText = XfaText;

      /***/
    }), (/* 26 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TextLayerRenderTask = void 0;
      exports.renderTextLayer = renderTextLayer;
      exports.updateTextLayer = updateTextLayer;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      var MAX_TEXT_DIVS_TO_RENDER = 100000;
      var DEFAULT_FONT_SIZE = 30;
      var DEFAULT_FONT_ASCENT = 0.8;
      var ascentCache = new Map();
      function getCtx(size, isOffscreenCanvasSupported) {
        var ctx;
        if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {
          ctx = new OffscreenCanvas(size, size).getContext("2d", {
            alpha: false
          });
        } else {
          var canvas = document.createElement("canvas");
          canvas.width = canvas.height = size;
          ctx = canvas.getContext("2d", {
            alpha: false
          });
        }
        return ctx;
      }
      function getAscent(fontFamily, isOffscreenCanvasSupported) {
        var cachedAscent = ascentCache.get(fontFamily);
        if (cachedAscent) {
          return cachedAscent;
        }
        var ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);
        ctx.font = "".concat(DEFAULT_FONT_SIZE, "px ").concat(fontFamily);
        var metrics = ctx.measureText("");
        var ascent = metrics.fontBoundingBoxAscent;
        var descent = Math.abs(metrics.fontBoundingBoxDescent);
        if (ascent) {
          var ratio = ascent / (ascent + descent);
          ascentCache.set(fontFamily, ratio);
          ctx.canvas.width = ctx.canvas.height = 0;
          return ratio;
        }
        ctx.strokeStyle = "red";
        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
        ctx.strokeText("g", 0, 0);
        var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
        descent = 0;
        for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {
          if (pixels[i] > 0) {
            descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
            break;
          }
        }
        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
        ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
        ascent = 0;
        for (var _i16 = 0, ii = pixels.length; _i16 < ii; _i16 += 4) {
          if (pixels[_i16] > 0) {
            ascent = DEFAULT_FONT_SIZE - Math.floor(_i16 / 4 / DEFAULT_FONT_SIZE);
            break;
          }
        }
        ctx.canvas.width = ctx.canvas.height = 0;
        if (ascent) {
          var _ratio = ascent / (ascent + descent);
          ascentCache.set(fontFamily, _ratio);
          return _ratio;
        }
        ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
        return DEFAULT_FONT_ASCENT;
      }
      function appendText(task, geom, styles) {
        var textDiv = document.createElement("span");
        var textDivProperties = {
          angle: 0,
          canvasWidth: 0,
          hasText: geom.str !== "",
          hasEOL: geom.hasEOL,
          fontSize: 0
        };
        task._textDivs.push(textDiv);
        var tx = _util.Util.transform(task._transform, geom.transform);
        var angle = Math.atan2(tx[1], tx[0]);
        var style = styles[geom.fontName];
        if (style.vertical) {
          angle += Math.PI / 2;
        }
        var fontHeight = Math.hypot(tx[2], tx[3]);
        var fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);
        var left, top;
        if (angle === 0) {
          left = tx[4];
          top = tx[5] - fontAscent;
        } else {
          left = tx[4] + fontAscent * Math.sin(angle);
          top = tx[5] - fontAscent * Math.cos(angle);
        }
        var scaleFactorStr = "calc(var(--scale-factor)*";
        var divStyle = textDiv.style;
        if (task._container === task._rootContainer) {
          divStyle.left = "".concat((100 * left / task._pageWidth).toFixed(2), "%");
          divStyle.top = "".concat((100 * top / task._pageHeight).toFixed(2), "%");
        } else {
          divStyle.left = "".concat(scaleFactorStr).concat(left.toFixed(2), "px)");
          divStyle.top = "".concat(scaleFactorStr).concat(top.toFixed(2), "px)");
        }
        divStyle.fontSize = "".concat(scaleFactorStr).concat(fontHeight.toFixed(2), "px)");
        divStyle.fontFamily = style.fontFamily;
        textDivProperties.fontSize = fontHeight;
        textDiv.setAttribute("role", "presentation");
        textDiv.textContent = geom.str;
        textDiv.dir = geom.dir;
        if (task._fontInspectorEnabled) {
          textDiv.dataset.fontName = geom.fontName;
        }
        if (angle !== 0) {
          textDivProperties.angle = angle * (180 / Math.PI);
        }
        var shouldScaleText = false;
        if (geom.str.length > 1) {
          shouldScaleText = true;
        } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
          var absScaleX = Math.abs(geom.transform[0]),
            absScaleY = Math.abs(geom.transform[3]);
          if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
            shouldScaleText = true;
          }
        }
        if (shouldScaleText) {
          textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
        }
        task._textDivProperties.set(textDiv, textDivProperties);
        if (task._isReadableStream) {
          task._layoutText(textDiv);
        }
      }
      function layout(params) {
        var div = params.div,
          scale = params.scale,
          properties = params.properties,
          ctx = params.ctx,
          prevFontSize = params.prevFontSize,
          prevFontFamily = params.prevFontFamily;
        var style = div.style;
        var transform = "";
        if (properties.canvasWidth !== 0 && properties.hasText) {
          var fontFamily = style.fontFamily;
          var canvasWidth = properties.canvasWidth,
            fontSize = properties.fontSize;
          if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
            ctx.font = "".concat(fontSize * scale, "px ").concat(fontFamily);
            params.prevFontSize = fontSize;
            params.prevFontFamily = fontFamily;
          }
          var _ctx$measureText = ctx.measureText(div.textContent),
            width = _ctx$measureText.width;
          if (width > 0) {
            transform = "scaleX(".concat(canvasWidth * scale / width, ")");
          }
        }
        if (properties.angle !== 0) {
          transform = "rotate(".concat(properties.angle, "deg) ").concat(transform);
        }
        if (transform.length > 0) {
          style.transform = transform;
        }
      }
      function render(task) {
        if (task._canceled) {
          return;
        }
        var textDivs = task._textDivs;
        var capability = task._capability;
        var textDivsLength = textDivs.length;
        if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
          capability.resolve();
          return;
        }
        if (!task._isReadableStream) {
          var _iterator104 = _createForOfIteratorHelper(textDivs),
            _step104;
          try {
            for (_iterator104.s(); !(_step104 = _iterator104.n()).done;) {
              var textDiv = _step104.value;
              task._layoutText(textDiv);
            }
          } catch (err) {
            _iterator104.e(err);
          } finally {
            _iterator104.f();
          }
        }
        capability.resolve();
      }
      var TextLayerRenderTask = /*#__PURE__*/function () {
        function TextLayerRenderTask(_ref64) {
          var _globalThis$FontInspe2,
            _this57 = this;
          var textContentSource = _ref64.textContentSource,
            container = _ref64.container,
            viewport = _ref64.viewport,
            textDivs = _ref64.textDivs,
            textDivProperties = _ref64.textDivProperties,
            textContentItemsStr = _ref64.textContentItemsStr,
            isOffscreenCanvasSupported = _ref64.isOffscreenCanvasSupported;
          _classCallCheck(this, TextLayerRenderTask);
          this._textContentSource = textContentSource;
          this._isReadableStream = textContentSource instanceof ReadableStream;
          this._container = this._rootContainer = container;
          this._textDivs = textDivs || [];
          this._textContentItemsStr = textContentItemsStr || [];
          this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;
          this._fontInspectorEnabled = !!((_globalThis$FontInspe2 = globalThis.FontInspector) !== null && _globalThis$FontInspe2 !== void 0 && _globalThis$FontInspe2.enabled);
          this._reader = null;
          this._textDivProperties = textDivProperties || new WeakMap();
          this._canceled = false;
          this._capability = new _util.PromiseCapability();
          this._layoutTextParams = {
            prevFontSize: null,
            prevFontFamily: null,
            div: null,
            scale: viewport.scale * (globalThis.devicePixelRatio || 1),
            properties: null,
            ctx: getCtx(0, isOffscreenCanvasSupported)
          };
          var _viewport$rawDims2 = viewport.rawDims,
            pageWidth = _viewport$rawDims2.pageWidth,
            pageHeight = _viewport$rawDims2.pageHeight,
            pageX = _viewport$rawDims2.pageX,
            pageY = _viewport$rawDims2.pageY;
          this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
          this._pageWidth = pageWidth;
          this._pageHeight = pageHeight;
          (0, _display_utils.setLayerDimensions)(container, viewport);
          this._capability.promise.finally(function () {
            _this57._layoutTextParams = null;
          }).catch(function () {});
        }
        return _createClass(TextLayerRenderTask, [{
          key: "promise",
          get: function get() {
            return this._capability.promise;
          }
        }, {
          key: "cancel",
          value: function cancel() {
            this._canceled = true;
            if (this._reader) {
              this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(function () {});
              this._reader = null;
            }
            this._capability.reject(new _util.AbortException("TextLayer task cancelled."));
          }
        }, {
          key: "_processItems",
          value: function _processItems(items, styleCache) {
            var _iterator105 = _createForOfIteratorHelper(items),
              _step105;
            try {
              for (_iterator105.s(); !(_step105 = _iterator105.n()).done;) {
                var item = _step105.value;
                if (item.str === undefined) {
                  if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
                    var parent = this._container;
                    this._container = document.createElement("span");
                    this._container.classList.add("markedContent");
                    if (item.id !== null) {
                      this._container.setAttribute("id", "".concat(item.id));
                    }
                    parent.append(this._container);
                  } else if (item.type === "endMarkedContent") {
                    this._container = this._container.parentNode;
                  }
                  continue;
                }
                this._textContentItemsStr.push(item.str);
                appendText(this, item, styleCache);
              }
            } catch (err) {
              _iterator105.e(err);
            } finally {
              _iterator105.f();
            }
          }
        }, {
          key: "_layoutText",
          value: function _layoutText(textDiv) {
            var textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);
            this._layoutTextParams.div = textDiv;
            layout(this._layoutTextParams);
            if (textDivProperties.hasText) {
              this._container.append(textDiv);
            }
            if (textDivProperties.hasEOL) {
              var br = document.createElement("br");
              br.setAttribute("role", "presentation");
              this._container.append(br);
            }
          }
        }, {
          key: "_render",
          value: function _render() {
            var _this58 = this;
            var capability = new _util.PromiseCapability();
            var styleCache = Object.create(null);
            if (this._isReadableStream) {
              var _pump2 = function pump() {
                _this58._reader.read().then(function (_ref65) {
                  var value = _ref65.value,
                    done = _ref65.done;
                  if (done) {
                    capability.resolve();
                    return;
                  }
                  Object.assign(styleCache, value.styles);
                  _this58._processItems(value.items, styleCache);
                  _pump2();
                }, capability.reject);
              };
              this._reader = this._textContentSource.getReader();
              _pump2();
            } else if (this._textContentSource) {
              var _this$_textContentSou = this._textContentSource,
                items = _this$_textContentSou.items,
                styles = _this$_textContentSou.styles;
              this._processItems(items, styles);
              capability.resolve();
            } else {
              throw new Error('No "textContentSource" parameter specified.');
            }
            capability.promise.then(function () {
              styleCache = null;
              render(_this58);
            }, this._capability.reject);
          }
        }]);
      }();
      exports.TextLayerRenderTask = TextLayerRenderTask;
      function renderTextLayer(params) {
        if (!params.textContentSource && (params.textContent || params.textContentStream)) {
          (0, _display_utils.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters " + "will be removed in the future, please use `textContentSource` instead.");
          params.textContentSource = params.textContent || params.textContentStream;
        }
        var container = params.container,
          viewport = params.viewport;
        var style = getComputedStyle(container);
        var visibility = style.getPropertyValue("visibility");
        var scaleFactor = parseFloat(style.getPropertyValue("--scale-factor"));
        if (visibility === "visible" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {
          console.error("The `--scale-factor` CSS-variable must be set, " + "to the same value as `viewport.scale`, " + "either on the `container`-element itself or higher up in the DOM.");
        }
        var task = new TextLayerRenderTask(params);
        task._render();
        return task;
      }
      function updateTextLayer(_ref66) {
        var container = _ref66.container,
          viewport = _ref66.viewport,
          textDivs = _ref66.textDivs,
          textDivProperties = _ref66.textDivProperties,
          isOffscreenCanvasSupported = _ref66.isOffscreenCanvasSupported,
          _ref66$mustRotate = _ref66.mustRotate,
          mustRotate = _ref66$mustRotate === void 0 ? true : _ref66$mustRotate,
          _ref66$mustRescale = _ref66.mustRescale,
          mustRescale = _ref66$mustRescale === void 0 ? true : _ref66$mustRescale;
        if (mustRotate) {
          (0, _display_utils.setLayerDimensions)(container, {
            rotation: viewport.rotation
          });
        }
        if (mustRescale) {
          var ctx = getCtx(0, isOffscreenCanvasSupported);
          var scale = viewport.scale * (globalThis.devicePixelRatio || 1);
          var params = {
            prevFontSize: null,
            prevFontFamily: null,
            div: null,
            scale: scale,
            properties: null,
            ctx: ctx
          };
          var _iterator106 = _createForOfIteratorHelper(textDivs),
            _step106;
          try {
            for (_iterator106.s(); !(_step106 = _iterator106.n()).done;) {
              var div = _step106.value;
              params.properties = textDivProperties.get(div);
              params.div = div;
              layout(params);
            }
          } catch (err) {
            _iterator106.e(err);
          } finally {
            _iterator106.f();
          }
        }
      }

      /***/
    }), (/* 27 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnnotationEditorLayer = void 0;
      var _util = __w_pdfjs_require__(1);
      var _editor = __w_pdfjs_require__(4);
      var _freetext = __w_pdfjs_require__(28);
      var _ink = __w_pdfjs_require__(33);
      var _display_utils = __w_pdfjs_require__(6);
      var _stamp = __w_pdfjs_require__(34);
      var _accessibilityManager = /*#__PURE__*/new WeakMap();
      var _allowClick = /*#__PURE__*/new WeakMap();
      var _annotationLayer = /*#__PURE__*/new WeakMap();
      var _boundPointerup = /*#__PURE__*/new WeakMap();
      var _boundPointerdown = /*#__PURE__*/new WeakMap();
      var _editors = /*#__PURE__*/new WeakMap();
      var _hadPointerDown = /*#__PURE__*/new WeakMap();
      var _isCleaningUp = /*#__PURE__*/new WeakMap();
      var _isDisabling = /*#__PURE__*/new WeakMap();
      var _uiManager = /*#__PURE__*/new WeakMap();
      var _AnnotationEditorLayer_brand = /*#__PURE__*/new WeakSet();
      var AnnotationEditorLayer = /*#__PURE__*/function () {
        function AnnotationEditorLayer(_ref67) {
          var uiManager = _ref67.uiManager,
            pageIndex = _ref67.pageIndex,
            div = _ref67.div,
            accessibilityManager = _ref67.accessibilityManager,
            annotationLayer = _ref67.annotationLayer,
            viewport = _ref67.viewport,
            l10n = _ref67.l10n;
          _classCallCheck(this, AnnotationEditorLayer);
          _classPrivateMethodInitSpec(this, _AnnotationEditorLayer_brand);
          _classPrivateFieldInitSpec(this, _accessibilityManager, void 0);
          _classPrivateFieldInitSpec(this, _allowClick, false);
          _classPrivateFieldInitSpec(this, _annotationLayer, null);
          _classPrivateFieldInitSpec(this, _boundPointerup, this.pointerup.bind(this));
          _classPrivateFieldInitSpec(this, _boundPointerdown, this.pointerdown.bind(this));
          _classPrivateFieldInitSpec(this, _editors, new Map());
          _classPrivateFieldInitSpec(this, _hadPointerDown, false);
          _classPrivateFieldInitSpec(this, _isCleaningUp, false);
          _classPrivateFieldInitSpec(this, _isDisabling, false);
          _classPrivateFieldInitSpec(this, _uiManager, void 0);
          var editorTypes = [_freetext.FreeTextEditor, _ink.InkEditor, _stamp.StampEditor];
          if (!AnnotationEditorLayer._initialized) {
            AnnotationEditorLayer._initialized = true;
            var _iterator107 = _createForOfIteratorHelper(editorTypes),
              _step107;
            try {
              for (_iterator107.s(); !(_step107 = _iterator107.n()).done;) {
                var editorType = _step107.value;
                editorType.initialize(l10n);
              }
            } catch (err) {
              _iterator107.e(err);
            } finally {
              _iterator107.f();
            }
          }
          uiManager.registerEditorTypes(editorTypes);
          _classPrivateFieldSet(_uiManager, this, uiManager);
          this.pageIndex = pageIndex;
          this.div = div;
          _classPrivateFieldSet(_accessibilityManager, this, accessibilityManager);
          _classPrivateFieldSet(_annotationLayer, this, annotationLayer);
          this.viewport = viewport;
          _classPrivateFieldGet(_uiManager, this).addLayer(this);
        }
        return _createClass(AnnotationEditorLayer, [{
          key: "isEmpty",
          get: function get() {
            return _classPrivateFieldGet(_editors, this).size === 0;
          }
        }, {
          key: "updateToolbar",
          value: function updateToolbar(mode) {
            _classPrivateFieldGet(_uiManager, this).updateToolbar(mode);
          }
        }, {
          key: "updateMode",
          value: function updateMode() {
            var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(_uiManager, this).getMode();
            _assertClassBrand(_AnnotationEditorLayer_brand, this, _cleanup).call(this);
            if (mode === _util.AnnotationEditorType.INK) {
              this.addInkEditorIfNeeded(false);
              this.disableClick();
            } else {
              this.enableClick();
            }
            if (mode !== _util.AnnotationEditorType.NONE) {
              this.div.classList.toggle("freeTextEditing", mode === _util.AnnotationEditorType.FREETEXT);
              this.div.classList.toggle("inkEditing", mode === _util.AnnotationEditorType.INK);
              this.div.classList.toggle("stampEditing", mode === _util.AnnotationEditorType.STAMP);
              this.div.hidden = false;
            }
          }
        }, {
          key: "addInkEditorIfNeeded",
          value: function addInkEditorIfNeeded(isCommitting) {
            if (!isCommitting && _classPrivateFieldGet(_uiManager, this).getMode() !== _util.AnnotationEditorType.INK) {
              return;
            }
            if (!isCommitting) {
              var _iterator108 = _createForOfIteratorHelper(_classPrivateFieldGet(_editors, this).values()),
                _step108;
              try {
                for (_iterator108.s(); !(_step108 = _iterator108.n()).done;) {
                  var _editor2 = _step108.value;
                  if (_editor2.isEmpty()) {
                    _editor2.setInBackground();
                    return;
                  }
                }
              } catch (err) {
                _iterator108.e(err);
              } finally {
                _iterator108.f();
              }
            }
            var editor = _assertClassBrand(_AnnotationEditorLayer_brand, this, _createAndAddNewEditor).call(this, {
              offsetX: 0,
              offsetY: 0
            }, false);
            editor.setInBackground();
          }
        }, {
          key: "setEditingState",
          value: function setEditingState(isEditing) {
            _classPrivateFieldGet(_uiManager, this).setEditingState(isEditing);
          }
        }, {
          key: "addCommands",
          value: function addCommands(params) {
            _classPrivateFieldGet(_uiManager, this).addCommands(params);
          }
        }, {
          key: "enable",
          value: function enable() {
            this.div.style.pointerEvents = "auto";
            var annotationElementIds = new Set();
            var _iterator109 = _createForOfIteratorHelper(_classPrivateFieldGet(_editors, this).values()),
              _step109;
            try {
              for (_iterator109.s(); !(_step109 = _iterator109.n()).done;) {
                var editor = _step109.value;
                editor.enableEditing();
                if (editor.annotationElementId) {
                  annotationElementIds.add(editor.annotationElementId);
                }
              }
            } catch (err) {
              _iterator109.e(err);
            } finally {
              _iterator109.f();
            }
            if (!_classPrivateFieldGet(_annotationLayer, this)) {
              return;
            }
            var editables = _classPrivateFieldGet(_annotationLayer, this).getEditableAnnotations();
            var _iterator110 = _createForOfIteratorHelper(editables),
              _step110;
            try {
              for (_iterator110.s(); !(_step110 = _iterator110.n()).done;) {
                var editable = _step110.value;
                editable.hide();
                if (_classPrivateFieldGet(_uiManager, this).isDeletedAnnotationElement(editable.data.id)) {
                  continue;
                }
                if (annotationElementIds.has(editable.data.id)) {
                  continue;
                }
                var _editor3 = this.deserialize(editable);
                if (!_editor3) {
                  continue;
                }
                this.addOrRebuild(_editor3);
                _editor3.enableEditing();
              }
            } catch (err) {
              _iterator110.e(err);
            } finally {
              _iterator110.f();
            }
          }
        }, {
          key: "disable",
          value: function disable() {
            _classPrivateFieldSet(_isDisabling, this, true);
            this.div.style.pointerEvents = "none";
            var hiddenAnnotationIds = new Set();
            var _iterator111 = _createForOfIteratorHelper(_classPrivateFieldGet(_editors, this).values()),
              _step111;
            try {
              for (_iterator111.s(); !(_step111 = _iterator111.n()).done;) {
                var _this$getEditableAnno;
                var editor = _step111.value;
                editor.disableEditing();
                if (!editor.annotationElementId || editor.serialize() !== null) {
                  hiddenAnnotationIds.add(editor.annotationElementId);
                  continue;
                }
                (_this$getEditableAnno = this.getEditableAnnotation(editor.annotationElementId)) === null || _this$getEditableAnno === void 0 || _this$getEditableAnno.show();
                editor.remove();
              }
            } catch (err) {
              _iterator111.e(err);
            } finally {
              _iterator111.f();
            }
            if (_classPrivateFieldGet(_annotationLayer, this)) {
              var editables = _classPrivateFieldGet(_annotationLayer, this).getEditableAnnotations();
              var _iterator112 = _createForOfIteratorHelper(editables),
                _step112;
              try {
                for (_iterator112.s(); !(_step112 = _iterator112.n()).done;) {
                  var editable = _step112.value;
                  var id = editable.data.id;
                  if (hiddenAnnotationIds.has(id) || _classPrivateFieldGet(_uiManager, this).isDeletedAnnotationElement(id)) {
                    continue;
                  }
                  editable.show();
                }
              } catch (err) {
                _iterator112.e(err);
              } finally {
                _iterator112.f();
              }
            }
            _assertClassBrand(_AnnotationEditorLayer_brand, this, _cleanup).call(this);
            if (this.isEmpty) {
              this.div.hidden = true;
            }
            _classPrivateFieldSet(_isDisabling, this, false);
          }
        }, {
          key: "getEditableAnnotation",
          value: function getEditableAnnotation(id) {
            var _classPrivateFieldGet21;
            return ((_classPrivateFieldGet21 = _classPrivateFieldGet(_annotationLayer, this)) === null || _classPrivateFieldGet21 === void 0 ? void 0 : _classPrivateFieldGet21.getEditableAnnotation(id)) || null;
          }
        }, {
          key: "setActiveEditor",
          value: function setActiveEditor(editor) {
            var currentActive = _classPrivateFieldGet(_uiManager, this).getActive();
            if (currentActive === editor) {
              return;
            }
            _classPrivateFieldGet(_uiManager, this).setActiveEditor(editor);
          }
        }, {
          key: "enableClick",
          value: function enableClick() {
            this.div.addEventListener("pointerdown", _classPrivateFieldGet(_boundPointerdown, this));
            this.div.addEventListener("pointerup", _classPrivateFieldGet(_boundPointerup, this));
          }
        }, {
          key: "disableClick",
          value: function disableClick() {
            this.div.removeEventListener("pointerdown", _classPrivateFieldGet(_boundPointerdown, this));
            this.div.removeEventListener("pointerup", _classPrivateFieldGet(_boundPointerup, this));
          }
        }, {
          key: "attach",
          value: function attach(editor) {
            _classPrivateFieldGet(_editors, this).set(editor.id, editor);
            var annotationElementId = editor.annotationElementId;
            if (annotationElementId && _classPrivateFieldGet(_uiManager, this).isDeletedAnnotationElement(annotationElementId)) {
              _classPrivateFieldGet(_uiManager, this).removeDeletedAnnotationElement(editor);
            }
          }
        }, {
          key: "detach",
          value: function detach(editor) {
            var _classPrivateFieldGet22;
            _classPrivateFieldGet(_editors, this).delete(editor.id);
            (_classPrivateFieldGet22 = _classPrivateFieldGet(_accessibilityManager, this)) === null || _classPrivateFieldGet22 === void 0 || _classPrivateFieldGet22.removePointerInTextLayer(editor.contentDiv);
            if (!_classPrivateFieldGet(_isDisabling, this) && editor.annotationElementId) {
              _classPrivateFieldGet(_uiManager, this).addDeletedAnnotationElement(editor);
            }
          }
        }, {
          key: "remove",
          value: function remove(editor) {
            var _this59 = this;
            this.detach(editor);
            _classPrivateFieldGet(_uiManager, this).removeEditor(editor);
            if (editor.div.contains(document.activeElement)) {
              setTimeout(function () {
                _classPrivateFieldGet(_uiManager, _this59).focusMainContainer();
              }, 0);
            }
            editor.div.remove();
            editor.isAttachedToDOM = false;
            if (!_classPrivateFieldGet(_isCleaningUp, this)) {
              this.addInkEditorIfNeeded(false);
            }
          }
        }, {
          key: "changeParent",
          value: function changeParent(editor) {
            var _editor$parent;
            if (editor.parent === this) {
              return;
            }
            if (editor.annotationElementId) {
              _classPrivateFieldGet(_uiManager, this).addDeletedAnnotationElement(editor.annotationElementId);
              _editor.AnnotationEditor.deleteAnnotationElement(editor);
              editor.annotationElementId = null;
            }
            this.attach(editor);
            (_editor$parent = editor.parent) === null || _editor$parent === void 0 || _editor$parent.detach(editor);
            editor.setParent(this);
            if (editor.div && editor.isAttachedToDOM) {
              editor.div.remove();
              this.div.append(editor.div);
            }
          }
        }, {
          key: "add",
          value: function add(editor) {
            this.changeParent(editor);
            _classPrivateFieldGet(_uiManager, this).addEditor(editor);
            this.attach(editor);
            if (!editor.isAttachedToDOM) {
              var div = editor.render();
              this.div.append(div);
              editor.isAttachedToDOM = true;
            }
            editor.fixAndSetPosition();
            editor.onceAdded();
            _classPrivateFieldGet(_uiManager, this).addToAnnotationStorage(editor);
          }
        }, {
          key: "moveEditorInDOM",
          value: function moveEditorInDOM(editor) {
            var _classPrivateFieldGet23;
            if (!editor.isAttachedToDOM) {
              return;
            }
            var _document5 = document,
              activeElement = _document5.activeElement;
            if (editor.div.contains(activeElement)) {
              editor._focusEventsAllowed = false;
              setTimeout(function () {
                if (!editor.div.contains(document.activeElement)) {
                  editor.div.addEventListener("focusin", function () {
                    editor._focusEventsAllowed = true;
                  }, {
                    once: true
                  });
                  activeElement.focus();
                } else {
                  editor._focusEventsAllowed = true;
                }
              }, 0);
            }
            editor._structTreeParentId = (_classPrivateFieldGet23 = _classPrivateFieldGet(_accessibilityManager, this)) === null || _classPrivateFieldGet23 === void 0 ? void 0 : _classPrivateFieldGet23.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
          }
        }, {
          key: "addOrRebuild",
          value: function addOrRebuild(editor) {
            if (editor.needsToBeRebuilt()) {
              editor.rebuild();
            } else {
              this.add(editor);
            }
          }
        }, {
          key: "addUndoableEditor",
          value: function addUndoableEditor(editor) {
            var cmd = function cmd() {
              return editor._uiManager.rebuild(editor);
            };
            var undo = function undo() {
              editor.remove();
            };
            this.addCommands({
              cmd: cmd,
              undo: undo,
              mustExec: false
            });
          }
        }, {
          key: "getNextId",
          value: function getNextId() {
            return _classPrivateFieldGet(_uiManager, this).getId();
          }
        }, {
          key: "pasteEditor",
          value: function pasteEditor(mode, params) {
            _classPrivateFieldGet(_uiManager, this).updateToolbar(mode);
            _classPrivateFieldGet(_uiManager, this).updateMode(mode);
            var _assertClassBrand$cal5 = _assertClassBrand(_AnnotationEditorLayer_brand, this, _getCenterPoint).call(this),
              offsetX = _assertClassBrand$cal5.offsetX,
              offsetY = _assertClassBrand$cal5.offsetY;
            var id = this.getNextId();
            var editor = _assertClassBrand(_AnnotationEditorLayer_brand, this, _createNewEditor).call(this, _objectSpread({
              parent: this,
              id: id,
              x: offsetX,
              y: offsetY,
              uiManager: _classPrivateFieldGet(_uiManager, this),
              isCentered: true
            }, params));
            if (editor) {
              this.add(editor);
            }
          }
        }, {
          key: "deserialize",
          value: function deserialize(data) {
            var _data$annotationType;
            switch ((_data$annotationType = data.annotationType) !== null && _data$annotationType !== void 0 ? _data$annotationType : data.annotationEditorType) {
              case _util.AnnotationEditorType.FREETEXT:
                return _freetext.FreeTextEditor.deserialize(data, this, _classPrivateFieldGet(_uiManager, this));
              case _util.AnnotationEditorType.INK:
                return _ink.InkEditor.deserialize(data, this, _classPrivateFieldGet(_uiManager, this));
              case _util.AnnotationEditorType.STAMP:
                return _stamp.StampEditor.deserialize(data, this, _classPrivateFieldGet(_uiManager, this));
            }
            return null;
          }
        }, {
          key: "addNewEditor",
          value: function addNewEditor() {
            _assertClassBrand(_AnnotationEditorLayer_brand, this, _createAndAddNewEditor).call(this, _assertClassBrand(_AnnotationEditorLayer_brand, this, _getCenterPoint).call(this), true);
          }
        }, {
          key: "setSelected",
          value: function setSelected(editor) {
            _classPrivateFieldGet(_uiManager, this).setSelected(editor);
          }
        }, {
          key: "toggleSelected",
          value: function toggleSelected(editor) {
            _classPrivateFieldGet(_uiManager, this).toggleSelected(editor);
          }
        }, {
          key: "isSelected",
          value: function isSelected(editor) {
            return _classPrivateFieldGet(_uiManager, this).isSelected(editor);
          }
        }, {
          key: "unselect",
          value: function unselect(editor) {
            _classPrivateFieldGet(_uiManager, this).unselect(editor);
          }
        }, {
          key: "pointerup",
          value: function pointerup(event) {
            var isMac = _util.FeatureTest.platform.isMac;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              return;
            }
            if (event.target !== this.div) {
              return;
            }
            if (!_classPrivateFieldGet(_hadPointerDown, this)) {
              return;
            }
            _classPrivateFieldSet(_hadPointerDown, this, false);
            if (!_classPrivateFieldGet(_allowClick, this)) {
              _classPrivateFieldSet(_allowClick, this, true);
              return;
            }
            if (_classPrivateFieldGet(_uiManager, this).getMode() === _util.AnnotationEditorType.STAMP) {
              _classPrivateFieldGet(_uiManager, this).unselectAll();
              return;
            }
            _assertClassBrand(_AnnotationEditorLayer_brand, this, _createAndAddNewEditor).call(this, event, false);
          }
        }, {
          key: "pointerdown",
          value: function pointerdown(event) {
            if (_classPrivateFieldGet(_hadPointerDown, this)) {
              _classPrivateFieldSet(_hadPointerDown, this, false);
              return;
            }
            var isMac = _util.FeatureTest.platform.isMac;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              return;
            }
            if (event.target !== this.div) {
              return;
            }
            _classPrivateFieldSet(_hadPointerDown, this, true);
            var editor = _classPrivateFieldGet(_uiManager, this).getActive();
            _classPrivateFieldSet(_allowClick, this, !editor || editor.isEmpty());
          }
        }, {
          key: "findNewParent",
          value: function findNewParent(editor, x, y) {
            var layer = _classPrivateFieldGet(_uiManager, this).findParent(x, y);
            if (layer === null || layer === this) {
              return false;
            }
            layer.changeParent(editor);
            return true;
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var _classPrivateFieldGet24;
            if (((_classPrivateFieldGet24 = _classPrivateFieldGet(_uiManager, this).getActive()) === null || _classPrivateFieldGet24 === void 0 ? void 0 : _classPrivateFieldGet24.parent) === this) {
              _classPrivateFieldGet(_uiManager, this).commitOrRemove();
              _classPrivateFieldGet(_uiManager, this).setActiveEditor(null);
            }
            var _iterator113 = _createForOfIteratorHelper(_classPrivateFieldGet(_editors, this).values()),
              _step113;
            try {
              for (_iterator113.s(); !(_step113 = _iterator113.n()).done;) {
                var _classPrivateFieldGet25;
                var editor = _step113.value;
                (_classPrivateFieldGet25 = _classPrivateFieldGet(_accessibilityManager, this)) === null || _classPrivateFieldGet25 === void 0 || _classPrivateFieldGet25.removePointerInTextLayer(editor.contentDiv);
                editor.setParent(null);
                editor.isAttachedToDOM = false;
                editor.div.remove();
              }
            } catch (err) {
              _iterator113.e(err);
            } finally {
              _iterator113.f();
            }
            this.div = null;
            _classPrivateFieldGet(_editors, this).clear();
            _classPrivateFieldGet(_uiManager, this).removeLayer(this);
          }
        }, {
          key: "render",
          value: function render(_ref68) {
            var viewport = _ref68.viewport;
            this.viewport = viewport;
            (0, _display_utils.setLayerDimensions)(this.div, viewport);
            var _iterator114 = _createForOfIteratorHelper(_classPrivateFieldGet(_uiManager, this).getEditors(this.pageIndex)),
              _step114;
            try {
              for (_iterator114.s(); !(_step114 = _iterator114.n()).done;) {
                var editor = _step114.value;
                this.add(editor);
              }
            } catch (err) {
              _iterator114.e(err);
            } finally {
              _iterator114.f();
            }
            this.updateMode();
          }
        }, {
          key: "update",
          value: function update(_ref69) {
            var viewport = _ref69.viewport;
            _classPrivateFieldGet(_uiManager, this).commitOrRemove();
            this.viewport = viewport;
            (0, _display_utils.setLayerDimensions)(this.div, {
              rotation: viewport.rotation
            });
            this.updateMode();
          }
        }, {
          key: "pageDimensions",
          get: function get() {
            var _this$viewport$rawDim = this.viewport.rawDims,
              pageWidth = _this$viewport$rawDim.pageWidth,
              pageHeight = _this$viewport$rawDim.pageHeight;
            return [pageWidth, pageHeight];
          }
        }]);
      }();
      function _createNewEditor(params) {
        switch (_classPrivateFieldGet(_uiManager, this).getMode()) {
          case _util.AnnotationEditorType.FREETEXT:
            return new _freetext.FreeTextEditor(params);
          case _util.AnnotationEditorType.INK:
            return new _ink.InkEditor(params);
          case _util.AnnotationEditorType.STAMP:
            return new _stamp.StampEditor(params);
        }
        return null;
      }
      function _createAndAddNewEditor(event, isCentered) {
        var id = this.getNextId();
        var editor = _assertClassBrand(_AnnotationEditorLayer_brand, this, _createNewEditor).call(this, {
          parent: this,
          id: id,
          x: event.offsetX,
          y: event.offsetY,
          uiManager: _classPrivateFieldGet(_uiManager, this),
          isCentered: isCentered
        });
        if (editor) {
          this.add(editor);
        }
        return editor;
      }
      function _getCenterPoint() {
        var _this$div$getBounding2 = this.div.getBoundingClientRect(),
          x = _this$div$getBounding2.x,
          y = _this$div$getBounding2.y,
          width = _this$div$getBounding2.width,
          height = _this$div$getBounding2.height;
        var tlX = Math.max(0, x);
        var tlY = Math.max(0, y);
        var brX = Math.min(window.innerWidth, x + width);
        var brY = Math.min(window.innerHeight, y + height);
        var centerX = (tlX + brX) / 2 - x;
        var centerY = (tlY + brY) / 2 - y;
        var _ref70 = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX],
          _ref71 = _slicedToArray(_ref70, 2),
          offsetX = _ref71[0],
          offsetY = _ref71[1];
        return {
          offsetX: offsetX,
          offsetY: offsetY
        };
      }
      function _cleanup() {
        _classPrivateFieldSet(_isCleaningUp, this, true);
        var _iterator115 = _createForOfIteratorHelper(_classPrivateFieldGet(_editors, this).values()),
          _step115;
        try {
          for (_iterator115.s(); !(_step115 = _iterator115.n()).done;) {
            var editor = _step115.value;
            if (editor.isEmpty()) {
              editor.remove();
            }
          }
        } catch (err) {
          _iterator115.e(err);
        } finally {
          _iterator115.f();
        }
        _classPrivateFieldSet(_isCleaningUp, this, false);
      }
      _defineProperty(AnnotationEditorLayer, "_initialized", false);
      exports.AnnotationEditorLayer = AnnotationEditorLayer;

      /***/
    }), (/* 28 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      var _FreeTextEditor;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FreeTextEditor = void 0;
      var _util = __w_pdfjs_require__(1);
      var _tools = __w_pdfjs_require__(5);
      var _editor = __w_pdfjs_require__(4);
      var _annotation_layer = __w_pdfjs_require__(29);
      var _boundEditorDivBlur = /*#__PURE__*/new WeakMap();
      var _boundEditorDivFocus = /*#__PURE__*/new WeakMap();
      var _boundEditorDivInput = /*#__PURE__*/new WeakMap();
      var _boundEditorDivKeydown = /*#__PURE__*/new WeakMap();
      var _color = /*#__PURE__*/new WeakMap();
      var _content = /*#__PURE__*/new WeakMap();
      var _editorDivId = /*#__PURE__*/new WeakMap();
      var _fontSize = /*#__PURE__*/new WeakMap();
      var _initialData = /*#__PURE__*/new WeakMap();
      var _FreeTextEditor_brand = /*#__PURE__*/new WeakSet();
      var FreeTextEditor = /*#__PURE__*/function (_editor$AnnotationEdi) {
        function FreeTextEditor(params) {
          var _this60;
          _classCallCheck(this, FreeTextEditor);
          _this60 = _callSuper(this, FreeTextEditor, [_objectSpread(_objectSpread({}, params), {}, {
            name: "freeTextEditor"
          })]);
          _classPrivateMethodInitSpec(_this60, _FreeTextEditor_brand);
          _classPrivateFieldInitSpec(_this60, _boundEditorDivBlur, _this60.editorDivBlur.bind(_this60));
          _classPrivateFieldInitSpec(_this60, _boundEditorDivFocus, _this60.editorDivFocus.bind(_this60));
          _classPrivateFieldInitSpec(_this60, _boundEditorDivInput, _this60.editorDivInput.bind(_this60));
          _classPrivateFieldInitSpec(_this60, _boundEditorDivKeydown, _this60.editorDivKeydown.bind(_this60));
          _classPrivateFieldInitSpec(_this60, _color, void 0);
          _classPrivateFieldInitSpec(_this60, _content, "");
          _classPrivateFieldInitSpec(_this60, _editorDivId, "".concat(_this60.id, "-editor"));
          _classPrivateFieldInitSpec(_this60, _fontSize, void 0);
          _classPrivateFieldInitSpec(_this60, _initialData, null);
          _classPrivateFieldSet(_color, _this60, params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
          _classPrivateFieldSet(_fontSize, _this60, params.fontSize || FreeTextEditor._defaultFontSize);
          return _this60;
        }
        _inherits(FreeTextEditor, _editor$AnnotationEdi);
        return _createClass(FreeTextEditor, [{
          key: "updateParams",
          value: function updateParams(type, value) {
            switch (type) {
              case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
                _assertClassBrand(_FreeTextEditor_brand, this, _updateFontSize).call(this, value);
                break;
              case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
                _assertClassBrand(_FreeTextEditor_brand, this, _updateColor).call(this, value);
                break;
            }
          }
        }, {
          key: "propertiesToUpdate",
          get: function get() {
            return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, _classPrivateFieldGet(_fontSize, this)], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, _classPrivateFieldGet(_color, this)]];
          }
        }, {
          key: "_translateEmpty",
          value: function _translateEmpty(x, y) {
            this._uiManager.translateSelectedEditors(x, y, true);
          }
        }, {
          key: "getInitialTranslation",
          value: function getInitialTranslation() {
            var scale = this.parentScale;
            return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + _classPrivateFieldGet(_fontSize, this)) * scale];
          }
        }, {
          key: "rebuild",
          value: function rebuild() {
            if (!this.parent) {
              return;
            }
            _superPropGet(FreeTextEditor, "rebuild", this, 3)([]);
            if (this.div === null) {
              return;
            }
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
            }
          }
        }, {
          key: "enableEditMode",
          value: function enableEditMode() {
            if (this.isInEditMode()) {
              return;
            }
            this.parent.setEditingState(false);
            this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);
            _superPropGet(FreeTextEditor, "enableEditMode", this, 3)([]);
            this.overlayDiv.classList.remove("enabled");
            this.editorDiv.contentEditable = true;
            this._isDraggable = false;
            this.div.removeAttribute("aria-activedescendant");
            this.editorDiv.addEventListener("keydown", _classPrivateFieldGet(_boundEditorDivKeydown, this));
            this.editorDiv.addEventListener("focus", _classPrivateFieldGet(_boundEditorDivFocus, this));
            this.editorDiv.addEventListener("blur", _classPrivateFieldGet(_boundEditorDivBlur, this));
            this.editorDiv.addEventListener("input", _classPrivateFieldGet(_boundEditorDivInput, this));
          }
        }, {
          key: "disableEditMode",
          value: function disableEditMode() {
            if (!this.isInEditMode()) {
              return;
            }
            this.parent.setEditingState(true);
            _superPropGet(FreeTextEditor, "disableEditMode", this, 3)([]);
            this.overlayDiv.classList.add("enabled");
            this.editorDiv.contentEditable = false;
            this.div.setAttribute("aria-activedescendant", _classPrivateFieldGet(_editorDivId, this));
            this._isDraggable = true;
            this.editorDiv.removeEventListener("keydown", _classPrivateFieldGet(_boundEditorDivKeydown, this));
            this.editorDiv.removeEventListener("focus", _classPrivateFieldGet(_boundEditorDivFocus, this));
            this.editorDiv.removeEventListener("blur", _classPrivateFieldGet(_boundEditorDivBlur, this));
            this.editorDiv.removeEventListener("input", _classPrivateFieldGet(_boundEditorDivInput, this));
            this.div.focus({
              preventScroll: true
            });
            this.isEditing = false;
            this.parent.div.classList.add("freeTextEditing");
          }
        }, {
          key: "focusin",
          value: function focusin(event) {
            if (!this._focusEventsAllowed) {
              return;
            }
            _superPropGet(FreeTextEditor, "focusin", this, 3)([event]);
            if (event.target !== this.editorDiv) {
              this.editorDiv.focus();
            }
          }
        }, {
          key: "onceAdded",
          value: function onceAdded() {
            var _this$_initialOptions;
            if (this.width) {
              _assertClassBrand(_FreeTextEditor_brand, this, _cheatInitialRect).call(this);
              return;
            }
            this.enableEditMode();
            this.editorDiv.focus();
            if ((_this$_initialOptions = this._initialOptions) !== null && _this$_initialOptions !== void 0 && _this$_initialOptions.isCentered) {
              this.center();
            }
            this._initialOptions = null;
          }
        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return !this.editorDiv || this.editorDiv.innerText.trim() === "";
          }
        }, {
          key: "remove",
          value: function remove() {
            this.isEditing = false;
            if (this.parent) {
              this.parent.setEditingState(true);
              this.parent.div.classList.add("freeTextEditing");
            }
            _superPropGet(FreeTextEditor, "remove", this, 3)([]);
          }
        }, {
          key: "commit",
          value: function commit() {
            var _this61 = this;
            if (!this.isInEditMode()) {
              return;
            }
            _superPropGet(FreeTextEditor, "commit", this, 3)([]);
            this.disableEditMode();
            var savedText = _classPrivateFieldGet(_content, this);
            var newText = _classPrivateFieldSet(_content, this, _assertClassBrand(_FreeTextEditor_brand, this, _extractText).call(this).trimEnd());
            if (savedText === newText) {
              return;
            }
            var setText = function setText(text) {
              _classPrivateFieldSet(_content, _this61, text);
              if (!text) {
                _this61.remove();
                return;
              }
              _assertClassBrand(_FreeTextEditor_brand, _this61, _setContent).call(_this61);
              _this61._uiManager.rebuild(_this61);
              _assertClassBrand(_FreeTextEditor_brand, _this61, _setEditorDimensions).call(_this61);
            };
            this.addCommands({
              cmd: function cmd() {
                setText(newText);
              },
              undo: function undo() {
                setText(savedText);
              },
              mustExec: false
            });
            _assertClassBrand(_FreeTextEditor_brand, this, _setEditorDimensions).call(this);
          }
        }, {
          key: "shouldGetKeyboardEvents",
          value: function shouldGetKeyboardEvents() {
            return this.isInEditMode();
          }
        }, {
          key: "enterInEditMode",
          value: function enterInEditMode() {
            this.enableEditMode();
            this.editorDiv.focus();
          }
        }, {
          key: "dblclick",
          value: function dblclick(event) {
            this.enterInEditMode();
          }
        }, {
          key: "keydown",
          value: function keydown(event) {
            if (event.target === this.div && event.key === "Enter") {
              this.enterInEditMode();
              event.preventDefault();
            }
          }
        }, {
          key: "editorDivKeydown",
          value: function editorDivKeydown(event) {
            FreeTextEditor._keyboardManager.exec(this, event);
          }
        }, {
          key: "editorDivFocus",
          value: function editorDivFocus(event) {
            this.isEditing = true;
          }
        }, {
          key: "editorDivBlur",
          value: function editorDivBlur(event) {
            this.isEditing = false;
          }
        }, {
          key: "editorDivInput",
          value: function editorDivInput(event) {
            this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
          }
        }, {
          key: "disableEditing",
          value: function disableEditing() {
            this.editorDiv.setAttribute("role", "comment");
            this.editorDiv.removeAttribute("aria-multiline");
          }
        }, {
          key: "enableEditing",
          value: function enableEditing() {
            this.editorDiv.setAttribute("role", "textbox");
            this.editorDiv.setAttribute("aria-multiline", true);
          }
        }, {
          key: "render",
          value: function render() {
            var _this62 = this;
            if (this.div) {
              return this.div;
            }
            var baseX, baseY;
            if (this.width) {
              baseX = this.x;
              baseY = this.y;
            }
            _superPropGet(FreeTextEditor, "render", this, 3)([]);
            this.editorDiv = document.createElement("div");
            this.editorDiv.className = "internal";
            this.editorDiv.setAttribute("id", _classPrivateFieldGet(_editorDivId, this));
            this.enableEditing();
            _editor.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then(function (msg) {
              var _this62$editorDiv;
              return (_this62$editorDiv = _this62.editorDiv) === null || _this62$editorDiv === void 0 ? void 0 : _this62$editorDiv.setAttribute("aria-label", msg);
            });
            _editor.AnnotationEditor._l10nPromise.get("free_text2_default_content").then(function (msg) {
              var _this62$editorDiv2;
              return (_this62$editorDiv2 = _this62.editorDiv) === null || _this62$editorDiv2 === void 0 ? void 0 : _this62$editorDiv2.setAttribute("default-content", msg);
            });
            this.editorDiv.contentEditable = true;
            var style = this.editorDiv.style;
            style.fontSize = "calc(".concat(_classPrivateFieldGet(_fontSize, this), "px * var(--scale-factor))");
            style.color = _classPrivateFieldGet(_color, this);
            this.div.append(this.editorDiv);
            this.overlayDiv = document.createElement("div");
            this.overlayDiv.classList.add("overlay", "enabled");
            this.div.append(this.overlayDiv);
            (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
            if (this.width) {
              var _this$parentDimension9 = _slicedToArray(this.parentDimensions, 2),
                parentWidth = _this$parentDimension9[0],
                parentHeight = _this$parentDimension9[1];
              if (this.annotationElementId) {
                var _classPrivateFieldGet26 = _classPrivateFieldGet(_initialData, this),
                  position = _classPrivateFieldGet26.position;
                var _this$getInitialTrans3 = this.getInitialTranslation(),
                  _this$getInitialTrans4 = _slicedToArray(_this$getInitialTrans3, 2),
                  tx = _this$getInitialTrans4[0],
                  ty = _this$getInitialTrans4[1];
                var _this$pageTranslation2 = this.pageTranslationToScreen(tx, ty);
                var _this$pageTranslation3 = _slicedToArray(_this$pageTranslation2, 2);
                tx = _this$pageTranslation3[0];
                ty = _this$pageTranslation3[1];
                var _this$pageDimensions7 = _slicedToArray(this.pageDimensions, 2),
                  pageWidth = _this$pageDimensions7[0],
                  pageHeight = _this$pageDimensions7[1];
                var _this$pageTranslation4 = _slicedToArray(this.pageTranslation, 2),
                  pageX = _this$pageTranslation4[0],
                  pageY = _this$pageTranslation4[1];
                var posX, posY;
                switch (this.rotation) {
                  case 0:
                    posX = baseX + (position[0] - pageX) / pageWidth;
                    posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                    break;
                  case 90:
                    posX = baseX + (position[0] - pageX) / pageWidth;
                    posY = baseY - (position[1] - pageY) / pageHeight;
                    var _ref72 = [ty, -tx];
                    tx = _ref72[0];
                    ty = _ref72[1];
                    break;
                  case 180:
                    posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                    posY = baseY - (position[1] - pageY) / pageHeight;
                    var _ref73 = [-tx, -ty];
                    tx = _ref73[0];
                    ty = _ref73[1];
                    break;
                  case 270:
                    posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
                    posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
                    var _ref74 = [-ty, tx];
                    tx = _ref74[0];
                    ty = _ref74[1];
                    break;
                }
                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
              } else {
                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
              }
              _assertClassBrand(_FreeTextEditor_brand, this, _setContent).call(this);
              this._isDraggable = true;
              this.editorDiv.contentEditable = false;
            } else {
              this._isDraggable = false;
              this.editorDiv.contentEditable = true;
            }
            return this.div;
          }
        }, {
          key: "contentDiv",
          get: function get() {
            return this.editorDiv;
          }
        }, {
          key: "serialize",
          value: function serialize() {
            var isForCopying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (this.isEmpty()) {
              return null;
            }
            if (this.deleted) {
              return {
                pageIndex: this.pageIndex,
                id: this.annotationElementId,
                deleted: true
              };
            }
            var padding = FreeTextEditor._internalPadding * this.parentScale;
            var rect = this.getRect(padding, padding);
            var color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : _classPrivateFieldGet(_color, this));
            var serialized = {
              annotationType: _util.AnnotationEditorType.FREETEXT,
              color: color,
              fontSize: _classPrivateFieldGet(_fontSize, this),
              value: _classPrivateFieldGet(_content, this),
              pageIndex: this.pageIndex,
              rect: rect,
              rotation: this.rotation,
              structTreeParentId: this._structTreeParentId
            };
            if (isForCopying) {
              return serialized;
            }
            if (this.annotationElementId && !_assertClassBrand(_FreeTextEditor_brand, this, _hasElementChanged).call(this, serialized)) {
              return null;
            }
            serialized.id = this.annotationElementId;
            return serialized;
          }
        }], [{
          key: "_keyboardManager",
          get: function get() {
            var proto = FreeTextEditor.prototype;
            var arrowChecker = function arrowChecker(self) {
              return self.isEmpty();
            };
            var small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;
            var big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;
            return (0, _util.shadow)(this, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
              bubbles: true
            }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
              args: [-small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
              args: [-big, 0],
              checker: arrowChecker
            }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
              args: [small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
              args: [big, 0],
              checker: arrowChecker
            }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
              args: [0, -small],
              checker: arrowChecker
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
              args: [0, -big],
              checker: arrowChecker
            }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
              args: [0, small],
              checker: arrowChecker
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
              args: [0, big],
              checker: arrowChecker
            }]]));
          }
        }, {
          key: "initialize",
          value: function initialize(l10n) {
            _editor.AnnotationEditor.initialize(l10n, {
              strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
            });
            var style = getComputedStyle(document.documentElement);
            this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
          }
        }, {
          key: "updateDefaultParams",
          value: function updateDefaultParams(type, value) {
            switch (type) {
              case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
                FreeTextEditor._defaultFontSize = value;
                break;
              case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
                FreeTextEditor._defaultColor = value;
                break;
            }
          }
        }, {
          key: "defaultPropertiesToUpdate",
          get: function get() {
            return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
          }
        }, {
          key: "deserialize",
          value: function deserialize(data, parent, uiManager) {
            var _util$Util5;
            var initialData = null;
            if (data instanceof _annotation_layer.FreeTextAnnotationElement) {
              var _data3 = data,
                _data3$data = _data3.data,
                _data3$data$defaultAp = _data3$data.defaultAppearanceData,
                fontSize = _data3$data$defaultAp.fontSize,
                fontColor = _data3$data$defaultAp.fontColor,
                rect = _data3$data.rect,
                rotation = _data3$data.rotation,
                id = _data3$data.id,
                textContent = _data3.textContent,
                textPosition = _data3.textPosition,
                pageNumber = _data3.parent.page.pageNumber;
              if (!textContent || textContent.length === 0) {
                return null;
              }
              initialData = data = {
                annotationType: _util.AnnotationEditorType.FREETEXT,
                color: Array.from(fontColor),
                fontSize: fontSize,
                value: textContent.join("\n"),
                position: textPosition,
                pageIndex: pageNumber - 1,
                rect: rect,
                rotation: rotation,
                id: id,
                deleted: false
              };
            }
            var editor = _superPropGet(FreeTextEditor, "deserialize", this, 2)([data, parent, uiManager]);
            _classPrivateFieldSet(_fontSize, editor, data.fontSize);
            _classPrivateFieldSet(_color, editor, (_util$Util5 = _util.Util).makeHexColor.apply(_util$Util5, _toConsumableArray(data.color)));
            _classPrivateFieldSet(_content, editor, data.value);
            editor.annotationElementId = data.id || null;
            _classPrivateFieldSet(_initialData, editor, initialData);
            return editor;
          }
        }]);
      }(_editor.AnnotationEditor);
      _FreeTextEditor = FreeTextEditor;
      function _updateFontSize(fontSize) {
        var _this63 = this;
        var setFontsize = function setFontsize(size) {
          _this63.editorDiv.style.fontSize = "calc(".concat(size, "px * var(--scale-factor))");
          _this63.translate(0, -(size - _classPrivateFieldGet(_fontSize, _this63)) * _this63.parentScale);
          _classPrivateFieldSet(_fontSize, _this63, size);
          _assertClassBrand(_FreeTextEditor_brand, _this63, _setEditorDimensions).call(_this63);
        };
        var savedFontsize = _classPrivateFieldGet(_fontSize, this);
        this.addCommands({
          cmd: function cmd() {
            setFontsize(fontSize);
          },
          undo: function undo() {
            setFontsize(savedFontsize);
          },
          mustExec: true,
          type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      function _updateColor(color) {
        var _this64 = this;
        var savedColor = _classPrivateFieldGet(_color, this);
        this.addCommands({
          cmd: function cmd() {
            _classPrivateFieldSet(_color, _this64, _this64.editorDiv.style.color = color);
          },
          undo: function undo() {
            _classPrivateFieldSet(_color, _this64, _this64.editorDiv.style.color = savedColor);
          },
          mustExec: true,
          type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      function _extractText() {
        var divs = this.editorDiv.getElementsByTagName("div");
        if (divs.length === 0) {
          return this.editorDiv.innerText;
        }
        var buffer = [];
        var _iterator116 = _createForOfIteratorHelper(divs),
          _step116;
        try {
          for (_iterator116.s(); !(_step116 = _iterator116.n()).done;) {
            var div = _step116.value;
            buffer.push(div.innerText.replace(/\r\n?|\n/, ""));
          }
        } catch (err) {
          _iterator116.e(err);
        } finally {
          _iterator116.f();
        }
        return buffer.join("\n");
      }
      function _setEditorDimensions() {
        var _this$parentDimension10 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension10[0],
          parentHeight = _this$parentDimension10[1];
        var rect;
        if (this.isAttachedToDOM) {
          rect = this.div.getBoundingClientRect();
        } else {
          var currentLayer = this.currentLayer,
            div = this.div;
          var savedDisplay = div.style.display;
          div.style.display = "hidden";
          currentLayer.div.append(this.div);
          rect = div.getBoundingClientRect();
          div.remove();
          div.style.display = savedDisplay;
        }
        if (this.rotation % 180 === this.parentRotation % 180) {
          this.width = rect.width / parentWidth;
          this.height = rect.height / parentHeight;
        } else {
          this.width = rect.height / parentWidth;
          this.height = rect.width / parentHeight;
        }
        this.fixAndSetPosition();
      }
      function _setContent() {
        this.editorDiv.replaceChildren();
        if (!_classPrivateFieldGet(_content, this)) {
          return;
        }
        var _iterator117 = _createForOfIteratorHelper(_classPrivateFieldGet(_content, this).split("\n")),
          _step117;
        try {
          for (_iterator117.s(); !(_step117 = _iterator117.n()).done;) {
            var line = _step117.value;
            var div = document.createElement("div");
            div.append(line ? document.createTextNode(line) : document.createElement("br"));
            this.editorDiv.append(div);
          }
        } catch (err) {
          _iterator117.e(err);
        } finally {
          _iterator117.f();
        }
      }
      function _hasElementChanged(serialized) {
        var _classPrivateFieldGet27 = _classPrivateFieldGet(_initialData, this),
          value = _classPrivateFieldGet27.value,
          fontSize = _classPrivateFieldGet27.fontSize,
          color = _classPrivateFieldGet27.color,
          rect = _classPrivateFieldGet27.rect,
          pageIndex = _classPrivateFieldGet27.pageIndex;
        return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some(function (x, i) {
          return Math.abs(x - rect[i]) >= 1;
        }) || serialized.color.some(function (c, i) {
          return c !== color[i];
        }) || serialized.pageIndex !== pageIndex;
      }
      function _cheatInitialRect() {
        var _this65 = this;
        var delayed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (!this.annotationElementId) {
          return;
        }
        _assertClassBrand(_FreeTextEditor_brand, this, _setEditorDimensions).call(this);
        if (!delayed && (this.width === 0 || this.height === 0)) {
          setTimeout(function () {
            return _assertClassBrand(_FreeTextEditor_brand, _this65, _cheatInitialRect).call(_this65, true);
          }, 0);
          return;
        }
        var padding = _FreeTextEditor._internalPadding * this.parentScale;
        _classPrivateFieldGet(_initialData, this).rect = this.getRect(padding, padding);
      }
      _defineProperty(FreeTextEditor, "_freeTextDefaultContent", "");
      _defineProperty(FreeTextEditor, "_internalPadding", 0);
      _defineProperty(FreeTextEditor, "_defaultColor", null);
      _defineProperty(FreeTextEditor, "_defaultFontSize", 10);
      _defineProperty(FreeTextEditor, "_type", "freetext");
      exports.FreeTextEditor = FreeTextEditor;

      /***/
    }), (/* 29 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StampAnnotationElement = exports.InkAnnotationElement = exports.FreeTextAnnotationElement = exports.AnnotationLayer = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(6);
      var _annotation_storage = __w_pdfjs_require__(3);
      var _scripting_utils = __w_pdfjs_require__(30);
      var _displayL10n_utils = __w_pdfjs_require__(31);
      var _xfa_layer = __w_pdfjs_require__(32);
      var DEFAULT_TAB_INDEX = 1000;
      var DEFAULT_FONT_SIZE = 9;
      var GetElementsByNameSet = new WeakSet();
      function getRectDims(rect) {
        return {
          width: rect[2] - rect[0],
          height: rect[3] - rect[1]
        };
      }
      var AnnotationElementFactory = /*#__PURE__*/function () {
        function AnnotationElementFactory() {
          _classCallCheck(this, AnnotationElementFactory);
        }
        return _createClass(AnnotationElementFactory, null, [{
          key: "create",
          value: function create(parameters) {
            var subtype = parameters.data.annotationType;
            switch (subtype) {
              case _util.AnnotationType.LINK:
                return new LinkAnnotationElement(parameters);
              case _util.AnnotationType.TEXT:
                return new TextAnnotationElement(parameters);
              case _util.AnnotationType.WIDGET:
                var fieldType = parameters.data.fieldType;
                switch (fieldType) {
                  case "Tx":
                    return new TextWidgetAnnotationElement(parameters);
                  case "Btn":
                    if (parameters.data.radioButton) {
                      return new RadioButtonWidgetAnnotationElement(parameters);
                    } else if (parameters.data.checkBox) {
                      return new CheckboxWidgetAnnotationElement(parameters);
                    }
                    return new PushButtonWidgetAnnotationElement(parameters);
                  case "Ch":
                    return new ChoiceWidgetAnnotationElement(parameters);
                  case "Sig":
                    return new SignatureWidgetAnnotationElement(parameters);
                }
                return new WidgetAnnotationElement(parameters);
              case _util.AnnotationType.POPUP:
                return new PopupAnnotationElement(parameters);
              case _util.AnnotationType.FREETEXT:
                return new FreeTextAnnotationElement(parameters);
              case _util.AnnotationType.LINE:
                return new LineAnnotationElement(parameters);
              case _util.AnnotationType.SQUARE:
                return new SquareAnnotationElement(parameters);
              case _util.AnnotationType.CIRCLE:
                return new CircleAnnotationElement(parameters);
              case _util.AnnotationType.POLYLINE:
                return new PolylineAnnotationElement(parameters);
              case _util.AnnotationType.CARET:
                return new CaretAnnotationElement(parameters);
              case _util.AnnotationType.INK:
                return new InkAnnotationElement(parameters);
              case _util.AnnotationType.POLYGON:
                return new PolygonAnnotationElement(parameters);
              case _util.AnnotationType.HIGHLIGHT:
                return new HighlightAnnotationElement(parameters);
              case _util.AnnotationType.UNDERLINE:
                return new UnderlineAnnotationElement(parameters);
              case _util.AnnotationType.SQUIGGLY:
                return new SquigglyAnnotationElement(parameters);
              case _util.AnnotationType.STRIKEOUT:
                return new StrikeOutAnnotationElement(parameters);
              case _util.AnnotationType.STAMP:
                return new StampAnnotationElement(parameters);
              case _util.AnnotationType.FILEATTACHMENT:
                return new FileAttachmentAnnotationElement(parameters);
              default:
                return new AnnotationElement(parameters);
            }
          }
        }]);
      }();
      var _hasBorder = /*#__PURE__*/new WeakMap();
      var AnnotationElement = /*#__PURE__*/function () {
        function AnnotationElement(parameters) {
          var _ref75 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref75$isRenderable = _ref75.isRenderable,
            isRenderable = _ref75$isRenderable === void 0 ? false : _ref75$isRenderable,
            _ref75$ignoreBorder = _ref75.ignoreBorder,
            ignoreBorder = _ref75$ignoreBorder === void 0 ? false : _ref75$ignoreBorder,
            _ref75$createQuadrila = _ref75.createQuadrilaterals,
            createQuadrilaterals = _ref75$createQuadrila === void 0 ? false : _ref75$createQuadrila;
          _classCallCheck(this, AnnotationElement);
          _classPrivateFieldInitSpec(this, _hasBorder, false);
          this.isRenderable = isRenderable;
          this.data = parameters.data;
          this.layer = parameters.layer;
          this.linkService = parameters.linkService;
          this.downloadManager = parameters.downloadManager;
          this.imageResourcesPath = parameters.imageResourcesPath;
          this.renderForms = parameters.renderForms;
          this.svgFactory = parameters.svgFactory;
          this.annotationStorage = parameters.annotationStorage;
          this.enableScripting = parameters.enableScripting;
          this.hasJSActions = parameters.hasJSActions;
          this._fieldObjects = parameters.fieldObjects;
          this.parent = parameters.parent;
          if (isRenderable) {
            this.container = this._createContainer(ignoreBorder);
          }
          if (createQuadrilaterals) {
            this._createQuadrilaterals();
          }
        }
        return _createClass(AnnotationElement, [{
          key: "hasPopupData",
          get: function get() {
            return AnnotationElement._hasPopupData(this.data);
          }
        }, {
          key: "_createContainer",
          value: function _createContainer(ignoreBorder) {
            var data = this.data,
              _this$parent3 = this.parent,
              page = _this$parent3.page,
              viewport = _this$parent3.viewport;
            var container = document.createElement("section");
            container.setAttribute("data-annotation-id", data.id);
            if (!(this instanceof WidgetAnnotationElement)) {
              container.tabIndex = DEFAULT_TAB_INDEX;
            }
            container.style.zIndex = this.parent.zIndex++;
            if (this.data.popupRef) {
              container.setAttribute("aria-haspopup", "dialog");
            }
            if (data.noRotate) {
              container.classList.add("norotate");
            }
            var _viewport$rawDims3 = viewport.rawDims,
              pageWidth = _viewport$rawDims3.pageWidth,
              pageHeight = _viewport$rawDims3.pageHeight,
              pageX = _viewport$rawDims3.pageX,
              pageY = _viewport$rawDims3.pageY;
            if (!data.rect || this instanceof PopupAnnotationElement) {
              var _rotation2 = data.rotation;
              if (!data.hasOwnCanvas && _rotation2 !== 0) {
                this.setRotation(_rotation2, container);
              }
              return container;
            }
            var _getRectDims = getRectDims(data.rect),
              width = _getRectDims.width,
              height = _getRectDims.height;
            var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
            if (!ignoreBorder && data.borderStyle.width > 0) {
              container.style.borderWidth = "".concat(data.borderStyle.width, "px");
              var horizontalRadius = data.borderStyle.horizontalCornerRadius;
              var verticalRadius = data.borderStyle.verticalCornerRadius;
              if (horizontalRadius > 0 || verticalRadius > 0) {
                var radius = "calc(".concat(horizontalRadius, "px * var(--scale-factor)) / calc(").concat(verticalRadius, "px * var(--scale-factor))");
                container.style.borderRadius = radius;
              } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                var _radius = "calc(".concat(width, "px * var(--scale-factor)) / calc(").concat(height, "px * var(--scale-factor))");
                container.style.borderRadius = _radius;
              }
              switch (data.borderStyle.style) {
                case _util.AnnotationBorderStyleType.SOLID:
                  container.style.borderStyle = "solid";
                  break;
                case _util.AnnotationBorderStyleType.DASHED:
                  container.style.borderStyle = "dashed";
                  break;
                case _util.AnnotationBorderStyleType.BEVELED:
                  (0, _util.warn)("Unimplemented border style: beveled");
                  break;
                case _util.AnnotationBorderStyleType.INSET:
                  (0, _util.warn)("Unimplemented border style: inset");
                  break;
                case _util.AnnotationBorderStyleType.UNDERLINE:
                  container.style.borderBottomStyle = "solid";
                  break;
                default:
                  break;
              }
              var borderColor = data.borderColor || null;
              if (borderColor) {
                _classPrivateFieldSet(_hasBorder, this, true);
                container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
              } else {
                container.style.borderWidth = 0;
              }
            }
            container.style.left = "".concat(100 * (rect[0] - pageX) / pageWidth, "%");
            container.style.top = "".concat(100 * (rect[1] - pageY) / pageHeight, "%");
            var rotation = data.rotation;
            if (data.hasOwnCanvas || rotation === 0) {
              container.style.width = "".concat(100 * width / pageWidth, "%");
              container.style.height = "".concat(100 * height / pageHeight, "%");
            } else {
              this.setRotation(rotation, container);
            }
            return container;
          }
        }, {
          key: "setRotation",
          value: function setRotation(angle) {
            var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
            if (!this.data.rect) {
              return;
            }
            var _this$parent$viewport3 = this.parent.viewport.rawDims,
              pageWidth = _this$parent$viewport3.pageWidth,
              pageHeight = _this$parent$viewport3.pageHeight;
            var _getRectDims2 = getRectDims(this.data.rect),
              width = _getRectDims2.width,
              height = _getRectDims2.height;
            var elementWidth, elementHeight;
            if (angle % 180 === 0) {
              elementWidth = 100 * width / pageWidth;
              elementHeight = 100 * height / pageHeight;
            } else {
              elementWidth = 100 * height / pageWidth;
              elementHeight = 100 * width / pageHeight;
            }
            container.style.width = "".concat(elementWidth, "%");
            container.style.height = "".concat(elementHeight, "%");
            container.setAttribute("data-main-rotation", (360 - angle) % 360);
          }
        }, {
          key: "_commonActions",
          get: function get() {
            var _this66 = this;
            var setColor = function setColor(jsName, styleName, event) {
              var color = event.detail[jsName];
              var colorType = color[0];
              var colorArray = color.slice(1);
              event.target.style[styleName] = _scripting_utils.ColorConverters["".concat(colorType, "_HTML")](colorArray);
              _this66.annotationStorage.setValue(_this66.data.id, _defineProperty({}, styleName, _scripting_utils.ColorConverters["".concat(colorType, "_rgb")](colorArray)));
            };
            return (0, _util.shadow)(this, "_commonActions", {
              display: function display(event) {
                var display = event.detail.display;
                var hidden = display % 2 === 1;
                _this66.container.style.visibility = hidden ? "hidden" : "visible";
                _this66.annotationStorage.setValue(_this66.data.id, {
                  noView: hidden,
                  noPrint: display === 1 || display === 2
                });
              },
              print: function print(event) {
                _this66.annotationStorage.setValue(_this66.data.id, {
                  noPrint: !event.detail.print
                });
              },
              hidden: function hidden(event) {
                var hidden = event.detail.hidden;
                _this66.container.style.visibility = hidden ? "hidden" : "visible";
                _this66.annotationStorage.setValue(_this66.data.id, {
                  noPrint: hidden,
                  noView: hidden
                });
              },
              focus: function focus(event) {
                setTimeout(function () {
                  return event.target.focus({
                    preventScroll: false
                  });
                }, 0);
              },
              userName: function userName(event) {
                event.target.title = event.detail.userName;
              },
              readonly: function readonly(event) {
                event.target.disabled = event.detail.readonly;
              },
              required: function required(event) {
                _this66._setRequired(event.target, event.detail.required);
              },
              bgColor: function bgColor(event) {
                setColor("bgColor", "backgroundColor", event);
              },
              fillColor: function fillColor(event) {
                setColor("fillColor", "backgroundColor", event);
              },
              fgColor: function fgColor(event) {
                setColor("fgColor", "color", event);
              },
              textColor: function textColor(event) {
                setColor("textColor", "color", event);
              },
              borderColor: function borderColor(event) {
                setColor("borderColor", "borderColor", event);
              },
              strokeColor: function strokeColor(event) {
                setColor("strokeColor", "borderColor", event);
              },
              rotation: function rotation(event) {
                var angle = event.detail.rotation;
                _this66.setRotation(angle);
                _this66.annotationStorage.setValue(_this66.data.id, {
                  rotation: angle
                });
              }
            });
          }
        }, {
          key: "_dispatchEventFromSandbox",
          value: function _dispatchEventFromSandbox(actions, jsEvent) {
            var commonActions = this._commonActions;
            for (var _i17 = 0, _Object$keys = Object.keys(jsEvent.detail); _i17 < _Object$keys.length; _i17++) {
              var name = _Object$keys[_i17];
              var action = actions[name] || commonActions[name];
              action === null || action === void 0 || action(jsEvent);
            }
          }
        }, {
          key: "_setDefaultPropertiesFromJS",
          value: function _setDefaultPropertiesFromJS(element) {
            if (!this.enableScripting) {
              return;
            }
            var storedData = this.annotationStorage.getRawValue(this.data.id);
            if (!storedData) {
              return;
            }
            var commonActions = this._commonActions;
            for (var _i18 = 0, _Object$entries3 = Object.entries(storedData); _i18 < _Object$entries3.length; _i18++) {
              var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i18], 2),
                actionName = _Object$entries3$_i[0],
                detail = _Object$entries3$_i[1];
              var action = commonActions[actionName];
              if (action) {
                var eventProxy = {
                  detail: _defineProperty({}, actionName, detail),
                  target: element
                };
                action(eventProxy);
                delete storedData[actionName];
              }
            }
          }
        }, {
          key: "_createQuadrilaterals",
          value: function _createQuadrilaterals() {
            if (!this.container) {
              return;
            }
            var quadPoints = this.data.quadPoints;
            if (!quadPoints) {
              return;
            }
            var _this$data$rect = _slicedToArray(this.data.rect, 4),
              rectBlX = _this$data$rect[0],
              rectBlY = _this$data$rect[1],
              rectTrX = _this$data$rect[2],
              rectTrY = _this$data$rect[3];
            if (quadPoints.length === 1) {
              var _quadPoints$ = _slicedToArray(quadPoints[0], 3),
                _quadPoints$$ = _quadPoints$[1],
                trX = _quadPoints$$.x,
                trY = _quadPoints$$.y,
                _quadPoints$$2 = _quadPoints$[2],
                blX = _quadPoints$$2.x,
                blY = _quadPoints$$2.y;
              if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
                return;
              }
            }
            var style = this.container.style;
            var svgBuffer;
            if (_classPrivateFieldGet(_hasBorder, this)) {
              var borderColor = style.borderColor,
                borderWidth = style.borderWidth;
              style.borderWidth = 0;
              svgBuffer = ["url('data:image/svg+xml;utf8,", "<svg xmlns=\"http://www.w3.org/2000/svg\"", " preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">", "<g fill=\"transparent\" stroke=\"".concat(borderColor, "\" stroke-width=\"").concat(borderWidth, "\">")];
              this.container.classList.add("hasBorder");
            }
            var width = rectTrX - rectBlX;
            var height = rectTrY - rectBlY;
            var svgFactory = this.svgFactory;
            var svg = svgFactory.createElement("svg");
            svg.classList.add("quadrilateralsContainer");
            svg.setAttribute("width", 0);
            svg.setAttribute("height", 0);
            var defs = svgFactory.createElement("defs");
            svg.append(defs);
            var clipPath = svgFactory.createElement("clipPath");
            var id = "clippath_".concat(this.data.id);
            clipPath.setAttribute("id", id);
            clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
            defs.append(clipPath);
            var _iterator118 = _createForOfIteratorHelper(quadPoints),
              _step118;
            try {
              for (_iterator118.s(); !(_step118 = _iterator118.n()).done;) {
                var _svgBuffer;
                var _step118$value = _slicedToArray(_step118.value, 3),
                  _step118$value$ = _step118$value[1],
                  _trX = _step118$value$.x,
                  _trY = _step118$value$.y,
                  _step118$value$2 = _step118$value[2],
                  _blX = _step118$value$2.x,
                  _blY = _step118$value$2.y;
                var rect = svgFactory.createElement("rect");
                var x = (_blX - rectBlX) / width;
                var y = (rectTrY - _trY) / height;
                var rectWidth = (_trX - _blX) / width;
                var rectHeight = (_trY - _blY) / height;
                rect.setAttribute("x", x);
                rect.setAttribute("y", y);
                rect.setAttribute("width", rectWidth);
                rect.setAttribute("height", rectHeight);
                clipPath.append(rect);
                (_svgBuffer = svgBuffer) === null || _svgBuffer === void 0 || _svgBuffer.push("<rect vector-effect=\"non-scaling-stroke\" x=\"".concat(x, "\" y=\"").concat(y, "\" width=\"").concat(rectWidth, "\" height=\"").concat(rectHeight, "\"/>"));
              }
            } catch (err) {
              _iterator118.e(err);
            } finally {
              _iterator118.f();
            }
            if (_classPrivateFieldGet(_hasBorder, this)) {
              svgBuffer.push("</g></svg>')");
              style.backgroundImage = svgBuffer.join("");
            }
            this.container.append(svg);
            this.container.style.clipPath = "url(#".concat(id, ")");
          }
        }, {
          key: "_createPopup",
          value: function _createPopup() {
            var container = this.container,
              data = this.data;
            container.setAttribute("aria-haspopup", "dialog");
            var popup = new PopupAnnotationElement({
              data: {
                color: data.color,
                titleObj: data.titleObj,
                modificationDate: data.modificationDate,
                contentsObj: data.contentsObj,
                richText: data.richText,
                parentRect: data.rect,
                borderStyle: 0,
                id: "popup_".concat(data.id),
                rotation: data.rotation
              },
              parent: this.parent,
              elements: [this]
            });
            this.parent.div.append(popup.render());
          }
        }, {
          key: "render",
          value: function render() {
            (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
          }
        }, {
          key: "_getElementsByName",
          value: function _getElementsByName(name) {
            var skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var fields = [];
            if (this._fieldObjects) {
              var fieldObj = this._fieldObjects[name];
              if (fieldObj) {
                var _iterator119 = _createForOfIteratorHelper(fieldObj),
                  _step119;
                try {
                  for (_iterator119.s(); !(_step119 = _iterator119.n()).done;) {
                    var _step119$value = _step119.value,
                      page = _step119$value.page,
                      id = _step119$value.id,
                      exportValues = _step119$value.exportValues;
                    if (page === -1) {
                      continue;
                    }
                    if (id === skipId) {
                      continue;
                    }
                    var exportValue = typeof exportValues === "string" ? exportValues : null;
                    var domElement = document.querySelector("[data-element-id=\"".concat(id, "\"]"));
                    if (domElement && !GetElementsByNameSet.has(domElement)) {
                      (0, _util.warn)("_getElementsByName - element not allowed: ".concat(id));
                      continue;
                    }
                    fields.push({
                      id: id,
                      exportValue: exportValue,
                      domElement: domElement
                    });
                  }
                } catch (err) {
                  _iterator119.e(err);
                } finally {
                  _iterator119.f();
                }
              }
              return fields;
            }
            var _iterator120 = _createForOfIteratorHelper(document.getElementsByName(name)),
              _step120;
            try {
              for (_iterator120.s(); !(_step120 = _iterator120.n()).done;) {
                var _domElement = _step120.value;
                var _exportValue = _domElement.exportValue;
                var _id7 = _domElement.getAttribute("data-element-id");
                if (_id7 === skipId) {
                  continue;
                }
                if (!GetElementsByNameSet.has(_domElement)) {
                  continue;
                }
                fields.push({
                  id: _id7,
                  exportValue: _exportValue,
                  domElement: _domElement
                });
              }
            } catch (err) {
              _iterator120.e(err);
            } finally {
              _iterator120.f();
            }
            return fields;
          }
        }, {
          key: "show",
          value: function show() {
            var _this$popup;
            if (this.container) {
              this.container.hidden = false;
            }
            (_this$popup = this.popup) === null || _this$popup === void 0 || _this$popup.maybeShow();
          }
        }, {
          key: "hide",
          value: function hide() {
            var _this$popup2;
            if (this.container) {
              this.container.hidden = true;
            }
            (_this$popup2 = this.popup) === null || _this$popup2 === void 0 || _this$popup2.forceHide();
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return this.container;
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            var triggers = this.getElementsToTriggerPopup();
            if (Array.isArray(triggers)) {
              var _iterator121 = _createForOfIteratorHelper(triggers),
                _step121;
              try {
                for (_iterator121.s(); !(_step121 = _iterator121.n()).done;) {
                  var element = _step121.value;
                  element.classList.add("highlightArea");
                }
              } catch (err) {
                _iterator121.e(err);
              } finally {
                _iterator121.f();
              }
            } else {
              triggers.classList.add("highlightArea");
            }
          }
        }, {
          key: "_editOnDoubleClick",
          value: function _editOnDoubleClick() {
            var _this67 = this;
            var mode = this.annotationEditorType,
              editId = this.data.id;
            this.container.addEventListener("dblclick", function () {
              var _this67$linkService$e;
              (_this67$linkService$e = _this67.linkService.eventBus) === null || _this67$linkService$e === void 0 || _this67$linkService$e.dispatch("switchannotationeditormode", {
                source: _this67,
                mode: mode,
                editId: editId
              });
            });
          }
        }], [{
          key: "_hasPopupData",
          value: function _hasPopupData(_ref76) {
            var titleObj = _ref76.titleObj,
              contentsObj = _ref76.contentsObj,
              richText = _ref76.richText;
            return !!(titleObj !== null && titleObj !== void 0 && titleObj.str || contentsObj !== null && contentsObj !== void 0 && contentsObj.str || richText !== null && richText !== void 0 && richText.str);
          }
        }]);
      }();
      var _LinkAnnotationElement_brand = /*#__PURE__*/new WeakSet();
      var LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {
        function LinkAnnotationElement(parameters) {
          var _this68;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          _classCallCheck(this, LinkAnnotationElement);
          _this68 = _callSuper(this, LinkAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
            createQuadrilaterals: true
          }]);
          _classPrivateMethodInitSpec(_this68, _LinkAnnotationElement_brand);
          _this68.isTooltipOnly = parameters.data.isTooltipOnly;
          return _this68;
        }
        _inherits(LinkAnnotationElement, _AnnotationElement2);
        return _createClass(LinkAnnotationElement, [{
          key: "render",
          value: function render() {
            var data = this.data,
              linkService = this.linkService;
            var link = document.createElement("a");
            link.setAttribute("data-element-id", data.id);
            var isBound = false;
            if (data.url) {
              linkService.addLinkAttributes(link, data.url, data.newWindow);
              isBound = true;
            } else if (data.action) {
              this._bindNamedAction(link, data.action);
              isBound = true;
            } else if (data.attachment) {
              this._bindAttachment(link, data.attachment);
              isBound = true;
            } else if (data.setOCGState) {
              _assertClassBrand(_LinkAnnotationElement_brand, this, _bindSetOCGState).call(this, link, data.setOCGState);
              isBound = true;
            } else if (data.dest) {
              this._bindLink(link, data.dest);
              isBound = true;
            } else {
              if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                this._bindJSAction(link, data);
                isBound = true;
              }
              if (data.resetForm) {
                this._bindResetFormAction(link, data.resetForm);
                isBound = true;
              } else if (this.isTooltipOnly && !isBound) {
                this._bindLink(link, "");
                isBound = true;
              }
            }
            this.container.classList.add("linkAnnotation");
            if (isBound) {
              this.container.append(link);
            }
            return this.container;
          }
        }, {
          key: "_bindLink",
          value: function _bindLink(link, destination) {
            var _this69 = this;
            link.href = this.linkService.getDestinationHash(destination);
            link.onclick = function () {
              if (destination) {
                _this69.linkService.goToDestination(destination);
              }
              return false;
            };
            if (destination || destination === "") {
              _assertClassBrand(_LinkAnnotationElement_brand, this, _setInternalLink).call(this);
            }
          }
        }, {
          key: "_bindNamedAction",
          value: function _bindNamedAction(link, action) {
            var _this70 = this;
            link.href = this.linkService.getAnchorUrl("");
            link.onclick = function () {
              _this70.linkService.executeNamedAction(action);
              return false;
            };
            _assertClassBrand(_LinkAnnotationElement_brand, this, _setInternalLink).call(this);
          }
        }, {
          key: "_bindAttachment",
          value: function _bindAttachment(link, attachment) {
            var _this71 = this;
            link.href = this.linkService.getAnchorUrl("");
            link.onclick = function () {
              var _this71$downloadManag;
              (_this71$downloadManag = _this71.downloadManager) === null || _this71$downloadManag === void 0 || _this71$downloadManag.openOrDownloadData(_this71.container, attachment.content, attachment.filename);
              return false;
            };
            _assertClassBrand(_LinkAnnotationElement_brand, this, _setInternalLink).call(this);
          }
        }, {
          key: "_bindJSAction",
          value: function _bindJSAction(link, data) {
            var _this72 = this;
            link.href = this.linkService.getAnchorUrl("");
            var map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
            var _loop2 = function _loop2() {
              var name = _Object$keys2[_i19];
              var jsName = map.get(name);
              if (!jsName) {
                return 1; // continue
              }
              link[jsName] = function () {
                var _this72$linkService$e;
                (_this72$linkService$e = _this72.linkService.eventBus) === null || _this72$linkService$e === void 0 || _this72$linkService$e.dispatch("dispatcheventinsandbox", {
                  source: _this72,
                  detail: {
                    id: data.id,
                    name: name
                  }
                });
                return false;
              };
            };
            for (var _i19 = 0, _Object$keys2 = Object.keys(data.actions); _i19 < _Object$keys2.length; _i19++) {
              if (_loop2()) continue;
            }
            if (!link.onclick) {
              link.onclick = function () {
                return false;
              };
            }
            _assertClassBrand(_LinkAnnotationElement_brand, this, _setInternalLink).call(this);
          }
        }, {
          key: "_bindResetFormAction",
          value: function _bindResetFormAction(link, resetForm) {
            var _this73 = this;
            var otherClickAction = link.onclick;
            if (!otherClickAction) {
              link.href = this.linkService.getAnchorUrl("");
            }
            _assertClassBrand(_LinkAnnotationElement_brand, this, _setInternalLink).call(this);
            if (!this._fieldObjects) {
              (0, _util.warn)("_bindResetFormAction - \"resetForm\" action not supported, " + "ensure that the `fieldObjects` parameter is provided.");
              if (!otherClickAction) {
                link.onclick = function () {
                  return false;
                };
              }
              return;
            }
            link.onclick = function () {
              otherClickAction === null || otherClickAction === void 0 || otherClickAction();
              var resetFormFields = resetForm.fields,
                resetFormRefs = resetForm.refs,
                include = resetForm.include;
              var allFields = [];
              if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                var fieldIds = new Set(resetFormRefs);
                var _iterator122 = _createForOfIteratorHelper(resetFormFields),
                  _step122;
                try {
                  for (_iterator122.s(); !(_step122 = _iterator122.n()).done;) {
                    var fieldName = _step122.value;
                    var _fields = _this73._fieldObjects[fieldName] || [];
                    var _iterator124 = _createForOfIteratorHelper(_fields),
                      _step124;
                    try {
                      for (_iterator124.s(); !(_step124 = _iterator124.n()).done;) {
                        var id = _step124.value.id;
                        fieldIds.add(id);
                      }
                    } catch (err) {
                      _iterator124.e(err);
                    } finally {
                      _iterator124.f();
                    }
                  }
                } catch (err) {
                  _iterator122.e(err);
                } finally {
                  _iterator122.f();
                }
                for (var _i20 = 0, _Object$values = Object.values(_this73._fieldObjects); _i20 < _Object$values.length; _i20++) {
                  var fields = _Object$values[_i20];
                  var _iterator123 = _createForOfIteratorHelper(fields),
                    _step123;
                  try {
                    for (_iterator123.s(); !(_step123 = _iterator123.n()).done;) {
                      var field = _step123.value;
                      if (fieldIds.has(field.id) === include) {
                        allFields.push(field);
                      }
                    }
                  } catch (err) {
                    _iterator123.e(err);
                  } finally {
                    _iterator123.f();
                  }
                }
              } else {
                for (var _i21 = 0, _Object$values2 = Object.values(_this73._fieldObjects); _i21 < _Object$values2.length; _i21++) {
                  var _fields2 = _Object$values2[_i21];
                  allFields.push.apply(allFields, _toConsumableArray(_fields2));
                }
              }
              var storage = _this73.annotationStorage;
              var allIds = [];
              for (var _i22 = 0, _allFields = allFields; _i22 < _allFields.length; _i22++) {
                var _field = _allFields[_i22];
                var _id8 = _field.id;
                allIds.push(_id8);
                switch (_field.type) {
                  case "text":
                    {
                      var value = _field.defaultValue || "";
                      storage.setValue(_id8, {
                        value: value
                      });
                      break;
                    }
                  case "checkbox":
                  case "radiobutton":
                    {
                      var _value2 = _field.defaultValue === _field.exportValues;
                      storage.setValue(_id8, {
                        value: _value2
                      });
                      break;
                    }
                  case "combobox":
                  case "listbox":
                    {
                      var _value3 = _field.defaultValue || "";
                      storage.setValue(_id8, {
                        value: _value3
                      });
                      break;
                    }
                  default:
                    continue;
                }
                var domElement = document.querySelector("[data-element-id=\"".concat(_id8, "\"]"));
                if (!domElement) {
                  continue;
                } else if (!GetElementsByNameSet.has(domElement)) {
                  (0, _util.warn)("_bindResetFormAction - element not allowed: ".concat(_id8));
                  continue;
                }
                domElement.dispatchEvent(new Event("resetform"));
              }
              if (_this73.enableScripting) {
                var _this73$linkService$e;
                (_this73$linkService$e = _this73.linkService.eventBus) === null || _this73$linkService$e === void 0 || _this73$linkService$e.dispatch("dispatcheventinsandbox", {
                  source: _this73,
                  detail: {
                    id: "app",
                    ids: allIds,
                    name: "ResetForm"
                  }
                });
              }
              return false;
            };
          }
        }]);
      }(AnnotationElement);
      function _setInternalLink() {
        this.container.setAttribute("data-internal-link", "");
      }
      function _bindSetOCGState(link, action) {
        var _this90 = this;
        link.href = this.linkService.getAnchorUrl("");
        link.onclick = function () {
          _this90.linkService.executeSetOCGState(action);
          return false;
        };
        _assertClassBrand(_LinkAnnotationElement_brand, this, _setInternalLink).call(this);
      }
      var TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {
        function TextAnnotationElement(parameters) {
          _classCallCheck(this, TextAnnotationElement);
          return _callSuper(this, TextAnnotationElement, [parameters, {
            isRenderable: true
          }]);
        }
        _inherits(TextAnnotationElement, _AnnotationElement3);
        return _createClass(TextAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("textAnnotation");
            var image = document.createElement("img");
            image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
            image.alt = "[{{type}} Annotation]";
            image.dataset.l10nId = "text_annotation_type";
            image.dataset.l10nArgs = JSON.stringify({
              type: this.data.name
            });
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            this.container.append(image);
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {
        function WidgetAnnotationElement() {
          _classCallCheck(this, WidgetAnnotationElement);
          return _callSuper(this, WidgetAnnotationElement, arguments);
        }
        _inherits(WidgetAnnotationElement, _AnnotationElement4);
        return _createClass(WidgetAnnotationElement, [{
          key: "render",
          value: function render() {
            if (this.data.alternativeText) {
              this.container.title = this.data.alternativeText;
            }
            return this.container;
          }
        }, {
          key: "showElementAndHideCanvas",
          value: function showElementAndHideCanvas(element) {
            if (this.data.hasOwnCanvas) {
              var _element$previousSibl;
              if (((_element$previousSibl = element.previousSibling) === null || _element$previousSibl === void 0 ? void 0 : _element$previousSibl.nodeName) === "CANVAS") {
                element.previousSibling.hidden = true;
              }
              element.hidden = false;
            }
          }
        }, {
          key: "_getKeyModifier",
          value: function _getKeyModifier(event) {
            var _util$FeatureTest$pla = _util.FeatureTest.platform,
              isWin = _util$FeatureTest$pla.isWin,
              isMac = _util$FeatureTest$pla.isMac;
            return isWin && event.ctrlKey || isMac && event.metaKey;
          }
        }, {
          key: "_setEventListener",
          value: function _setEventListener(element, elementData, baseName, eventName, valueGetter) {
            var _this74 = this;
            if (baseName.includes("mouse")) {
              element.addEventListener(baseName, function (event) {
                var _this74$linkService$e;
                (_this74$linkService$e = _this74.linkService.eventBus) === null || _this74$linkService$e === void 0 || _this74$linkService$e.dispatch("dispatcheventinsandbox", {
                  source: _this74,
                  detail: {
                    id: _this74.data.id,
                    name: eventName,
                    value: valueGetter(event),
                    shift: event.shiftKey,
                    modifier: _this74._getKeyModifier(event)
                  }
                });
              });
            } else {
              element.addEventListener(baseName, function (event) {
                var _this74$linkService$e2;
                if (baseName === "blur") {
                  if (!elementData.focused || !event.relatedTarget) {
                    return;
                  }
                  elementData.focused = false;
                } else if (baseName === "focus") {
                  if (elementData.focused) {
                    return;
                  }
                  elementData.focused = true;
                }
                if (!valueGetter) {
                  return;
                }
                (_this74$linkService$e2 = _this74.linkService.eventBus) === null || _this74$linkService$e2 === void 0 || _this74$linkService$e2.dispatch("dispatcheventinsandbox", {
                  source: _this74,
                  detail: {
                    id: _this74.data.id,
                    name: eventName,
                    value: valueGetter(event)
                  }
                });
              });
            }
          }
        }, {
          key: "_setEventListeners",
          value: function _setEventListeners(element, elementData, names, getter) {
            var _iterator125 = _createForOfIteratorHelper(names),
              _step125;
            try {
              for (_iterator125.s(); !(_step125 = _iterator125.n()).done;) {
                var _this$data$actions;
                var _step125$value = _slicedToArray(_step125.value, 2),
                  baseName = _step125$value[0],
                  eventName = _step125$value[1];
                if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
                  var _this$data$actions2, _this$data$actions3;
                  if (eventName === "Focus" || eventName === "Blur") {
                    elementData || (elementData = {
                      focused: false
                    });
                  }
                  this._setEventListener(element, elementData, baseName, eventName, getter);
                  if (eventName === "Focus" && !((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Blur)) {
                    this._setEventListener(element, elementData, "blur", "Blur", null);
                  } else if (eventName === "Blur" && !((_this$data$actions3 = this.data.actions) !== null && _this$data$actions3 !== void 0 && _this$data$actions3.Focus)) {
                    this._setEventListener(element, elementData, "focus", "Focus", null);
                  }
                }
              }
            } catch (err) {
              _iterator125.e(err);
            } finally {
              _iterator125.f();
            }
          }
        }, {
          key: "_setBackgroundColor",
          value: function _setBackgroundColor(element) {
            var color = this.data.backgroundColor || null;
            element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
          }
        }, {
          key: "_setTextStyle",
          value: function _setTextStyle(element) {
            var TEXT_ALIGNMENT = ["left", "center", "right"];
            var fontColor = this.data.defaultAppearanceData.fontColor;
            var fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
            var style = element.style;
            var computedFontSize;
            var BORDER_SIZE = 2;
            var roundToOneDecimal = function roundToOneDecimal(x) {
              return Math.round(10 * x) / 10;
            };
            if (this.data.multiLine) {
              var height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
              var numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;
              var lineHeight = height / numberOfLines;
              computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));
            } else {
              var _height2 = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
              computedFontSize = Math.min(fontSize, roundToOneDecimal(_height2 / _util.LINE_FACTOR));
            }
            style.fontSize = "calc(".concat(computedFontSize, "px * var(--scale-factor))");
            style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
            if (this.data.textAlignment !== null) {
              style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
            }
          }
        }, {
          key: "_setRequired",
          value: function _setRequired(element, isRequired) {
            if (isRequired) {
              element.setAttribute("required", true);
            } else {
              element.removeAttribute("required");
            }
            element.setAttribute("aria-required", isRequired);
          }
        }]);
      }(AnnotationElement);
      var TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {
        function TextWidgetAnnotationElement(parameters) {
          _classCallCheck(this, TextWidgetAnnotationElement);
          var isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
          return _callSuper(this, TextWidgetAnnotationElement, [parameters, {
            isRenderable: isRenderable
          }]);
        }
        _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);
        return _createClass(TextWidgetAnnotationElement, [{
          key: "setPropertyOnSiblings",
          value: function setPropertyOnSiblings(base, key, value, keyInStorage) {
            var storage = this.annotationStorage;
            var _iterator126 = _createForOfIteratorHelper(this._getElementsByName(base.name, base.id)),
              _step126;
            try {
              for (_iterator126.s(); !(_step126 = _iterator126.n()).done;) {
                var element = _step126.value;
                if (element.domElement) {
                  element.domElement[key] = value;
                }
                storage.setValue(element.id, _defineProperty({}, keyInStorage, value));
              }
            } catch (err) {
              _iterator126.e(err);
            } finally {
              _iterator126.f();
            }
          }
        }, {
          key: "render",
          value: function render() {
            var _this75 = this;
            var storage = this.annotationStorage;
            var id = this.data.id;
            this.container.classList.add("textWidgetAnnotation");
            var element = null;
            if (this.renderForms) {
              var _this$data$textConten;
              var storedData = storage.getValue(id, {
                value: this.data.fieldValue
              });
              var textContent = storedData.value || "";
              var maxLen = storage.getValue(id, {
                charLimit: this.data.maxLen
              }).charLimit;
              if (maxLen && textContent.length > maxLen) {
                textContent = textContent.slice(0, maxLen);
              }
              var fieldFormattedValues = storedData.formattedValue || ((_this$data$textConten = this.data.textContent) === null || _this$data$textConten === void 0 ? void 0 : _this$data$textConten.join("\n")) || null;
              if (fieldFormattedValues && this.data.comb) {
                fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
              }
              var elementData = {
                userValue: textContent,
                formattedValue: fieldFormattedValues,
                lastCommittedValue: null,
                commitKey: 1,
                focused: false
              };
              if (this.data.multiLine) {
                element = document.createElement("textarea");
                element.textContent = fieldFormattedValues !== null && fieldFormattedValues !== void 0 ? fieldFormattedValues : textContent;
                if (this.data.doNotScroll) {
                  element.style.overflowY = "hidden";
                }
              } else {
                element = document.createElement("input");
                element.type = "text";
                element.setAttribute("value", fieldFormattedValues !== null && fieldFormattedValues !== void 0 ? fieldFormattedValues : textContent);
                if (this.data.doNotScroll) {
                  element.style.overflowX = "hidden";
                }
              }
              if (this.data.hasOwnCanvas) {
                element.hidden = true;
              }
              GetElementsByNameSet.add(element);
              element.setAttribute("data-element-id", id);
              element.disabled = this.data.readOnly;
              element.name = this.data.fieldName;
              element.tabIndex = DEFAULT_TAB_INDEX;
              this._setRequired(element, this.data.required);
              if (maxLen) {
                element.maxLength = maxLen;
              }
              element.addEventListener("input", function (event) {
                storage.setValue(id, {
                  value: event.target.value
                });
                _this75.setPropertyOnSiblings(element, "value", event.target.value, "value");
                elementData.formattedValue = null;
              });
              element.addEventListener("resetform", function (event) {
                var _this75$data$defaultF;
                var defaultValue = (_this75$data$defaultF = _this75.data.defaultFieldValue) !== null && _this75$data$defaultF !== void 0 ? _this75$data$defaultF : "";
                element.value = elementData.userValue = defaultValue;
                elementData.formattedValue = null;
              });
              var blurListener = function blurListener(event) {
                var formattedValue = elementData.formattedValue;
                if (formattedValue !== null && formattedValue !== undefined) {
                  event.target.value = formattedValue;
                }
                event.target.scrollLeft = 0;
              };
              if (this.enableScripting && this.hasJSActions) {
                var _this$data$actions4;
                element.addEventListener("focus", function (event) {
                  if (elementData.focused) {
                    return;
                  }
                  var target = event.target;
                  if (elementData.userValue) {
                    target.value = elementData.userValue;
                  }
                  elementData.lastCommittedValue = target.value;
                  elementData.commitKey = 1;
                  elementData.focused = true;
                });
                element.addEventListener("updatefromsandbox", function (jsEvent) {
                  _this75.showElementAndHideCanvas(jsEvent.target);
                  var actions = {
                    value: function value(event) {
                      var _event$detail$value;
                      elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : "";
                      storage.setValue(id, {
                        value: elementData.userValue.toString()
                      });
                      event.target.value = elementData.userValue;
                    },
                    formattedValue: function formattedValue(event) {
                      var formattedValue = event.detail.formattedValue;
                      elementData.formattedValue = formattedValue;
                      if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                        event.target.value = formattedValue;
                      }
                      storage.setValue(id, {
                        formattedValue: formattedValue
                      });
                    },
                    selRange: function selRange(event) {
                      var _event$target;
                      (_event$target = event.target).setSelectionRange.apply(_event$target, _toConsumableArray(event.detail.selRange));
                    },
                    charLimit: function charLimit(event) {
                      var _this75$linkService$e;
                      var charLimit = event.detail.charLimit;
                      var target = event.target;
                      if (charLimit === 0) {
                        target.removeAttribute("maxLength");
                        return;
                      }
                      target.setAttribute("maxLength", charLimit);
                      var value = elementData.userValue;
                      if (!value || value.length <= charLimit) {
                        return;
                      }
                      value = value.slice(0, charLimit);
                      target.value = elementData.userValue = value;
                      storage.setValue(id, {
                        value: value
                      });
                      (_this75$linkService$e = _this75.linkService.eventBus) === null || _this75$linkService$e === void 0 || _this75$linkService$e.dispatch("dispatcheventinsandbox", {
                        source: _this75,
                        detail: {
                          id: id,
                          name: "Keystroke",
                          value: value,
                          willCommit: true,
                          commitKey: 1,
                          selStart: target.selectionStart,
                          selEnd: target.selectionEnd
                        }
                      });
                    }
                  };
                  _this75._dispatchEventFromSandbox(actions, jsEvent);
                });
                element.addEventListener("keydown", function (event) {
                  var _this75$linkService$e2;
                  elementData.commitKey = 1;
                  var commitKey = -1;
                  if (event.key === "Escape") {
                    commitKey = 0;
                  } else if (event.key === "Enter" && !_this75.data.multiLine) {
                    commitKey = 2;
                  } else if (event.key === "Tab") {
                    elementData.commitKey = 3;
                  }
                  if (commitKey === -1) {
                    return;
                  }
                  var value = event.target.value;
                  if (elementData.lastCommittedValue === value) {
                    return;
                  }
                  elementData.lastCommittedValue = value;
                  elementData.userValue = value;
                  (_this75$linkService$e2 = _this75.linkService.eventBus) === null || _this75$linkService$e2 === void 0 || _this75$linkService$e2.dispatch("dispatcheventinsandbox", {
                    source: _this75,
                    detail: {
                      id: id,
                      name: "Keystroke",
                      value: value,
                      willCommit: true,
                      commitKey: commitKey,
                      selStart: event.target.selectionStart,
                      selEnd: event.target.selectionEnd
                    }
                  });
                });
                var _blurListener = blurListener;
                blurListener = null;
                element.addEventListener("blur", function (event) {
                  if (!elementData.focused || !event.relatedTarget) {
                    return;
                  }
                  elementData.focused = false;
                  var value = event.target.value;
                  elementData.userValue = value;
                  if (elementData.lastCommittedValue !== value) {
                    var _this75$linkService$e3;
                    (_this75$linkService$e3 = _this75.linkService.eventBus) === null || _this75$linkService$e3 === void 0 || _this75$linkService$e3.dispatch("dispatcheventinsandbox", {
                      source: _this75,
                      detail: {
                        id: id,
                        name: "Keystroke",
                        value: value,
                        willCommit: true,
                        commitKey: elementData.commitKey,
                        selStart: event.target.selectionStart,
                        selEnd: event.target.selectionEnd
                      }
                    });
                  }
                  _blurListener(event);
                });
                if ((_this$data$actions4 = this.data.actions) !== null && _this$data$actions4 !== void 0 && _this$data$actions4.Keystroke) {
                  element.addEventListener("beforeinput", function (event) {
                    var _this75$linkService$e4;
                    elementData.lastCommittedValue = null;
                    var data = event.data,
                      target = event.target;
                    var value = target.value,
                      selectionStart = target.selectionStart,
                      selectionEnd = target.selectionEnd;
                    var selStart = selectionStart,
                      selEnd = selectionEnd;
                    switch (event.inputType) {
                      case "deleteWordBackward":
                        {
                          var match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                          if (match) {
                            selStart -= match[0].length;
                          }
                          break;
                        }
                      case "deleteWordForward":
                        {
                          var _match3 = value.substring(selectionStart).match(/^[^\w]*\w*/);
                          if (_match3) {
                            selEnd += _match3[0].length;
                          }
                          break;
                        }
                      case "deleteContentBackward":
                        if (selectionStart === selectionEnd) {
                          selStart -= 1;
                        }
                        break;
                      case "deleteContentForward":
                        if (selectionStart === selectionEnd) {
                          selEnd += 1;
                        }
                        break;
                    }
                    event.preventDefault();
                    (_this75$linkService$e4 = _this75.linkService.eventBus) === null || _this75$linkService$e4 === void 0 || _this75$linkService$e4.dispatch("dispatcheventinsandbox", {
                      source: _this75,
                      detail: {
                        id: id,
                        name: "Keystroke",
                        value: value,
                        change: data || "",
                        willCommit: false,
                        selStart: selStart,
                        selEnd: selEnd
                      }
                    });
                  });
                }
                this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
                  return event.target.value;
                });
              }
              if (blurListener) {
                element.addEventListener("blur", blurListener);
              }
              if (this.data.comb) {
                var fieldWidth = this.data.rect[2] - this.data.rect[0];
                var combWidth = fieldWidth / maxLen;
                element.classList.add("comb");
                element.style.letterSpacing = "calc(".concat(combWidth, "px * var(--scale-factor) - 1ch)");
              }
            } else {
              element = document.createElement("div");
              element.textContent = this.data.fieldValue;
              element.style.verticalAlign = "middle";
              element.style.display = "table-cell";
            }
            this._setTextStyle(element);
            this._setBackgroundColor(element);
            this._setDefaultPropertiesFromJS(element);
            this.container.append(element);
            return this.container;
          }
        }]);
      }(WidgetAnnotationElement);
      var SignatureWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {
        function SignatureWidgetAnnotationElement(parameters) {
          _classCallCheck(this, SignatureWidgetAnnotationElement);
          return _callSuper(this, SignatureWidgetAnnotationElement, [parameters, {
            isRenderable: !!parameters.data.hasOwnCanvas
          }]);
        }
        _inherits(SignatureWidgetAnnotationElement, _WidgetAnnotationElem2);
        return _createClass(SignatureWidgetAnnotationElement);
      }(WidgetAnnotationElement);
      var CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {
        function CheckboxWidgetAnnotationElement(parameters) {
          _classCallCheck(this, CheckboxWidgetAnnotationElement);
          return _callSuper(this, CheckboxWidgetAnnotationElement, [parameters, {
            isRenderable: parameters.renderForms
          }]);
        }
        _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem3);
        return _createClass(CheckboxWidgetAnnotationElement, [{
          key: "render",
          value: function render() {
            var _this76 = this;
            var storage = this.annotationStorage;
            var data = this.data;
            var id = data.id;
            var value = storage.getValue(id, {
              value: data.exportValue === data.fieldValue
            }).value;
            if (typeof value === "string") {
              value = value !== "Off";
              storage.setValue(id, {
                value: value
              });
            }
            this.container.classList.add("buttonWidgetAnnotation", "checkBox");
            var element = document.createElement("input");
            GetElementsByNameSet.add(element);
            element.setAttribute("data-element-id", id);
            element.disabled = data.readOnly;
            this._setRequired(element, this.data.required);
            element.type = "checkbox";
            element.name = data.fieldName;
            if (value) {
              element.setAttribute("checked", true);
            }
            element.setAttribute("exportValue", data.exportValue);
            element.tabIndex = DEFAULT_TAB_INDEX;
            element.addEventListener("change", function (event) {
              var _event$target2 = event.target,
                name = _event$target2.name,
                checked = _event$target2.checked;
              var _iterator127 = _createForOfIteratorHelper(_this76._getElementsByName(name, id)),
                _step127;
              try {
                for (_iterator127.s(); !(_step127 = _iterator127.n()).done;) {
                  var checkbox = _step127.value;
                  var curChecked = checked && checkbox.exportValue === data.exportValue;
                  if (checkbox.domElement) {
                    checkbox.domElement.checked = curChecked;
                  }
                  storage.setValue(checkbox.id, {
                    value: curChecked
                  });
                }
              } catch (err) {
                _iterator127.e(err);
              } finally {
                _iterator127.f();
              }
              storage.setValue(id, {
                value: checked
              });
            });
            element.addEventListener("resetform", function (event) {
              var defaultValue = data.defaultFieldValue || "Off";
              event.target.checked = defaultValue === data.exportValue;
            });
            if (this.enableScripting && this.hasJSActions) {
              element.addEventListener("updatefromsandbox", function (jsEvent) {
                var actions = {
                  value: function value(event) {
                    event.target.checked = event.detail.value !== "Off";
                    storage.setValue(id, {
                      value: event.target.checked
                    });
                  }
                };
                _this76._dispatchEventFromSandbox(actions, jsEvent);
              });
              this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
                return event.target.checked;
              });
            }
            this._setBackgroundColor(element);
            this._setDefaultPropertiesFromJS(element);
            this.container.append(element);
            return this.container;
          }
        }]);
      }(WidgetAnnotationElement);
      var RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {
        function RadioButtonWidgetAnnotationElement(parameters) {
          _classCallCheck(this, RadioButtonWidgetAnnotationElement);
          return _callSuper(this, RadioButtonWidgetAnnotationElement, [parameters, {
            isRenderable: parameters.renderForms
          }]);
        }
        _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem4);
        return _createClass(RadioButtonWidgetAnnotationElement, [{
          key: "render",
          value: function render() {
            var _this77 = this;
            this.container.classList.add("buttonWidgetAnnotation", "radioButton");
            var storage = this.annotationStorage;
            var data = this.data;
            var id = data.id;
            var value = storage.getValue(id, {
              value: data.fieldValue === data.buttonValue
            }).value;
            if (typeof value === "string") {
              value = value !== data.buttonValue;
              storage.setValue(id, {
                value: value
              });
            }
            var element = document.createElement("input");
            GetElementsByNameSet.add(element);
            element.setAttribute("data-element-id", id);
            element.disabled = data.readOnly;
            this._setRequired(element, this.data.required);
            element.type = "radio";
            element.name = data.fieldName;
            if (value) {
              element.setAttribute("checked", true);
            }
            element.tabIndex = DEFAULT_TAB_INDEX;
            element.addEventListener("change", function (event) {
              var _event$target3 = event.target,
                name = _event$target3.name,
                checked = _event$target3.checked;
              var _iterator128 = _createForOfIteratorHelper(_this77._getElementsByName(name, id)),
                _step128;
              try {
                for (_iterator128.s(); !(_step128 = _iterator128.n()).done;) {
                  var radio = _step128.value;
                  storage.setValue(radio.id, {
                    value: false
                  });
                }
              } catch (err) {
                _iterator128.e(err);
              } finally {
                _iterator128.f();
              }
              storage.setValue(id, {
                value: checked
              });
            });
            element.addEventListener("resetform", function (event) {
              var defaultValue = data.defaultFieldValue;
              event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
            });
            if (this.enableScripting && this.hasJSActions) {
              var pdfButtonValue = data.buttonValue;
              element.addEventListener("updatefromsandbox", function (jsEvent) {
                var actions = {
                  value: function value(event) {
                    var checked = pdfButtonValue === event.detail.value;
                    var _iterator129 = _createForOfIteratorHelper(_this77._getElementsByName(event.target.name)),
                      _step129;
                    try {
                      for (_iterator129.s(); !(_step129 = _iterator129.n()).done;) {
                        var radio = _step129.value;
                        var curChecked = checked && radio.id === id;
                        if (radio.domElement) {
                          radio.domElement.checked = curChecked;
                        }
                        storage.setValue(radio.id, {
                          value: curChecked
                        });
                      }
                    } catch (err) {
                      _iterator129.e(err);
                    } finally {
                      _iterator129.f();
                    }
                  }
                };
                _this77._dispatchEventFromSandbox(actions, jsEvent);
              });
              this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
                return event.target.checked;
              });
            }
            this._setBackgroundColor(element);
            this._setDefaultPropertiesFromJS(element);
            this.container.append(element);
            return this.container;
          }
        }]);
      }(WidgetAnnotationElement);
      var PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {
        function PushButtonWidgetAnnotationElement(parameters) {
          _classCallCheck(this, PushButtonWidgetAnnotationElement);
          return _callSuper(this, PushButtonWidgetAnnotationElement, [parameters, {
            ignoreBorder: parameters.data.hasAppearance
          }]);
        }
        _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);
        return _createClass(PushButtonWidgetAnnotationElement, [{
          key: "render",
          value: function render() {
            var _this78 = this;
            var container = _superPropGet(PushButtonWidgetAnnotationElement, "render", this, 3)([]);
            container.classList.add("buttonWidgetAnnotation", "pushButton");
            if (this.data.alternativeText) {
              container.title = this.data.alternativeText;
            }
            var linkElement = container.lastChild;
            if (this.enableScripting && this.hasJSActions && linkElement) {
              this._setDefaultPropertiesFromJS(linkElement);
              linkElement.addEventListener("updatefromsandbox", function (jsEvent) {
                _this78._dispatchEventFromSandbox({}, jsEvent);
              });
            }
            return container;
          }
        }]);
      }(LinkAnnotationElement);
      var ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem5) {
        function ChoiceWidgetAnnotationElement(parameters) {
          _classCallCheck(this, ChoiceWidgetAnnotationElement);
          return _callSuper(this, ChoiceWidgetAnnotationElement, [parameters, {
            isRenderable: parameters.renderForms
          }]);
        }
        _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem5);
        return _createClass(ChoiceWidgetAnnotationElement, [{
          key: "render",
          value: function render() {
            var _this79 = this;
            this.container.classList.add("choiceWidgetAnnotation");
            var storage = this.annotationStorage;
            var id = this.data.id;
            var storedData = storage.getValue(id, {
              value: this.data.fieldValue
            });
            var selectElement = document.createElement("select");
            GetElementsByNameSet.add(selectElement);
            selectElement.setAttribute("data-element-id", id);
            selectElement.disabled = this.data.readOnly;
            this._setRequired(selectElement, this.data.required);
            selectElement.name = this.data.fieldName;
            selectElement.tabIndex = DEFAULT_TAB_INDEX;
            var addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
            if (!this.data.combo) {
              selectElement.size = this.data.options.length;
              if (this.data.multiSelect) {
                selectElement.multiple = true;
              }
            }
            selectElement.addEventListener("resetform", function (event) {
              var defaultValue = _this79.data.defaultFieldValue;
              var _iterator130 = _createForOfIteratorHelper(selectElement.options),
                _step130;
              try {
                for (_iterator130.s(); !(_step130 = _iterator130.n()).done;) {
                  var option = _step130.value;
                  option.selected = option.value === defaultValue;
                }
              } catch (err) {
                _iterator130.e(err);
              } finally {
                _iterator130.f();
              }
            });
            var _iterator131 = _createForOfIteratorHelper(this.data.options),
              _step131;
            try {
              for (_iterator131.s(); !(_step131 = _iterator131.n()).done;) {
                var option = _step131.value;
                var optionElement = document.createElement("option");
                optionElement.textContent = option.displayValue;
                optionElement.value = option.exportValue;
                if (storedData.value.includes(option.exportValue)) {
                  optionElement.setAttribute("selected", true);
                  addAnEmptyEntry = false;
                }
                selectElement.append(optionElement);
              }
            } catch (err) {
              _iterator131.e(err);
            } finally {
              _iterator131.f();
            }
            var _removeEmptyEntry = null;
            if (addAnEmptyEntry) {
              var noneOptionElement = document.createElement("option");
              noneOptionElement.value = " ";
              noneOptionElement.setAttribute("hidden", true);
              noneOptionElement.setAttribute("selected", true);
              selectElement.prepend(noneOptionElement);
              _removeEmptyEntry = function removeEmptyEntry() {
                noneOptionElement.remove();
                selectElement.removeEventListener("input", _removeEmptyEntry);
                _removeEmptyEntry = null;
              };
              selectElement.addEventListener("input", _removeEmptyEntry);
            }
            var getValue = function getValue(isExport) {
              var name = isExport ? "value" : "textContent";
              var options = selectElement.options,
                multiple = selectElement.multiple;
              if (!multiple) {
                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
              }
              return Array.prototype.filter.call(options, function (option) {
                return option.selected;
              }).map(function (option) {
                return option[name];
              });
            };
            var selectedValues = getValue(false);
            var getItems = function getItems(event) {
              var options = event.target.options;
              return Array.prototype.map.call(options, function (option) {
                return {
                  displayValue: option.textContent,
                  exportValue: option.value
                };
              });
            };
            if (this.enableScripting && this.hasJSActions) {
              selectElement.addEventListener("updatefromsandbox", function (jsEvent) {
                var actions = {
                  value: function value(event) {
                    var _removeEmptyEntry2;
                    (_removeEmptyEntry2 = _removeEmptyEntry) === null || _removeEmptyEntry2 === void 0 || _removeEmptyEntry2();
                    var value = event.detail.value;
                    var values = new Set(Array.isArray(value) ? value : [value]);
                    var _iterator132 = _createForOfIteratorHelper(selectElement.options),
                      _step132;
                    try {
                      for (_iterator132.s(); !(_step132 = _iterator132.n()).done;) {
                        var option = _step132.value;
                        option.selected = values.has(option.value);
                      }
                    } catch (err) {
                      _iterator132.e(err);
                    } finally {
                      _iterator132.f();
                    }
                    storage.setValue(id, {
                      value: getValue(true)
                    });
                    selectedValues = getValue(false);
                  },
                  multipleSelection: function multipleSelection(event) {
                    selectElement.multiple = true;
                  },
                  remove: function remove(event) {
                    var options = selectElement.options;
                    var index = event.detail.remove;
                    options[index].selected = false;
                    selectElement.remove(index);
                    if (options.length > 0) {
                      var i = Array.prototype.findIndex.call(options, function (option) {
                        return option.selected;
                      });
                      if (i === -1) {
                        options[0].selected = true;
                      }
                    }
                    storage.setValue(id, {
                      value: getValue(true),
                      items: getItems(event)
                    });
                    selectedValues = getValue(false);
                  },
                  clear: function clear(event) {
                    while (selectElement.length !== 0) {
                      selectElement.remove(0);
                    }
                    storage.setValue(id, {
                      value: null,
                      items: []
                    });
                    selectedValues = getValue(false);
                  },
                  insert: function insert(event) {
                    var _event$detail$insert = event.detail.insert,
                      index = _event$detail$insert.index,
                      displayValue = _event$detail$insert.displayValue,
                      exportValue = _event$detail$insert.exportValue;
                    var selectChild = selectElement.children[index];
                    var optionElement = document.createElement("option");
                    optionElement.textContent = displayValue;
                    optionElement.value = exportValue;
                    if (selectChild) {
                      selectChild.before(optionElement);
                    } else {
                      selectElement.append(optionElement);
                    }
                    storage.setValue(id, {
                      value: getValue(true),
                      items: getItems(event)
                    });
                    selectedValues = getValue(false);
                  },
                  items: function items(event) {
                    var items = event.detail.items;
                    while (selectElement.length !== 0) {
                      selectElement.remove(0);
                    }
                    var _iterator133 = _createForOfIteratorHelper(items),
                      _step133;
                    try {
                      for (_iterator133.s(); !(_step133 = _iterator133.n()).done;) {
                        var item = _step133.value;
                        var displayValue = item.displayValue,
                          exportValue = item.exportValue;
                        var optionElement = document.createElement("option");
                        optionElement.textContent = displayValue;
                        optionElement.value = exportValue;
                        selectElement.append(optionElement);
                      }
                    } catch (err) {
                      _iterator133.e(err);
                    } finally {
                      _iterator133.f();
                    }
                    if (selectElement.options.length > 0) {
                      selectElement.options[0].selected = true;
                    }
                    storage.setValue(id, {
                      value: getValue(true),
                      items: getItems(event)
                    });
                    selectedValues = getValue(false);
                  },
                  indices: function indices(event) {
                    var indices = new Set(event.detail.indices);
                    var _iterator134 = _createForOfIteratorHelper(event.target.options),
                      _step134;
                    try {
                      for (_iterator134.s(); !(_step134 = _iterator134.n()).done;) {
                        var option = _step134.value;
                        option.selected = indices.has(option.index);
                      }
                    } catch (err) {
                      _iterator134.e(err);
                    } finally {
                      _iterator134.f();
                    }
                    storage.setValue(id, {
                      value: getValue(true)
                    });
                    selectedValues = getValue(false);
                  },
                  editable: function editable(event) {
                    event.target.disabled = !event.detail.editable;
                  }
                };
                _this79._dispatchEventFromSandbox(actions, jsEvent);
              });
              selectElement.addEventListener("input", function (event) {
                var _this79$linkService$e;
                var exportValue = getValue(true);
                storage.setValue(id, {
                  value: exportValue
                });
                event.preventDefault();
                (_this79$linkService$e = _this79.linkService.eventBus) === null || _this79$linkService$e === void 0 || _this79$linkService$e.dispatch("dispatcheventinsandbox", {
                  source: _this79,
                  detail: {
                    id: id,
                    name: "Keystroke",
                    value: selectedValues,
                    changeEx: exportValue,
                    willCommit: false,
                    commitKey: 1,
                    keyDown: false
                  }
                });
              });
              this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], function (event) {
                return event.target.value;
              });
            } else {
              selectElement.addEventListener("input", function (event) {
                storage.setValue(id, {
                  value: getValue(true)
                });
              });
            }
            if (this.data.combo) {
              this._setTextStyle(selectElement);
            } else {}
            this._setBackgroundColor(selectElement);
            this._setDefaultPropertiesFromJS(selectElement);
            this.container.append(selectElement);
            return this.container;
          }
        }]);
      }(WidgetAnnotationElement);
      var PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {
        function PopupAnnotationElement(parameters) {
          var _this80;
          _classCallCheck(this, PopupAnnotationElement);
          var data = parameters.data,
            elements = parameters.elements;
          _this80 = _callSuper(this, PopupAnnotationElement, [parameters, {
            isRenderable: AnnotationElement._hasPopupData(data)
          }]);
          _this80.elements = elements;
          return _this80;
        }
        _inherits(PopupAnnotationElement, _AnnotationElement5);
        return _createClass(PopupAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("popupAnnotation");
            var popup = new PopupElement({
              container: this.container,
              color: this.data.color,
              titleObj: this.data.titleObj,
              modificationDate: this.data.modificationDate,
              contentsObj: this.data.contentsObj,
              richText: this.data.richText,
              rect: this.data.rect,
              parentRect: this.data.parentRect || null,
              parent: this.parent,
              elements: this.elements,
              open: this.data.open
            });
            var elementIds = [];
            var _iterator135 = _createForOfIteratorHelper(this.elements),
              _step135;
            try {
              for (_iterator135.s(); !(_step135 = _iterator135.n()).done;) {
                var element = _step135.value;
                element.popup = popup;
                elementIds.push(element.data.id);
                element.addHighlightArea();
              }
            } catch (err) {
              _iterator135.e(err);
            } finally {
              _iterator135.f();
            }
            this.container.setAttribute("aria-controls", elementIds.map(function (id) {
              return "".concat(_util.AnnotationPrefix).concat(id);
            }).join(","));
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var _dateTimePromise = /*#__PURE__*/new WeakMap();
      var _boundKeyDown = /*#__PURE__*/new WeakMap();
      var _boundHide = /*#__PURE__*/new WeakMap();
      var _boundShow = /*#__PURE__*/new WeakMap();
      var _boundToggle = /*#__PURE__*/new WeakMap();
      var _color2 = /*#__PURE__*/new WeakMap();
      var _container2 = /*#__PURE__*/new WeakMap();
      var _contentsObj = /*#__PURE__*/new WeakMap();
      var _elements = /*#__PURE__*/new WeakMap();
      var _parent = /*#__PURE__*/new WeakMap();
      var _parentRect = /*#__PURE__*/new WeakMap();
      var _pinned = /*#__PURE__*/new WeakMap();
      var _popup = /*#__PURE__*/new WeakMap();
      var _rect2 = /*#__PURE__*/new WeakMap();
      var _richText = /*#__PURE__*/new WeakMap();
      var _titleObj = /*#__PURE__*/new WeakMap();
      var _wasVisible = /*#__PURE__*/new WeakMap();
      var _PopupElement_brand = /*#__PURE__*/new WeakSet();
      var PopupElement = /*#__PURE__*/function () {
        function PopupElement(_ref77) {
          var container = _ref77.container,
            color = _ref77.color,
            elements = _ref77.elements,
            titleObj = _ref77.titleObj,
            modificationDate = _ref77.modificationDate,
            contentsObj = _ref77.contentsObj,
            richText = _ref77.richText,
            parent = _ref77.parent,
            rect = _ref77.rect,
            parentRect = _ref77.parentRect,
            open = _ref77.open;
          _classCallCheck(this, PopupElement);
          _classPrivateMethodInitSpec(this, _PopupElement_brand);
          _classPrivateFieldInitSpec(this, _dateTimePromise, null);
          _classPrivateFieldInitSpec(this, _boundKeyDown, _assertClassBrand(_PopupElement_brand, this, _keyDown).bind(this));
          _classPrivateFieldInitSpec(this, _boundHide, _assertClassBrand(_PopupElement_brand, this, _hide).bind(this));
          _classPrivateFieldInitSpec(this, _boundShow, _assertClassBrand(_PopupElement_brand, this, _show).bind(this));
          _classPrivateFieldInitSpec(this, _boundToggle, _assertClassBrand(_PopupElement_brand, this, _toggle).bind(this));
          _classPrivateFieldInitSpec(this, _color2, null);
          _classPrivateFieldInitSpec(this, _container2, null);
          _classPrivateFieldInitSpec(this, _contentsObj, null);
          _classPrivateFieldInitSpec(this, _elements, null);
          _classPrivateFieldInitSpec(this, _parent, null);
          _classPrivateFieldInitSpec(this, _parentRect, null);
          _classPrivateFieldInitSpec(this, _pinned, false);
          _classPrivateFieldInitSpec(this, _popup, null);
          _classPrivateFieldInitSpec(this, _rect2, null);
          _classPrivateFieldInitSpec(this, _richText, null);
          _classPrivateFieldInitSpec(this, _titleObj, null);
          _classPrivateFieldInitSpec(this, _wasVisible, false);
          _classPrivateFieldSet(_container2, this, container);
          _classPrivateFieldSet(_titleObj, this, titleObj);
          _classPrivateFieldSet(_contentsObj, this, contentsObj);
          _classPrivateFieldSet(_richText, this, richText);
          _classPrivateFieldSet(_parent, this, parent);
          _classPrivateFieldSet(_color2, this, color);
          _classPrivateFieldSet(_rect2, this, rect);
          _classPrivateFieldSet(_parentRect, this, parentRect);
          _classPrivateFieldSet(_elements, this, elements);
          var dateObject = _display_utils.PDFDateString.toDateObject(modificationDate);
          if (dateObject) {
            _classPrivateFieldSet(_dateTimePromise, this, parent.l10n.get("annotation_date_string", {
              date: dateObject.toLocaleDateString(),
              time: dateObject.toLocaleTimeString()
            }));
          }
          this.trigger = elements.flatMap(function (e) {
            return e.getElementsToTriggerPopup();
          });
          var _iterator136 = _createForOfIteratorHelper(this.trigger),
            _step136;
          try {
            for (_iterator136.s(); !(_step136 = _iterator136.n()).done;) {
              var element = _step136.value;
              element.addEventListener("click", _classPrivateFieldGet(_boundToggle, this));
              element.addEventListener("mouseenter", _classPrivateFieldGet(_boundShow, this));
              element.addEventListener("mouseleave", _classPrivateFieldGet(_boundHide, this));
              element.classList.add("popupTriggerArea");
            }
          } catch (err) {
            _iterator136.e(err);
          } finally {
            _iterator136.f();
          }
          var _iterator137 = _createForOfIteratorHelper(elements),
            _step137;
          try {
            for (_iterator137.s(); !(_step137 = _iterator137.n()).done;) {
              var _element$container;
              var _element = _step137.value;
              (_element$container = _element.container) === null || _element$container === void 0 || _element$container.addEventListener("keydown", _classPrivateFieldGet(_boundKeyDown, this));
            }
          } catch (err) {
            _iterator137.e(err);
          } finally {
            _iterator137.f();
          }
          _classPrivateFieldGet(_container2, this).hidden = true;
          if (open) {
            _assertClassBrand(_PopupElement_brand, this, _toggle).call(this);
          }
        }
        return _createClass(PopupElement, [{
          key: "render",
          value: function render() {
            if (_classPrivateFieldGet(_popup, this)) {
              return;
            }
            var _classPrivateFieldGet28 = _classPrivateFieldGet(_parent, this),
              view = _classPrivateFieldGet28.page.view,
              _classPrivateFieldGet29 = _classPrivateFieldGet28.viewport.rawDims,
              pageWidth = _classPrivateFieldGet29.pageWidth,
              pageHeight = _classPrivateFieldGet29.pageHeight,
              pageX = _classPrivateFieldGet29.pageX,
              pageY = _classPrivateFieldGet29.pageY;
            var popup = _classPrivateFieldSet(_popup, this, document.createElement("div"));
            popup.className = "popup";
            if (_classPrivateFieldGet(_color2, this)) {
              var _util$Util6;
              var baseColor = popup.style.outlineColor = (_util$Util6 = _util.Util).makeHexColor.apply(_util$Util6, _toConsumableArray(_classPrivateFieldGet(_color2, this)));
              if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
                popup.style.backgroundColor = "color-mix(in srgb, ".concat(baseColor, " 30%, white)");
              } else {
                var _util$Util7;
                var BACKGROUND_ENLIGHT = 0.7;
                popup.style.backgroundColor = (_util$Util7 = _util.Util).makeHexColor.apply(_util$Util7, _toConsumableArray(_classPrivateFieldGet(_color2, this).map(function (c) {
                  return Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c);
                })));
              }
            }
            var header = document.createElement("span");
            header.className = "header";
            var title = document.createElement("h1");
            header.append(title);
            var _classPrivateFieldGet30 = _classPrivateFieldGet(_titleObj, this);
            title.dir = _classPrivateFieldGet30.dir;
            title.textContent = _classPrivateFieldGet30.str;
            popup.append(header);
            if (_classPrivateFieldGet(_dateTimePromise, this)) {
              var modificationDate = document.createElement("span");
              modificationDate.classList.add("popupDate");
              _classPrivateFieldGet(_dateTimePromise, this).then(function (localized) {
                modificationDate.textContent = localized;
              });
              header.append(modificationDate);
            }
            var contentsObj = _classPrivateFieldGet(_contentsObj, this);
            var richText = _classPrivateFieldGet(_richText, this);
            if (richText !== null && richText !== void 0 && richText.str && (!(contentsObj !== null && contentsObj !== void 0 && contentsObj.str) || contentsObj.str === richText.str)) {
              _xfa_layer.XfaLayer.render({
                xfaHtml: richText.html,
                intent: "richText",
                div: popup
              });
              popup.lastChild.classList.add("richText", "popupContent");
            } else {
              var contents = this._formatContents(contentsObj);
              popup.append(contents);
            }
            var useParentRect = !!_classPrivateFieldGet(_parentRect, this);
            var rect = useParentRect ? _classPrivateFieldGet(_parentRect, this) : _classPrivateFieldGet(_rect2, this);
            var _iterator138 = _createForOfIteratorHelper(_classPrivateFieldGet(_elements, this)),
              _step138;
            try {
              for (_iterator138.s(); !(_step138 = _iterator138.n()).done;) {
                var element = _step138.value;
                if (!rect || _util.Util.intersect(element.data.rect, rect) !== null) {
                  rect = element.data.rect;
                  useParentRect = true;
                  break;
                }
              }
            } catch (err) {
              _iterator138.e(err);
            } finally {
              _iterator138.f();
            }
            var normalizedRect = _util.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
            var HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
            var parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
            var popupLeft = normalizedRect[0] + parentWidth;
            var popupTop = normalizedRect[1];
            var _classPrivateFieldGet31 = _classPrivateFieldGet(_container2, this),
              style = _classPrivateFieldGet31.style;
            style.left = "".concat(100 * (popupLeft - pageX) / pageWidth, "%");
            style.top = "".concat(100 * (popupTop - pageY) / pageHeight, "%");
            _classPrivateFieldGet(_container2, this).append(popup);
          }
        }, {
          key: "_formatContents",
          value: function _formatContents(_ref78) {
            var str = _ref78.str,
              dir = _ref78.dir;
            var p = document.createElement("p");
            p.classList.add("popupContent");
            p.dir = dir;
            var lines = str.split(/(?:\r\n?|\n)/);
            for (var i = 0, ii = lines.length; i < ii; ++i) {
              var line = lines[i];
              p.append(document.createTextNode(line));
              if (i < ii - 1) {
                p.append(document.createElement("br"));
              }
            }
            return p;
          }
        }, {
          key: "forceHide",
          value: function forceHide() {
            _classPrivateFieldSet(_wasVisible, this, this.isVisible);
            if (!_classPrivateFieldGet(_wasVisible, this)) {
              return;
            }
            _classPrivateFieldGet(_container2, this).hidden = true;
          }
        }, {
          key: "maybeShow",
          value: function maybeShow() {
            if (!_classPrivateFieldGet(_wasVisible, this)) {
              return;
            }
            _classPrivateFieldSet(_wasVisible, this, false);
            _classPrivateFieldGet(_container2, this).hidden = false;
          }
        }, {
          key: "isVisible",
          get: function get() {
            return _classPrivateFieldGet(_container2, this).hidden === false;
          }
        }]);
      }();
      function _keyDown(event) {
        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
          return;
        }
        if (event.key === "Enter" || event.key === "Escape" && _classPrivateFieldGet(_pinned, this)) {
          _assertClassBrand(_PopupElement_brand, this, _toggle).call(this);
        }
      }
      function _toggle() {
        _classPrivateFieldSet(_pinned, this, !_classPrivateFieldGet(_pinned, this));
        if (_classPrivateFieldGet(_pinned, this)) {
          _assertClassBrand(_PopupElement_brand, this, _show).call(this);
          _classPrivateFieldGet(_container2, this).addEventListener("click", _classPrivateFieldGet(_boundToggle, this));
          _classPrivateFieldGet(_container2, this).addEventListener("keydown", _classPrivateFieldGet(_boundKeyDown, this));
        } else {
          _assertClassBrand(_PopupElement_brand, this, _hide).call(this);
          _classPrivateFieldGet(_container2, this).removeEventListener("click", _classPrivateFieldGet(_boundToggle, this));
          _classPrivateFieldGet(_container2, this).removeEventListener("keydown", _classPrivateFieldGet(_boundKeyDown, this));
        }
      }
      function _show() {
        if (!_classPrivateFieldGet(_popup, this)) {
          this.render();
        }
        if (!this.isVisible) {
          _classPrivateFieldGet(_container2, this).hidden = false;
          _classPrivateFieldGet(_container2, this).style.zIndex = parseInt(_classPrivateFieldGet(_container2, this).style.zIndex) + 1000;
        } else if (_classPrivateFieldGet(_pinned, this)) {
          _classPrivateFieldGet(_container2, this).classList.add("focused");
        }
      }
      function _hide() {
        _classPrivateFieldGet(_container2, this).classList.remove("focused");
        if (_classPrivateFieldGet(_pinned, this) || !this.isVisible) {
          return;
        }
        _classPrivateFieldGet(_container2, this).hidden = true;
        _classPrivateFieldGet(_container2, this).style.zIndex = parseInt(_classPrivateFieldGet(_container2, this).style.zIndex) - 1000;
      }
      var FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {
        function FreeTextAnnotationElement(parameters) {
          var _this81;
          _classCallCheck(this, FreeTextAnnotationElement);
          _this81 = _callSuper(this, FreeTextAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
          _this81.textContent = parameters.data.textContent;
          _this81.textPosition = parameters.data.textPosition;
          _this81.annotationEditorType = _util.AnnotationEditorType.FREETEXT;
          return _this81;
        }
        _inherits(FreeTextAnnotationElement, _AnnotationElement6);
        return _createClass(FreeTextAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("freeTextAnnotation");
            if (this.textContent) {
              var content = document.createElement("div");
              content.classList.add("annotationTextContent");
              content.setAttribute("role", "comment");
              var _iterator139 = _createForOfIteratorHelper(this.textContent),
                _step139;
              try {
                for (_iterator139.s(); !(_step139 = _iterator139.n()).done;) {
                  var line = _step139.value;
                  var lineSpan = document.createElement("span");
                  lineSpan.textContent = line;
                  content.append(lineSpan);
                }
              } catch (err) {
                _iterator139.e(err);
              } finally {
                _iterator139.f();
              }
              this.container.append(content);
            }
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            this._editOnDoubleClick();
            return this.container;
          }
        }]);
      }(AnnotationElement);
      exports.FreeTextAnnotationElement = FreeTextAnnotationElement;
      var _line = /*#__PURE__*/new WeakMap();
      var LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {
        function LineAnnotationElement(parameters) {
          var _this82;
          _classCallCheck(this, LineAnnotationElement);
          _this82 = _callSuper(this, LineAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
          _classPrivateFieldInitSpec(_this82, _line, null);
          return _this82;
        }
        _inherits(LineAnnotationElement, _AnnotationElement7);
        return _createClass(LineAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("lineAnnotation");
            var data = this.data;
            var _getRectDims3 = getRectDims(data.rect),
              width = _getRectDims3.width,
              height = _getRectDims3.height;
            var svg = this.svgFactory.create(width, height, true);
            var line = _classPrivateFieldSet(_line, this, this.svgFactory.createElement("svg:line"));
            line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
            line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
            line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
            line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
            line.setAttribute("stroke-width", data.borderStyle.width || 1);
            line.setAttribute("stroke", "transparent");
            line.setAttribute("fill", "transparent");
            svg.append(line);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            return this.container;
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return _classPrivateFieldGet(_line, this);
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }]);
      }(AnnotationElement);
      var _square = /*#__PURE__*/new WeakMap();
      var SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {
        function SquareAnnotationElement(parameters) {
          var _this83;
          _classCallCheck(this, SquareAnnotationElement);
          _this83 = _callSuper(this, SquareAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
          _classPrivateFieldInitSpec(_this83, _square, null);
          return _this83;
        }
        _inherits(SquareAnnotationElement, _AnnotationElement8);
        return _createClass(SquareAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("squareAnnotation");
            var data = this.data;
            var _getRectDims4 = getRectDims(data.rect),
              width = _getRectDims4.width,
              height = _getRectDims4.height;
            var svg = this.svgFactory.create(width, height, true);
            var borderWidth = data.borderStyle.width;
            var square = _classPrivateFieldSet(_square, this, this.svgFactory.createElement("svg:rect"));
            square.setAttribute("x", borderWidth / 2);
            square.setAttribute("y", borderWidth / 2);
            square.setAttribute("width", width - borderWidth);
            square.setAttribute("height", height - borderWidth);
            square.setAttribute("stroke-width", borderWidth || 1);
            square.setAttribute("stroke", "transparent");
            square.setAttribute("fill", "transparent");
            svg.append(square);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            return this.container;
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return _classPrivateFieldGet(_square, this);
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }]);
      }(AnnotationElement);
      var _circle = /*#__PURE__*/new WeakMap();
      var CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {
        function CircleAnnotationElement(parameters) {
          var _this84;
          _classCallCheck(this, CircleAnnotationElement);
          _this84 = _callSuper(this, CircleAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
          _classPrivateFieldInitSpec(_this84, _circle, null);
          return _this84;
        }
        _inherits(CircleAnnotationElement, _AnnotationElement9);
        return _createClass(CircleAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("circleAnnotation");
            var data = this.data;
            var _getRectDims5 = getRectDims(data.rect),
              width = _getRectDims5.width,
              height = _getRectDims5.height;
            var svg = this.svgFactory.create(width, height, true);
            var borderWidth = data.borderStyle.width;
            var circle = _classPrivateFieldSet(_circle, this, this.svgFactory.createElement("svg:ellipse"));
            circle.setAttribute("cx", width / 2);
            circle.setAttribute("cy", height / 2);
            circle.setAttribute("rx", width / 2 - borderWidth / 2);
            circle.setAttribute("ry", height / 2 - borderWidth / 2);
            circle.setAttribute("stroke-width", borderWidth || 1);
            circle.setAttribute("stroke", "transparent");
            circle.setAttribute("fill", "transparent");
            svg.append(circle);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            return this.container;
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return _classPrivateFieldGet(_circle, this);
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }]);
      }(AnnotationElement);
      var _polyline = /*#__PURE__*/new WeakMap();
      var PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {
        function PolylineAnnotationElement(parameters) {
          var _this85;
          _classCallCheck(this, PolylineAnnotationElement);
          _this85 = _callSuper(this, PolylineAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
          _classPrivateFieldInitSpec(_this85, _polyline, null);
          _this85.containerClassName = "polylineAnnotation";
          _this85.svgElementName = "svg:polyline";
          return _this85;
        }
        _inherits(PolylineAnnotationElement, _AnnotationElement10);
        return _createClass(PolylineAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add(this.containerClassName);
            var data = this.data;
            var _getRectDims6 = getRectDims(data.rect),
              width = _getRectDims6.width,
              height = _getRectDims6.height;
            var svg = this.svgFactory.create(width, height, true);
            var points = [];
            var _iterator140 = _createForOfIteratorHelper(data.vertices),
              _step140;
            try {
              for (_iterator140.s(); !(_step140 = _iterator140.n()).done;) {
                var coordinate = _step140.value;
                var x = coordinate.x - data.rect[0];
                var y = data.rect[3] - coordinate.y;
                points.push(x + "," + y);
              }
            } catch (err) {
              _iterator140.e(err);
            } finally {
              _iterator140.f();
            }
            points = points.join(" ");
            var polyline = _classPrivateFieldSet(_polyline, this, this.svgFactory.createElement(this.svgElementName));
            polyline.setAttribute("points", points);
            polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
            polyline.setAttribute("stroke", "transparent");
            polyline.setAttribute("fill", "transparent");
            svg.append(polyline);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            return this.container;
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return _classPrivateFieldGet(_polyline, this);
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }]);
      }(AnnotationElement);
      var PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {
        function PolygonAnnotationElement(parameters) {
          var _this86;
          _classCallCheck(this, PolygonAnnotationElement);
          _this86 = _callSuper(this, PolygonAnnotationElement, [parameters]);
          _this86.containerClassName = "polygonAnnotation";
          _this86.svgElementName = "svg:polygon";
          return _this86;
        }
        _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);
        return _createClass(PolygonAnnotationElement);
      }(PolylineAnnotationElement);
      var CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {
        function CaretAnnotationElement(parameters) {
          _classCallCheck(this, CaretAnnotationElement);
          return _callSuper(this, CaretAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
        }
        _inherits(CaretAnnotationElement, _AnnotationElement11);
        return _createClass(CaretAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("caretAnnotation");
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var _polylines = /*#__PURE__*/new WeakMap();
      var InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {
        function InkAnnotationElement(parameters) {
          var _this87;
          _classCallCheck(this, InkAnnotationElement);
          _this87 = _callSuper(this, InkAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
          _classPrivateFieldInitSpec(_this87, _polylines, []);
          _this87.containerClassName = "inkAnnotation";
          _this87.svgElementName = "svg:polyline";
          _this87.annotationEditorType = _util.AnnotationEditorType.INK;
          return _this87;
        }
        _inherits(InkAnnotationElement, _AnnotationElement12);
        return _createClass(InkAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add(this.containerClassName);
            var data = this.data;
            var _getRectDims7 = getRectDims(data.rect),
              width = _getRectDims7.width,
              height = _getRectDims7.height;
            var svg = this.svgFactory.create(width, height, true);
            var _iterator141 = _createForOfIteratorHelper(data.inkLists),
              _step141;
            try {
              for (_iterator141.s(); !(_step141 = _iterator141.n()).done;) {
                var inkList = _step141.value;
                var points = [];
                var _iterator142 = _createForOfIteratorHelper(inkList),
                  _step142;
                try {
                  for (_iterator142.s(); !(_step142 = _iterator142.n()).done;) {
                    var coordinate = _step142.value;
                    var x = coordinate.x - data.rect[0];
                    var y = data.rect[3] - coordinate.y;
                    points.push("".concat(x, ",").concat(y));
                  }
                } catch (err) {
                  _iterator142.e(err);
                } finally {
                  _iterator142.f();
                }
                points = points.join(" ");
                var polyline = this.svgFactory.createElement(this.svgElementName);
                _classPrivateFieldGet(_polylines, this).push(polyline);
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                polyline.setAttribute("stroke", "transparent");
                polyline.setAttribute("fill", "transparent");
                if (!data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                svg.append(polyline);
              }
            } catch (err) {
              _iterator141.e(err);
            } finally {
              _iterator141.f();
            }
            this.container.append(svg);
            return this.container;
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return _classPrivateFieldGet(_polylines, this);
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }]);
      }(AnnotationElement);
      exports.InkAnnotationElement = InkAnnotationElement;
      var HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {
        function HighlightAnnotationElement(parameters) {
          _classCallCheck(this, HighlightAnnotationElement);
          return _callSuper(this, HighlightAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
          }]);
        }
        _inherits(HighlightAnnotationElement, _AnnotationElement13);
        return _createClass(HighlightAnnotationElement, [{
          key: "render",
          value: function render() {
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            this.container.classList.add("highlightAnnotation");
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {
        function UnderlineAnnotationElement(parameters) {
          _classCallCheck(this, UnderlineAnnotationElement);
          return _callSuper(this, UnderlineAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
          }]);
        }
        _inherits(UnderlineAnnotationElement, _AnnotationElement14);
        return _createClass(UnderlineAnnotationElement, [{
          key: "render",
          value: function render() {
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            this.container.classList.add("underlineAnnotation");
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {
        function SquigglyAnnotationElement(parameters) {
          _classCallCheck(this, SquigglyAnnotationElement);
          return _callSuper(this, SquigglyAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
          }]);
        }
        _inherits(SquigglyAnnotationElement, _AnnotationElement15);
        return _createClass(SquigglyAnnotationElement, [{
          key: "render",
          value: function render() {
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            this.container.classList.add("squigglyAnnotation");
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {
        function StrikeOutAnnotationElement(parameters) {
          _classCallCheck(this, StrikeOutAnnotationElement);
          return _callSuper(this, StrikeOutAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
          }]);
        }
        _inherits(StrikeOutAnnotationElement, _AnnotationElement16);
        return _createClass(StrikeOutAnnotationElement, [{
          key: "render",
          value: function render() {
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            this.container.classList.add("strikeoutAnnotation");
            return this.container;
          }
        }]);
      }(AnnotationElement);
      var StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {
        function StampAnnotationElement(parameters) {
          _classCallCheck(this, StampAnnotationElement);
          return _callSuper(this, StampAnnotationElement, [parameters, {
            isRenderable: true,
            ignoreBorder: true
          }]);
        }
        _inherits(StampAnnotationElement, _AnnotationElement17);
        return _createClass(StampAnnotationElement, [{
          key: "render",
          value: function render() {
            this.container.classList.add("stampAnnotation");
            if (!this.data.popupRef && this.hasPopupData) {
              this._createPopup();
            }
            return this.container;
          }
        }]);
      }(AnnotationElement);
      exports.StampAnnotationElement = StampAnnotationElement;
      var _trigger = /*#__PURE__*/new WeakMap();
      var _FileAttachmentAnnotationElement_brand = /*#__PURE__*/new WeakSet();
      var FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement18) {
        function FileAttachmentAnnotationElement(parameters) {
          var _this88$linkService$e;
          var _this88;
          _classCallCheck(this, FileAttachmentAnnotationElement);
          _this88 = _callSuper(this, FileAttachmentAnnotationElement, [parameters, {
            isRenderable: true
          }]);
          _classPrivateMethodInitSpec(_this88, _FileAttachmentAnnotationElement_brand);
          _classPrivateFieldInitSpec(_this88, _trigger, null);
          var _this88$data$file = _this88.data.file,
            filename = _this88$data$file.filename,
            content = _this88$data$file.content;
          _this88.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);
          _this88.content = content;
          (_this88$linkService$e = _this88.linkService.eventBus) === null || _this88$linkService$e === void 0 || _this88$linkService$e.dispatch("fileattachmentannotation", {
            source: _this88,
            filename: filename,
            content: content
          });
          return _this88;
        }
        _inherits(FileAttachmentAnnotationElement, _AnnotationElement18);
        return _createClass(FileAttachmentAnnotationElement, [{
          key: "render",
          value: function render() {
            var _this89 = this;
            this.container.classList.add("fileAttachmentAnnotation");
            var container = this.container,
              data = this.data;
            var trigger;
            if (data.hasAppearance || data.fillAlpha === 0) {
              trigger = document.createElement("div");
            } else {
              trigger = document.createElement("img");
              trigger.src = "".concat(this.imageResourcesPath, "annotation-").concat(/paperclip/i.test(data.name) ? "paperclip" : "pushpin", ".svg");
              if (data.fillAlpha && data.fillAlpha < 1) {
                trigger.style = "filter: opacity(".concat(Math.round(data.fillAlpha * 100), "%);");
              }
            }
            trigger.addEventListener("dblclick", _assertClassBrand(_FileAttachmentAnnotationElement_brand, this, _download).bind(this));
            _classPrivateFieldSet(_trigger, this, trigger);
            var isMac = _util.FeatureTest.platform.isMac;
            container.addEventListener("keydown", function (evt) {
              if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
                _assertClassBrand(_FileAttachmentAnnotationElement_brand, _this89, _download).call(_this89);
              }
            });
            if (!data.popupRef && this.hasPopupData) {
              this._createPopup();
            } else {
              trigger.classList.add("popupTriggerArea");
            }
            container.append(trigger);
            return container;
          }
        }, {
          key: "getElementsToTriggerPopup",
          value: function getElementsToTriggerPopup() {
            return _classPrivateFieldGet(_trigger, this);
          }
        }, {
          key: "addHighlightArea",
          value: function addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }]);
      }(AnnotationElement);
      function _download() {
        var _this$downloadManager;
        (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 || _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
      }
      var _accessibilityManager2 = /*#__PURE__*/new WeakMap();
      var _annotationCanvasMap = /*#__PURE__*/new WeakMap();
      var _editableAnnotations = /*#__PURE__*/new WeakMap();
      var _AnnotationLayer_brand = /*#__PURE__*/new WeakSet();
      var AnnotationLayer = /*#__PURE__*/function () {
        function AnnotationLayer(_ref79) {
          var div = _ref79.div,
            accessibilityManager = _ref79.accessibilityManager,
            annotationCanvasMap = _ref79.annotationCanvasMap,
            l10n = _ref79.l10n,
            page = _ref79.page,
            viewport = _ref79.viewport;
          _classCallCheck(this, AnnotationLayer);
          _classPrivateMethodInitSpec(this, _AnnotationLayer_brand);
          _classPrivateFieldInitSpec(this, _accessibilityManager2, null);
          _classPrivateFieldInitSpec(this, _annotationCanvasMap, null);
          _classPrivateFieldInitSpec(this, _editableAnnotations, new Map());
          this.div = div;
          _classPrivateFieldSet(_accessibilityManager2, this, accessibilityManager);
          _classPrivateFieldSet(_annotationCanvasMap, this, annotationCanvasMap);
          this.l10n = l10n;
          this.page = page;
          this.viewport = viewport;
          this.zIndex = 0;
          this.l10n || (this.l10n = _displayL10n_utils.NullL10n);
        }
        return _createClass(AnnotationLayer, [{
          key: "render",
          value: function () {
            var _render2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(params) {
              var annotations, layer, popupToElements, elementParams, _iterator143, _step143, data, isPopupAnnotation, _getRectDims8, width, height, elements, element, _elements2, rendered;
              return _regeneratorRuntime().wrap(function _callee28$(_context28) {
                while (1) switch (_context28.prev = _context28.next) {
                  case 0:
                    annotations = params.annotations;
                    layer = this.div;
                    (0, _display_utils.setLayerDimensions)(layer, this.viewport);
                    popupToElements = new Map();
                    elementParams = {
                      data: null,
                      layer: layer,
                      linkService: params.linkService,
                      downloadManager: params.downloadManager,
                      imageResourcesPath: params.imageResourcesPath || "",
                      renderForms: params.renderForms !== false,
                      svgFactory: new _display_utils.DOMSVGFactory(),
                      annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),
                      enableScripting: params.enableScripting === true,
                      hasJSActions: params.hasJSActions,
                      fieldObjects: params.fieldObjects,
                      parent: this,
                      elements: null
                    };
                    _iterator143 = _createForOfIteratorHelper(annotations);
                    _context28.prev = 6;
                    _iterator143.s();
                  case 8:
                    if ((_step143 = _iterator143.n()).done) {
                      _context28.next = 34;
                      break;
                    }
                    data = _step143.value;
                    if (!data.noHTML) {
                      _context28.next = 12;
                      break;
                    }
                    return _context28.abrupt("continue", 32);
                  case 12:
                    isPopupAnnotation = data.annotationType === _util.AnnotationType.POPUP;
                    if (isPopupAnnotation) {
                      _context28.next = 19;
                      break;
                    }
                    _getRectDims8 = getRectDims(data.rect), width = _getRectDims8.width, height = _getRectDims8.height;
                    if (!(width <= 0 || height <= 0)) {
                      _context28.next = 17;
                      break;
                    }
                    return _context28.abrupt("continue", 32);
                  case 17:
                    _context28.next = 23;
                    break;
                  case 19:
                    elements = popupToElements.get(data.id);
                    if (elements) {
                      _context28.next = 22;
                      break;
                    }
                    return _context28.abrupt("continue", 32);
                  case 22:
                    elementParams.elements = elements;
                  case 23:
                    elementParams.data = data;
                    element = AnnotationElementFactory.create(elementParams);
                    if (element.isRenderable) {
                      _context28.next = 27;
                      break;
                    }
                    return _context28.abrupt("continue", 32);
                  case 27:
                    if (!isPopupAnnotation && data.popupRef) {
                      _elements2 = popupToElements.get(data.popupRef);
                      if (!_elements2) {
                        popupToElements.set(data.popupRef, [element]);
                      } else {
                        _elements2.push(element);
                      }
                    }
                    if (element.annotationEditorType > 0) {
                      _classPrivateFieldGet(_editableAnnotations, this).set(element.data.id, element);
                    }
                    rendered = element.render();
                    if (data.hidden) {
                      rendered.style.visibility = "hidden";
                    }
                    _assertClassBrand(_AnnotationLayer_brand, this, _appendElement).call(this, rendered, data.id);
                  case 32:
                    _context28.next = 8;
                    break;
                  case 34:
                    _context28.next = 39;
                    break;
                  case 36:
                    _context28.prev = 36;
                    _context28.t0 = _context28["catch"](6);
                    _iterator143.e(_context28.t0);
                  case 39:
                    _context28.prev = 39;
                    _iterator143.f();
                    return _context28.finish(39);
                  case 42:
                    _assertClassBrand(_AnnotationLayer_brand, this, _setAnnotationCanvasMap).call(this);
                    _context28.next = 45;
                    return this.l10n.translate(layer);
                  case 45:
                  case "end":
                    return _context28.stop();
                }
              }, _callee28, this, [[6, 36, 39, 42]]);
            }));
            function render(_x16) {
              return _render2.apply(this, arguments);
            }
            return render;
          }()
        }, {
          key: "update",
          value: function update(_ref80) {
            var viewport = _ref80.viewport;
            var layer = this.div;
            this.viewport = viewport;
            (0, _display_utils.setLayerDimensions)(layer, {
              rotation: viewport.rotation
            });
            _assertClassBrand(_AnnotationLayer_brand, this, _setAnnotationCanvasMap).call(this);
            layer.hidden = false;
          }
        }, {
          key: "getEditableAnnotations",
          value: function getEditableAnnotations() {
            return Array.from(_classPrivateFieldGet(_editableAnnotations, this).values());
          }
        }, {
          key: "getEditableAnnotation",
          value: function getEditableAnnotation(id) {
            return _classPrivateFieldGet(_editableAnnotations, this).get(id);
          }
        }]);
      }();
      function _appendElement(element, id) {
        var _classPrivateFieldGet32;
        var contentElement = element.firstChild || element;
        contentElement.id = "".concat(_util.AnnotationPrefix).concat(id);
        this.div.append(element);
        (_classPrivateFieldGet32 = _classPrivateFieldGet(_accessibilityManager2, this)) === null || _classPrivateFieldGet32 === void 0 || _classPrivateFieldGet32.moveElementInDOM(this.div, element, contentElement, false);
      }
      function _setAnnotationCanvasMap() {
        if (!_classPrivateFieldGet(_annotationCanvasMap, this)) {
          return;
        }
        var layer = this.div;
        var _iterator144 = _createForOfIteratorHelper(_classPrivateFieldGet(_annotationCanvasMap, this)),
          _step144;
        try {
          for (_iterator144.s(); !(_step144 = _iterator144.n()).done;) {
            var _step144$value = _slicedToArray(_step144.value, 2),
              id = _step144$value[0],
              canvas = _step144$value[1];
            var element = layer.querySelector("[data-annotation-id=\"".concat(id, "\"]"));
            if (!element) {
              continue;
            }
            var firstChild = element.firstChild;
            if (!firstChild) {
              element.append(canvas);
            } else if (firstChild.nodeName === "CANVAS") {
              firstChild.replaceWith(canvas);
            } else {
              firstChild.before(canvas);
            }
          }
        } catch (err) {
          _iterator144.e(err);
        } finally {
          _iterator144.f();
        }
        _classPrivateFieldGet(_annotationCanvasMap, this).clear();
      }
      exports.AnnotationLayer = AnnotationLayer;

      /***/
    }), (/* 30 */
    /***/function (__unused_webpack_module, exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ColorConverters = void 0;
      function makeColorComp(n) {
        return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
      }
      function scaleAndClamp(x) {
        return Math.max(0, Math.min(255, 255 * x));
      }
      var ColorConverters = /*#__PURE__*/function () {
        function ColorConverters() {
          _classCallCheck(this, ColorConverters);
        }
        return _createClass(ColorConverters, null, [{
          key: "CMYK_G",
          value: function CMYK_G(_ref81) {
            var _ref82 = _slicedToArray(_ref81, 4),
              c = _ref82[0],
              y = _ref82[1],
              m = _ref82[2],
              k = _ref82[3];
            return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
          }
        }, {
          key: "G_CMYK",
          value: function G_CMYK(_ref83) {
            var _ref84 = _slicedToArray(_ref83, 1),
              g = _ref84[0];
            return ["CMYK", 0, 0, 0, 1 - g];
          }
        }, {
          key: "G_RGB",
          value: function G_RGB(_ref85) {
            var _ref86 = _slicedToArray(_ref85, 1),
              g = _ref86[0];
            return ["RGB", g, g, g];
          }
        }, {
          key: "G_rgb",
          value: function G_rgb(_ref87) {
            var _ref88 = _slicedToArray(_ref87, 1),
              g = _ref88[0];
            g = scaleAndClamp(g);
            return [g, g, g];
          }
        }, {
          key: "G_HTML",
          value: function G_HTML(_ref89) {
            var _ref90 = _slicedToArray(_ref89, 1),
              g = _ref90[0];
            var G = makeColorComp(g);
            return "#".concat(G).concat(G).concat(G);
          }
        }, {
          key: "RGB_G",
          value: function RGB_G(_ref91) {
            var _ref92 = _slicedToArray(_ref91, 3),
              r = _ref92[0],
              g = _ref92[1],
              b = _ref92[2];
            return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
          }
        }, {
          key: "RGB_rgb",
          value: function RGB_rgb(color) {
            return color.map(scaleAndClamp);
          }
        }, {
          key: "RGB_HTML",
          value: function RGB_HTML(color) {
            return "#".concat(color.map(makeColorComp).join(""));
          }
        }, {
          key: "T_HTML",
          value: function T_HTML() {
            return "#00000000";
          }
        }, {
          key: "T_rgb",
          value: function T_rgb() {
            return [null];
          }
        }, {
          key: "CMYK_RGB",
          value: function CMYK_RGB(_ref93) {
            var _ref94 = _slicedToArray(_ref93, 4),
              c = _ref94[0],
              y = _ref94[1],
              m = _ref94[2],
              k = _ref94[3];
            return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
          }
        }, {
          key: "CMYK_rgb",
          value: function CMYK_rgb(_ref95) {
            var _ref96 = _slicedToArray(_ref95, 4),
              c = _ref96[0],
              y = _ref96[1],
              m = _ref96[2],
              k = _ref96[3];
            return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
          }
        }, {
          key: "CMYK_HTML",
          value: function CMYK_HTML(components) {
            var rgb = this.CMYK_RGB(components).slice(1);
            return this.RGB_HTML(rgb);
          }
        }, {
          key: "RGB_CMYK",
          value: function RGB_CMYK(_ref97) {
            var _ref98 = _slicedToArray(_ref97, 3),
              r = _ref98[0],
              g = _ref98[1],
              b = _ref98[2];
            var c = 1 - r;
            var m = 1 - g;
            var y = 1 - b;
            var k = Math.min(c, m, y);
            return ["CMYK", c, m, y, k];
          }
        }]);
      }();
      exports.ColorConverters = ColorConverters;

      /***/
    }), (/* 31 */
    /***/function (__unused_webpack_module, exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NullL10n = void 0;
      exports.getL10nFallback = getL10nFallback;
      var DEFAULT_L10N_STRINGS = {
        of_pages: "of {{pagesCount}}",
        page_of_pages: "({{pageNumber}} of {{pagesCount}})",
        document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
        document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
        document_properties_date_string: "{{date}}, {{time}}",
        document_properties_page_size_unit_inches: "in",
        document_properties_page_size_unit_millimeters: "mm",
        document_properties_page_size_orientation_portrait: "portrait",
        document_properties_page_size_orientation_landscape: "landscape",
        document_properties_page_size_name_a3: "A3",
        document_properties_page_size_name_a4: "A4",
        document_properties_page_size_name_letter: "Letter",
        document_properties_page_size_name_legal: "Legal",
        document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
        document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
        document_properties_linearized_yes: "Yes",
        document_properties_linearized_no: "No",
        additional_layers: "Additional Layers",
        page_landmark: "Page {{page}}",
        thumb_page_title: "Page {{page}}",
        thumb_page_canvas: "Thumbnail of Page {{page}}",
        find_reached_top: "Reached top of document, continued from bottom",
        find_reached_bottom: "Reached end of document, continued from top",
        "find_match_count[one]": "{{current}} of {{total}} match",
        "find_match_count[other]": "{{current}} of {{total}} matches",
        "find_match_count_limit[one]": "More than {{limit}} match",
        "find_match_count_limit[other]": "More than {{limit}} matches",
        find_not_found: "Phrase not found",
        page_scale_width: "Page Width",
        page_scale_fit: "Page Fit",
        page_scale_auto: "Automatic Zoom",
        page_scale_actual: "Actual Size",
        page_scale_percent: "{{scale}}%",
        loading_error: "An error occurred while loading the PDF.",
        invalid_file_error: "Invalid or corrupted PDF file.",
        missing_file_error: "Missing PDF file.",
        unexpected_response_error: "Unexpected server response.",
        rendering_error: "An error occurred while rendering the page.",
        annotation_date_string: "{{date}}, {{time}}",
        printing_not_supported: "Warning: Printing is not fully supported by this browser.",
        printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
        web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
        free_text2_default_content: "Start typing…",
        editor_free_text2_aria_label: "Text Editor",
        editor_ink2_aria_label: "Draw Editor",
        editor_ink_canvas_aria_label: "User-created image",
        editor_alt_text_button_label: "Alt text",
        editor_alt_text_edit_button_label: "Edit alt text",
        editor_alt_text_decorative_tooltip: "Marked as decorative"
      };
      {
        DEFAULT_L10N_STRINGS.print_progress_percent = "{{progress}}%";
      }
      function getL10nFallback(key, args) {
        switch (key) {
          case "find_match_count":
            key = "find_match_count[".concat(args.total === 1 ? "one" : "other", "]");
            break;
          case "find_match_count_limit":
            key = "find_match_count_limit[".concat(args.limit === 1 ? "one" : "other", "]");
            break;
        }
        return DEFAULT_L10N_STRINGS[key] || "";
      }
      function formatL10nValue(text, args) {
        if (!args) {
          return text;
        }
        return text.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, function (all, name) {
          return name in args ? args[name] : "{{" + name + "}}";
        });
      }
      var NullL10n = {
        getLanguage: function getLanguage() {
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
            return _regeneratorRuntime().wrap(function _callee29$(_context29) {
              while (1) switch (_context29.prev = _context29.next) {
                case 0:
                  return _context29.abrupt("return", "en-us");
                case 1:
                case "end":
                  return _context29.stop();
              }
            }, _callee29);
          }))();
        },
        getDirection: function getDirection() {
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
            return _regeneratorRuntime().wrap(function _callee30$(_context30) {
              while (1) switch (_context30.prev = _context30.next) {
                case 0:
                  return _context30.abrupt("return", "ltr");
                case 1:
                case "end":
                  return _context30.stop();
              }
            }, _callee30);
          }))();
        },
        get: function get(key) {
          var _arguments = arguments;
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
            var args, fallback;
            return _regeneratorRuntime().wrap(function _callee31$(_context31) {
              while (1) switch (_context31.prev = _context31.next) {
                case 0:
                  args = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : null;
                  fallback = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : getL10nFallback(key, args);
                  return _context31.abrupt("return", formatL10nValue(fallback, args));
                case 3:
                case "end":
                  return _context31.stop();
              }
            }, _callee31);
          }))();
        },
        translate: function translate(element) {
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
            return _regeneratorRuntime().wrap(function _callee32$(_context32) {
              while (1) switch (_context32.prev = _context32.next) {
                case 0:
                case "end":
                  return _context32.stop();
              }
            }, _callee32);
          }))();
        }
      };
      exports.NullL10n = NullL10n;

      /***/
    }), (/* 32 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.XfaLayer = void 0;
      var _xfa_text = __w_pdfjs_require__(25);
      var XfaLayer = /*#__PURE__*/function () {
        function XfaLayer() {
          _classCallCheck(this, XfaLayer);
        }
        return _createClass(XfaLayer, null, [{
          key: "setupStorage",
          value: function setupStorage(html, id, element, storage, intent) {
            var storedData = storage.getValue(id, {
              value: null
            });
            switch (element.name) {
              case "textarea":
                if (storedData.value !== null) {
                  html.textContent = storedData.value;
                }
                if (intent === "print") {
                  break;
                }
                html.addEventListener("input", function (event) {
                  storage.setValue(id, {
                    value: event.target.value
                  });
                });
                break;
              case "input":
                if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                  if (storedData.value === element.attributes.xfaOn) {
                    html.setAttribute("checked", true);
                  } else if (storedData.value === element.attributes.xfaOff) {
                    html.removeAttribute("checked");
                  }
                  if (intent === "print") {
                    break;
                  }
                  html.addEventListener("change", function (event) {
                    storage.setValue(id, {
                      value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                    });
                  });
                } else {
                  if (storedData.value !== null) {
                    html.setAttribute("value", storedData.value);
                  }
                  if (intent === "print") {
                    break;
                  }
                  html.addEventListener("input", function (event) {
                    storage.setValue(id, {
                      value: event.target.value
                    });
                  });
                }
                break;
              case "select":
                if (storedData.value !== null) {
                  html.setAttribute("value", storedData.value);
                  var _iterator145 = _createForOfIteratorHelper(element.children),
                    _step145;
                  try {
                    for (_iterator145.s(); !(_step145 = _iterator145.n()).done;) {
                      var option = _step145.value;
                      if (option.attributes.value === storedData.value) {
                        option.attributes.selected = true;
                      } else if (option.attributes.hasOwnProperty("selected")) {
                        delete option.attributes.selected;
                      }
                    }
                  } catch (err) {
                    _iterator145.e(err);
                  } finally {
                    _iterator145.f();
                  }
                }
                html.addEventListener("input", function (event) {
                  var options = event.target.options;
                  var value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                  storage.setValue(id, {
                    value: value
                  });
                });
                break;
            }
          }
        }, {
          key: "setAttributes",
          value: function setAttributes(_ref99) {
            var html = _ref99.html,
              element = _ref99.element,
              _ref99$storage = _ref99.storage,
              storage = _ref99$storage === void 0 ? null : _ref99$storage,
              intent = _ref99.intent,
              linkService = _ref99.linkService;
            var attributes = element.attributes;
            var isHTMLAnchorElement = html instanceof HTMLAnchorElement;
            if (attributes.type === "radio") {
              attributes.name = "".concat(attributes.name, "-").concat(intent);
            }
            for (var _i23 = 0, _Object$entries4 = Object.entries(attributes); _i23 < _Object$entries4.length; _i23++) {
              var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i23], 2),
                key = _Object$entries4$_i[0],
                value = _Object$entries4$_i[1];
              if (value === null || value === undefined) {
                continue;
              }
              switch (key) {
                case "class":
                  if (value.length) {
                    html.setAttribute(key, value.join(" "));
                  }
                  break;
                case "dataId":
                  break;
                case "id":
                  html.setAttribute("data-element-id", value);
                  break;
                case "style":
                  Object.assign(html.style, value);
                  break;
                case "textContent":
                  html.textContent = value;
                  break;
                default:
                  if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                    html.setAttribute(key, value);
                  }
              }
            }
            if (isHTMLAnchorElement) {
              linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
            }
            if (storage && attributes.dataId) {
              this.setupStorage(html, attributes.dataId, element, storage);
            }
          }
        }, {
          key: "render",
          value: function render(parameters) {
            var storage = parameters.annotationStorage;
            var linkService = parameters.linkService;
            var root = parameters.xfaHtml;
            var intent = parameters.intent || "display";
            var rootHtml = document.createElement(root.name);
            if (root.attributes) {
              this.setAttributes({
                html: rootHtml,
                element: root,
                intent: intent,
                linkService: linkService
              });
            }
            var stack = [[root, -1, rootHtml]];
            var rootDiv = parameters.div;
            rootDiv.append(rootHtml);
            if (parameters.viewport) {
              var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
              rootDiv.style.transform = transform;
            }
            if (intent !== "richText") {
              rootDiv.setAttribute("class", "xfaLayer xfaFont");
            }
            var textDivs = [];
            while (stack.length > 0) {
              var _child$attributes;
              var _stack$at = stack.at(-1),
                _stack$at2 = _slicedToArray(_stack$at, 3),
                parent = _stack$at2[0],
                i = _stack$at2[1],
                html = _stack$at2[2];
              if (i + 1 === parent.children.length) {
                stack.pop();
                continue;
              }
              var child = parent.children[++stack.at(-1)[1]];
              if (child === null) {
                continue;
              }
              var name = child.name;
              if (name === "#text") {
                var node = document.createTextNode(child.value);
                textDivs.push(node);
                html.append(node);
                continue;
              }
              var childHtml = child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
              html.append(childHtml);
              if (child.attributes) {
                this.setAttributes({
                  html: childHtml,
                  element: child,
                  storage: storage,
                  intent: intent,
                  linkService: linkService
                });
              }
              if (child.children && child.children.length > 0) {
                stack.push([child, -1, childHtml]);
              } else if (child.value) {
                var _node = document.createTextNode(child.value);
                if (_xfa_text.XfaText.shouldBuildText(name)) {
                  textDivs.push(_node);
                }
                childHtml.append(_node);
              }
            }
            var _iterator146 = _createForOfIteratorHelper(rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")),
              _step146;
            try {
              for (_iterator146.s(); !(_step146 = _iterator146.n()).done;) {
                var el = _step146.value;
                el.setAttribute("readOnly", true);
              }
            } catch (err) {
              _iterator146.e(err);
            } finally {
              _iterator146.f();
            }
            return {
              textDivs: textDivs
            };
          }
        }, {
          key: "update",
          value: function update(parameters) {
            var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
            parameters.div.style.transform = transform;
            parameters.div.hidden = false;
          }
        }]);
      }();
      exports.XfaLayer = XfaLayer;

      /***/
    }), (/* 33 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      var _InkEditor;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.InkEditor = void 0;
      var _util = __w_pdfjs_require__(1);
      var _editor = __w_pdfjs_require__(4);
      var _annotation_layer = __w_pdfjs_require__(29);
      var _display_utils = __w_pdfjs_require__(6);
      var _tools = __w_pdfjs_require__(5);
      var _baseHeight = /*#__PURE__*/new WeakMap();
      var _baseWidth = /*#__PURE__*/new WeakMap();
      var _boundCanvasPointermove = /*#__PURE__*/new WeakMap();
      var _boundCanvasPointerleave = /*#__PURE__*/new WeakMap();
      var _boundCanvasPointerup = /*#__PURE__*/new WeakMap();
      var _boundCanvasPointerdown = /*#__PURE__*/new WeakMap();
      var _currentPath2D = /*#__PURE__*/new WeakMap();
      var _disableEditing = /*#__PURE__*/new WeakMap();
      var _hasSomethingToDraw = /*#__PURE__*/new WeakMap();
      var _isCanvasInitialized = /*#__PURE__*/new WeakMap();
      var _observer = /*#__PURE__*/new WeakMap();
      var _realWidth = /*#__PURE__*/new WeakMap();
      var _realHeight = /*#__PURE__*/new WeakMap();
      var _requestFrameCallback = /*#__PURE__*/new WeakMap();
      var _InkEditor_brand = /*#__PURE__*/new WeakSet();
      var InkEditor = /*#__PURE__*/function (_editor$AnnotationEdi2) {
        function InkEditor(params) {
          var _this91;
          _classCallCheck(this, InkEditor);
          _this91 = _callSuper(this, InkEditor, [_objectSpread(_objectSpread({}, params), {}, {
            name: "inkEditor"
          })]);
          _classPrivateMethodInitSpec(_this91, _InkEditor_brand);
          _classPrivateFieldInitSpec(_this91, _baseHeight, 0);
          _classPrivateFieldInitSpec(_this91, _baseWidth, 0);
          _classPrivateFieldInitSpec(_this91, _boundCanvasPointermove, _this91.canvasPointermove.bind(_this91));
          _classPrivateFieldInitSpec(_this91, _boundCanvasPointerleave, _this91.canvasPointerleave.bind(_this91));
          _classPrivateFieldInitSpec(_this91, _boundCanvasPointerup, _this91.canvasPointerup.bind(_this91));
          _classPrivateFieldInitSpec(_this91, _boundCanvasPointerdown, _this91.canvasPointerdown.bind(_this91));
          _classPrivateFieldInitSpec(_this91, _currentPath2D, new Path2D());
          _classPrivateFieldInitSpec(_this91, _disableEditing, false);
          _classPrivateFieldInitSpec(_this91, _hasSomethingToDraw, false);
          _classPrivateFieldInitSpec(_this91, _isCanvasInitialized, false);
          _classPrivateFieldInitSpec(_this91, _observer, null);
          _classPrivateFieldInitSpec(_this91, _realWidth, 0);
          _classPrivateFieldInitSpec(_this91, _realHeight, 0);
          _classPrivateFieldInitSpec(_this91, _requestFrameCallback, null);
          _this91.color = params.color || null;
          _this91.thickness = params.thickness || null;
          _this91.opacity = params.opacity || null;
          _this91.paths = [];
          _this91.bezierPath2D = [];
          _this91.allRawPaths = [];
          _this91.currentPath = [];
          _this91.scaleFactor = 1;
          _this91.translationX = _this91.translationY = 0;
          _this91.x = 0;
          _this91.y = 0;
          _this91._willKeepAspectRatio = true;
          return _this91;
        }
        _inherits(InkEditor, _editor$AnnotationEdi2);
        return _createClass(InkEditor, [{
          key: "updateParams",
          value: function updateParams(type, value) {
            switch (type) {
              case _util.AnnotationEditorParamsType.INK_THICKNESS:
                _assertClassBrand(_InkEditor_brand, this, _updateThickness).call(this, value);
                break;
              case _util.AnnotationEditorParamsType.INK_COLOR:
                _assertClassBrand(_InkEditor_brand, this, _updateColor2).call(this, value);
                break;
              case _util.AnnotationEditorParamsType.INK_OPACITY:
                _assertClassBrand(_InkEditor_brand, this, _updateOpacity).call(this, value);
                break;
            }
          }
        }, {
          key: "propertiesToUpdate",
          get: function get() {
            var _this$opacity;
            return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * ((_this$opacity = this.opacity) !== null && _this$opacity !== void 0 ? _this$opacity : InkEditor._defaultOpacity))]];
          }
        }, {
          key: "rebuild",
          value: function rebuild() {
            if (!this.parent) {
              return;
            }
            _superPropGet(InkEditor, "rebuild", this, 3)([]);
            if (this.div === null) {
              return;
            }
            if (!this.canvas) {
              _assertClassBrand(_InkEditor_brand, this, _createCanvas2).call(this);
              _assertClassBrand(_InkEditor_brand, this, _createObserver).call(this);
            }
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
              _assertClassBrand(_InkEditor_brand, this, _setCanvasDims).call(this);
            }
            _assertClassBrand(_InkEditor_brand, this, _fitToContent).call(this);
          }
        }, {
          key: "remove",
          value: function remove() {
            if (this.canvas === null) {
              return;
            }
            if (!this.isEmpty()) {
              this.commit();
            }
            this.canvas.width = this.canvas.height = 0;
            this.canvas.remove();
            this.canvas = null;
            _classPrivateFieldGet(_observer, this).disconnect();
            _classPrivateFieldSet(_observer, this, null);
            _superPropGet(InkEditor, "remove", this, 3)([]);
          }
        }, {
          key: "setParent",
          value: function setParent(parent) {
            if (!this.parent && parent) {
              this._uiManager.removeShouldRescale(this);
            } else if (this.parent && parent === null) {
              this._uiManager.addShouldRescale(this);
            }
            _superPropGet(InkEditor, "setParent", this, 3)([parent]);
          }
        }, {
          key: "onScaleChanging",
          value: function onScaleChanging() {
            var _this$parentDimension11 = _slicedToArray(this.parentDimensions, 2),
              parentWidth = _this$parentDimension11[0],
              parentHeight = _this$parentDimension11[1];
            var width = this.width * parentWidth;
            var height = this.height * parentHeight;
            this.setDimensions(width, height);
          }
        }, {
          key: "enableEditMode",
          value: function enableEditMode() {
            if (_classPrivateFieldGet(_disableEditing, this) || this.canvas === null) {
              return;
            }
            _superPropGet(InkEditor, "enableEditMode", this, 3)([]);
            this._isDraggable = false;
            this.canvas.addEventListener("pointerdown", _classPrivateFieldGet(_boundCanvasPointerdown, this));
          }
        }, {
          key: "disableEditMode",
          value: function disableEditMode() {
            if (!this.isInEditMode() || this.canvas === null) {
              return;
            }
            _superPropGet(InkEditor, "disableEditMode", this, 3)([]);
            this._isDraggable = !this.isEmpty();
            this.div.classList.remove("editing");
            this.canvas.removeEventListener("pointerdown", _classPrivateFieldGet(_boundCanvasPointerdown, this));
          }
        }, {
          key: "onceAdded",
          value: function onceAdded() {
            this._isDraggable = !this.isEmpty();
          }
        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
          }
        }, {
          key: "commit",
          value: function commit() {
            if (_classPrivateFieldGet(_disableEditing, this)) {
              return;
            }
            _superPropGet(InkEditor, "commit", this, 3)([]);
            this.isEditing = false;
            this.disableEditMode();
            this.setInForeground();
            _classPrivateFieldSet(_disableEditing, this, true);
            this.div.classList.add("disabled");
            _assertClassBrand(_InkEditor_brand, this, _fitToContent).call(this, true);
            this.makeResizable();
            this.parent.addInkEditorIfNeeded(true);
            this.moveInDOM();
            this.div.focus({
              preventScroll: true
            });
          }
        }, {
          key: "focusin",
          value: function focusin(event) {
            if (!this._focusEventsAllowed) {
              return;
            }
            _superPropGet(InkEditor, "focusin", this, 3)([event]);
            this.enableEditMode();
          }
        }, {
          key: "canvasPointerdown",
          value: function canvasPointerdown(event) {
            if (event.button !== 0 || !this.isInEditMode() || _classPrivateFieldGet(_disableEditing, this)) {
              return;
            }
            this.setInForeground();
            event.preventDefault();
            if (event.type !== "mouse") {
              this.div.focus();
            }
            _assertClassBrand(_InkEditor_brand, this, _startDrawing).call(this, event.offsetX, event.offsetY);
          }
        }, {
          key: "canvasPointermove",
          value: function canvasPointermove(event) {
            event.preventDefault();
            _assertClassBrand(_InkEditor_brand, this, _draw).call(this, event.offsetX, event.offsetY);
          }
        }, {
          key: "canvasPointerup",
          value: function canvasPointerup(event) {
            event.preventDefault();
            _assertClassBrand(_InkEditor_brand, this, _endDrawing).call(this, event);
          }
        }, {
          key: "canvasPointerleave",
          value: function canvasPointerleave(event) {
            _assertClassBrand(_InkEditor_brand, this, _endDrawing).call(this, event);
          }
        }, {
          key: "isResizable",
          get: function get() {
            return !this.isEmpty() && _classPrivateFieldGet(_disableEditing, this);
          }
        }, {
          key: "render",
          value: function render() {
            var _this92 = this;
            if (this.div) {
              return this.div;
            }
            var baseX, baseY;
            if (this.width) {
              baseX = this.x;
              baseY = this.y;
            }
            _superPropGet(InkEditor, "render", this, 3)([]);
            _editor.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then(function (msg) {
              var _this92$div;
              return (_this92$div = _this92.div) === null || _this92$div === void 0 ? void 0 : _this92$div.setAttribute("aria-label", msg);
            });
            var _assertClassBrand$cal6 = _assertClassBrand(_InkEditor_brand, this, _getInitialBBox).call(this),
              _assertClassBrand$cal7 = _slicedToArray(_assertClassBrand$cal6, 4),
              x = _assertClassBrand$cal7[0],
              y = _assertClassBrand$cal7[1],
              w = _assertClassBrand$cal7[2],
              h = _assertClassBrand$cal7[3];
            this.setAt(x, y, 0, 0);
            this.setDims(w, h);
            _assertClassBrand(_InkEditor_brand, this, _createCanvas2).call(this);
            if (this.width) {
              var _this$parentDimension12 = _slicedToArray(this.parentDimensions, 2),
                parentWidth = _this$parentDimension12[0],
                parentHeight = _this$parentDimension12[1];
              this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
              this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
              _classPrivateFieldSet(_isCanvasInitialized, this, true);
              _assertClassBrand(_InkEditor_brand, this, _setCanvasDims).call(this);
              this.setDims(this.width * parentWidth, this.height * parentHeight);
              _assertClassBrand(_InkEditor_brand, this, _redraw).call(this);
              this.div.classList.add("disabled");
            } else {
              this.div.classList.add("editing");
              this.enableEditMode();
            }
            _assertClassBrand(_InkEditor_brand, this, _createObserver).call(this);
            return this.div;
          }
        }, {
          key: "setDimensions",
          value: function setDimensions(width, height) {
            var roundedWidth = Math.round(width);
            var roundedHeight = Math.round(height);
            if (_classPrivateFieldGet(_realWidth, this) === roundedWidth && _classPrivateFieldGet(_realHeight, this) === roundedHeight) {
              return;
            }
            _classPrivateFieldSet(_realWidth, this, roundedWidth);
            _classPrivateFieldSet(_realHeight, this, roundedHeight);
            this.canvas.style.visibility = "hidden";
            var _this$parentDimension13 = _slicedToArray(this.parentDimensions, 2),
              parentWidth = _this$parentDimension13[0],
              parentHeight = _this$parentDimension13[1];
            this.width = width / parentWidth;
            this.height = height / parentHeight;
            this.fixAndSetPosition();
            if (_classPrivateFieldGet(_disableEditing, this)) {
              _assertClassBrand(_InkEditor_brand, this, _setScaleFactor).call(this, width, height);
            }
            _assertClassBrand(_InkEditor_brand, this, _setCanvasDims).call(this);
            _assertClassBrand(_InkEditor_brand, this, _redraw).call(this);
            this.canvas.style.visibility = "visible";
            this.fixDims();
          }
        }, {
          key: "serialize",
          value: function serialize() {
            if (this.isEmpty()) {
              return null;
            }
            var rect = this.getRect(0, 0);
            var color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
            return {
              annotationType: _util.AnnotationEditorType.INK,
              color: color,
              thickness: this.thickness,
              opacity: this.opacity,
              paths: _assertClassBrand(_InkEditor_brand, this, _serializePaths).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
              pageIndex: this.pageIndex,
              rect: rect,
              rotation: this.rotation,
              structTreeParentId: this._structTreeParentId
            };
          }
        }], [{
          key: "initialize",
          value: function initialize(l10n) {
            _editor.AnnotationEditor.initialize(l10n, {
              strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
            });
          }
        }, {
          key: "updateDefaultParams",
          value: function updateDefaultParams(type, value) {
            switch (type) {
              case _util.AnnotationEditorParamsType.INK_THICKNESS:
                InkEditor._defaultThickness = value;
                break;
              case _util.AnnotationEditorParamsType.INK_COLOR:
                InkEditor._defaultColor = value;
                break;
              case _util.AnnotationEditorParamsType.INK_OPACITY:
                InkEditor._defaultOpacity = value / 100;
                break;
            }
          }
        }, {
          key: "defaultPropertiesToUpdate",
          get: function get() {
            return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
          }
        }, {
          key: "deserialize",
          value: function deserialize(data, parent, uiManager) {
            var _util$Util8;
            if (data instanceof _annotation_layer.InkAnnotationElement) {
              return null;
            }
            var editor = _superPropGet(InkEditor, "deserialize", this, 2)([data, parent, uiManager]);
            editor.thickness = data.thickness;
            editor.color = (_util$Util8 = _util.Util).makeHexColor.apply(_util$Util8, _toConsumableArray(data.color));
            editor.opacity = data.opacity;
            var _editor$pageDimension2 = _slicedToArray(editor.pageDimensions, 2),
              pageWidth = _editor$pageDimension2[0],
              pageHeight = _editor$pageDimension2[1];
            var width = editor.width * pageWidth;
            var height = editor.height * pageHeight;
            var scaleFactor = editor.parentScale;
            var padding = data.thickness / 2;
            _classPrivateFieldSet(_disableEditing, editor, true);
            _classPrivateFieldSet(_realWidth, editor, Math.round(width));
            _classPrivateFieldSet(_realHeight, editor, Math.round(height));
            var paths = data.paths,
              rect = data.rect,
              rotation = data.rotation;
            var _iterator147 = _createForOfIteratorHelper(paths),
              _step147;
            try {
              for (_iterator147.s(); !(_step147 = _iterator147.n()).done;) {
                var bezier = _step147.value.bezier;
                bezier = _fromPDFCoordinates.call(InkEditor, bezier, rect, rotation);
                var path = [];
                editor.paths.push(path);
                var p0 = scaleFactor * (bezier[0] - padding);
                var p1 = scaleFactor * (bezier[1] - padding);
                for (var i = 2, ii = bezier.length; i < ii; i += 6) {
                  var p10 = scaleFactor * (bezier[i] - padding);
                  var p11 = scaleFactor * (bezier[i + 1] - padding);
                  var p20 = scaleFactor * (bezier[i + 2] - padding);
                  var p21 = scaleFactor * (bezier[i + 3] - padding);
                  var p30 = scaleFactor * (bezier[i + 4] - padding);
                  var p31 = scaleFactor * (bezier[i + 5] - padding);
                  path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                  p0 = p30;
                  p1 = p31;
                }
                var path2D = _assertClassBrand(InkEditor, this, _buildPath2D).call(this, path);
                editor.bezierPath2D.push(path2D);
              }
            } catch (err) {
              _iterator147.e(err);
            } finally {
              _iterator147.f();
            }
            var bbox = _assertClassBrand(_InkEditor_brand, editor, _getBbox).call(editor);
            _classPrivateFieldSet(_baseWidth, editor, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]));
            _classPrivateFieldSet(_baseHeight, editor, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]));
            _assertClassBrand(_InkEditor_brand, editor, _setScaleFactor).call(editor, width, height);
            return editor;
          }
        }]);
      }(_editor.AnnotationEditor);
      _InkEditor = InkEditor;
      function _updateThickness(thickness) {
        var _this93 = this;
        var savedThickness = this.thickness;
        this.addCommands({
          cmd: function cmd() {
            _this93.thickness = thickness;
            _assertClassBrand(_InkEditor_brand, _this93, _fitToContent).call(_this93);
          },
          undo: function undo() {
            _this93.thickness = savedThickness;
            _assertClassBrand(_InkEditor_brand, _this93, _fitToContent).call(_this93);
          },
          mustExec: true,
          type: _util.AnnotationEditorParamsType.INK_THICKNESS,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      function _updateColor2(color) {
        var _this94 = this;
        var savedColor = this.color;
        this.addCommands({
          cmd: function cmd() {
            _this94.color = color;
            _assertClassBrand(_InkEditor_brand, _this94, _redraw).call(_this94);
          },
          undo: function undo() {
            _this94.color = savedColor;
            _assertClassBrand(_InkEditor_brand, _this94, _redraw).call(_this94);
          },
          mustExec: true,
          type: _util.AnnotationEditorParamsType.INK_COLOR,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      function _updateOpacity(opacity) {
        var _this95 = this;
        opacity /= 100;
        var savedOpacity = this.opacity;
        this.addCommands({
          cmd: function cmd() {
            _this95.opacity = opacity;
            _assertClassBrand(_InkEditor_brand, _this95, _redraw).call(_this95);
          },
          undo: function undo() {
            _this95.opacity = savedOpacity;
            _assertClassBrand(_InkEditor_brand, _this95, _redraw).call(_this95);
          },
          mustExec: true,
          type: _util.AnnotationEditorParamsType.INK_OPACITY,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      function _getInitialBBox() {
        var parentRotation = this.parentRotation,
          _this$parentDimension14 = _slicedToArray(this.parentDimensions, 2),
          width = _this$parentDimension14[0],
          height = _this$parentDimension14[1];
        switch (parentRotation) {
          case 90:
            return [0, height, height, width];
          case 180:
            return [width, height, width, height];
          case 270:
            return [width, 0, height, width];
          default:
            return [0, 0, width, height];
        }
      }
      function _setStroke() {
        var ctx = this.ctx,
          color = this.color,
          opacity = this.opacity,
          thickness = this.thickness,
          parentScale = this.parentScale,
          scaleFactor = this.scaleFactor;
        ctx.lineWidth = thickness * parentScale / scaleFactor;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.miterLimit = 10;
        ctx.strokeStyle = "".concat(color).concat((0, _tools.opacityToHex)(opacity));
      }
      function _startDrawing(x, y) {
        var _this96 = this;
        this.canvas.addEventListener("contextmenu", _display_utils.noContextMenu);
        this.canvas.addEventListener("pointerleave", _classPrivateFieldGet(_boundCanvasPointerleave, this));
        this.canvas.addEventListener("pointermove", _classPrivateFieldGet(_boundCanvasPointermove, this));
        this.canvas.addEventListener("pointerup", _classPrivateFieldGet(_boundCanvasPointerup, this));
        this.canvas.removeEventListener("pointerdown", _classPrivateFieldGet(_boundCanvasPointerdown, this));
        this.isEditing = true;
        if (!_classPrivateFieldGet(_isCanvasInitialized, this)) {
          var _this$opacity2;
          _classPrivateFieldSet(_isCanvasInitialized, this, true);
          _assertClassBrand(_InkEditor_brand, this, _setCanvasDims).call(this);
          this.thickness || (this.thickness = _InkEditor._defaultThickness);
          this.color || (this.color = _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
          (_this$opacity2 = this.opacity) !== null && _this$opacity2 !== void 0 ? _this$opacity2 : this.opacity = _InkEditor._defaultOpacity;
        }
        this.currentPath.push([x, y]);
        _classPrivateFieldSet(_hasSomethingToDraw, this, false);
        _assertClassBrand(_InkEditor_brand, this, _setStroke).call(this);
        _classPrivateFieldSet(_requestFrameCallback, this, function () {
          _assertClassBrand(_InkEditor_brand, _this96, _drawPoints).call(_this96);
          if (_classPrivateFieldGet(_requestFrameCallback, _this96)) {
            window.requestAnimationFrame(_classPrivateFieldGet(_requestFrameCallback, _this96));
          }
        });
        window.requestAnimationFrame(_classPrivateFieldGet(_requestFrameCallback, this));
      }
      function _draw(x, y) {
        var _assertClassBrand2;
        var _this$currentPath$at = this.currentPath.at(-1),
          _this$currentPath$at2 = _slicedToArray(_this$currentPath$at, 2),
          lastX = _this$currentPath$at2[0],
          lastY = _this$currentPath$at2[1];
        if (this.currentPath.length > 1 && x === lastX && y === lastY) {
          return;
        }
        var currentPath = this.currentPath;
        var path2D = _classPrivateFieldGet(_currentPath2D, this);
        currentPath.push([x, y]);
        _classPrivateFieldSet(_hasSomethingToDraw, this, true);
        if (currentPath.length <= 2) {
          var _path2D;
          (_path2D = path2D).moveTo.apply(_path2D, _toConsumableArray(currentPath[0]));
          path2D.lineTo(x, y);
          return;
        }
        if (currentPath.length === 3) {
          var _path2D2;
          _classPrivateFieldSet(_currentPath2D, this, path2D = new Path2D());
          (_path2D2 = path2D).moveTo.apply(_path2D2, _toConsumableArray(currentPath[0]));
        }
        (_assertClassBrand2 = _assertClassBrand(_InkEditor_brand, this, _makeBezierCurve)).call.apply(_assertClassBrand2, [this, path2D].concat(_toConsumableArray(currentPath.at(-3)), _toConsumableArray(currentPath.at(-2)), [x, y]));
      }
      function _endPath() {
        var _classPrivateFieldGet33;
        if (this.currentPath.length === 0) {
          return;
        }
        var lastPoint = this.currentPath.at(-1);
        (_classPrivateFieldGet33 = _classPrivateFieldGet(_currentPath2D, this)).lineTo.apply(_classPrivateFieldGet33, _toConsumableArray(lastPoint));
      }
      function _stopDrawing(x, y) {
        var _this97 = this;
        _classPrivateFieldSet(_requestFrameCallback, this, null);
        x = Math.min(Math.max(x, 0), this.canvas.width);
        y = Math.min(Math.max(y, 0), this.canvas.height);
        _assertClassBrand(_InkEditor_brand, this, _draw).call(this, x, y);
        _assertClassBrand(_InkEditor_brand, this, _endPath).call(this);
        var bezier;
        if (this.currentPath.length !== 1) {
          bezier = _assertClassBrand(_InkEditor_brand, this, _generateBezierPoints).call(this);
        } else {
          var xy = [x, y];
          bezier = [[xy, xy.slice(), xy.slice(), xy]];
        }
        var path2D = _classPrivateFieldGet(_currentPath2D, this);
        var currentPath = this.currentPath;
        this.currentPath = [];
        _classPrivateFieldSet(_currentPath2D, this, new Path2D());
        var cmd = function cmd() {
          _this97.allRawPaths.push(currentPath);
          _this97.paths.push(bezier);
          _this97.bezierPath2D.push(path2D);
          _this97.rebuild();
        };
        var undo = function undo() {
          _this97.allRawPaths.pop();
          _this97.paths.pop();
          _this97.bezierPath2D.pop();
          if (_this97.paths.length === 0) {
            _this97.remove();
          } else {
            if (!_this97.canvas) {
              _assertClassBrand(_InkEditor_brand, _this97, _createCanvas2).call(_this97);
              _assertClassBrand(_InkEditor_brand, _this97, _createObserver).call(_this97);
            }
            _assertClassBrand(_InkEditor_brand, _this97, _fitToContent).call(_this97);
          }
        };
        this.addCommands({
          cmd: cmd,
          undo: undo,
          mustExec: true
        });
      }
      function _drawPoints() {
        if (!_classPrivateFieldGet(_hasSomethingToDraw, this)) {
          return;
        }
        _classPrivateFieldSet(_hasSomethingToDraw, this, false);
        var thickness = Math.ceil(this.thickness * this.parentScale);
        var lastPoints = this.currentPath.slice(-3);
        var x = lastPoints.map(function (xy) {
          return xy[0];
        });
        var y = lastPoints.map(function (xy) {
          return xy[1];
        });
        var xMin = Math.min.apply(Math, _toConsumableArray(x)) - thickness;
        var xMax = Math.max.apply(Math, _toConsumableArray(x)) + thickness;
        var yMin = Math.min.apply(Math, _toConsumableArray(y)) - thickness;
        var yMax = Math.max.apply(Math, _toConsumableArray(y)) + thickness;
        var ctx = this.ctx;
        ctx.save();
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        var _iterator148 = _createForOfIteratorHelper(this.bezierPath2D),
          _step148;
        try {
          for (_iterator148.s(); !(_step148 = _iterator148.n()).done;) {
            var path = _step148.value;
            ctx.stroke(path);
          }
        } catch (err) {
          _iterator148.e(err);
        } finally {
          _iterator148.f();
        }
        ctx.stroke(_classPrivateFieldGet(_currentPath2D, this));
        ctx.restore();
      }
      function _makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {
        var prevX = (x0 + x1) / 2;
        var prevY = (y0 + y1) / 2;
        var x3 = (x1 + x2) / 2;
        var y3 = (y1 + y2) / 2;
        path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
      }
      function _generateBezierPoints() {
        var path = this.currentPath;
        if (path.length <= 2) {
          return [[path[0], path[0], path.at(-1), path.at(-1)]];
        }
        var bezierPoints = [];
        var i;
        var _path$ = _slicedToArray(path[0], 2),
          x0 = _path$[0],
          y0 = _path$[1];
        for (i = 1; i < path.length - 2; i++) {
          var _path$i = _slicedToArray(path[i], 2),
            _x17 = _path$i[0],
            _y3 = _path$i[1];
          var _path = _slicedToArray(path[i + 1], 2),
            _x18 = _path[0],
            _y4 = _path[1];
          var x3 = (_x17 + _x18) / 2;
          var y3 = (_y3 + _y4) / 2;
          var _control = [x0 + 2 * (_x17 - x0) / 3, y0 + 2 * (_y3 - y0) / 3];
          var _control2 = [x3 + 2 * (_x17 - x3) / 3, y3 + 2 * (_y3 - y3) / 3];
          bezierPoints.push([[x0, y0], _control, _control2, [x3, y3]]);
          x0 = x3;
          y0 = y3;
        }
        var _path$i2 = _slicedToArray(path[i], 2),
          x1 = _path$i2[0],
          y1 = _path$i2[1];
        var _path2 = _slicedToArray(path[i + 1], 2),
          x2 = _path2[0],
          y2 = _path2[1];
        var control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
        var control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];
        bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
        return bezierPoints;
      }
      function _redraw() {
        if (this.isEmpty()) {
          _assertClassBrand(_InkEditor_brand, this, _updateTransform).call(this);
          return;
        }
        _assertClassBrand(_InkEditor_brand, this, _setStroke).call(this);
        var canvas = this.canvas,
          ctx = this.ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        _assertClassBrand(_InkEditor_brand, this, _updateTransform).call(this);
        var _iterator149 = _createForOfIteratorHelper(this.bezierPath2D),
          _step149;
        try {
          for (_iterator149.s(); !(_step149 = _iterator149.n()).done;) {
            var path = _step149.value;
            ctx.stroke(path);
          }
        } catch (err) {
          _iterator149.e(err);
        } finally {
          _iterator149.f();
        }
      }
      function _endDrawing(event) {
        var _this98 = this;
        this.canvas.removeEventListener("pointerleave", _classPrivateFieldGet(_boundCanvasPointerleave, this));
        this.canvas.removeEventListener("pointermove", _classPrivateFieldGet(_boundCanvasPointermove, this));
        this.canvas.removeEventListener("pointerup", _classPrivateFieldGet(_boundCanvasPointerup, this));
        this.canvas.addEventListener("pointerdown", _classPrivateFieldGet(_boundCanvasPointerdown, this));
        setTimeout(function () {
          _this98.canvas.removeEventListener("contextmenu", _display_utils.noContextMenu);
        }, 10);
        _assertClassBrand(_InkEditor_brand, this, _stopDrawing).call(this, event.offsetX, event.offsetY);
        this.addToAnnotationStorage();
        this.setInBackground();
      }
      function _createCanvas2() {
        var _this99 = this;
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.canvas.height = 0;
        this.canvas.className = "inkEditorCanvas";
        _editor.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(function (msg) {
          var _this99$canvas;
          return (_this99$canvas = _this99.canvas) === null || _this99$canvas === void 0 ? void 0 : _this99$canvas.setAttribute("aria-label", msg);
        });
        this.div.append(this.canvas);
        this.ctx = this.canvas.getContext("2d");
      }
      function _createObserver() {
        var _this100 = this;
        _classPrivateFieldSet(_observer, this, new ResizeObserver(function (entries) {
          var rect = entries[0].contentRect;
          if (rect.width && rect.height) {
            _this100.setDimensions(rect.width, rect.height);
          }
        }));
        _classPrivateFieldGet(_observer, this).observe(this.div);
      }
      function _setCanvasDims() {
        if (!_classPrivateFieldGet(_isCanvasInitialized, this)) {
          return;
        }
        var _this$parentDimension15 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension15[0],
          parentHeight = _this$parentDimension15[1];
        this.canvas.width = Math.ceil(this.width * parentWidth);
        this.canvas.height = Math.ceil(this.height * parentHeight);
        _assertClassBrand(_InkEditor_brand, this, _updateTransform).call(this);
      }
      function _setScaleFactor(width, height) {
        var padding = _assertClassBrand(_InkEditor_brand, this, _getPadding).call(this);
        var scaleFactorW = (width - padding) / _classPrivateFieldGet(_baseWidth, this);
        var scaleFactorH = (height - padding) / _classPrivateFieldGet(_baseHeight, this);
        this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
      }
      function _updateTransform() {
        var padding = _assertClassBrand(_InkEditor_brand, this, _getPadding).call(this) / 2;
        this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
      }
      function _buildPath2D(bezier) {
        var path2D = new Path2D();
        for (var i = 0, ii = bezier.length; i < ii; i++) {
          var _bezier$i = _slicedToArray(bezier[i], 4),
            first = _bezier$i[0],
            control1 = _bezier$i[1],
            control2 = _bezier$i[2],
            second = _bezier$i[3];
          if (i === 0) {
            path2D.moveTo.apply(path2D, _toConsumableArray(first));
          }
          path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
        }
        return path2D;
      }
      function _toPDFCoordinates(points, rect, rotation) {
        var _rect3 = _slicedToArray(rect, 4),
          blX = _rect3[0],
          blY = _rect3[1],
          trX = _rect3[2],
          trY = _rect3[3];
        switch (rotation) {
          case 0:
            for (var i = 0, ii = points.length; i < ii; i += 2) {
              points[i] += blX;
              points[i + 1] = trY - points[i + 1];
            }
            break;
          case 90:
            for (var _i24 = 0, _ii2 = points.length; _i24 < _ii2; _i24 += 2) {
              var x = points[_i24];
              points[_i24] = points[_i24 + 1] + blX;
              points[_i24 + 1] = x + blY;
            }
            break;
          case 180:
            for (var _i25 = 0, _ii3 = points.length; _i25 < _ii3; _i25 += 2) {
              points[_i25] = trX - points[_i25];
              points[_i25 + 1] += blY;
            }
            break;
          case 270:
            for (var _i26 = 0, _ii4 = points.length; _i26 < _ii4; _i26 += 2) {
              var _x19 = points[_i26];
              points[_i26] = trX - points[_i26 + 1];
              points[_i26 + 1] = trY - _x19;
            }
            break;
          default:
            throw new Error("Invalid rotation");
        }
        return points;
      }
      function _fromPDFCoordinates(points, rect, rotation) {
        var _rect4 = _slicedToArray(rect, 4),
          blX = _rect4[0],
          blY = _rect4[1],
          trX = _rect4[2],
          trY = _rect4[3];
        switch (rotation) {
          case 0:
            for (var i = 0, ii = points.length; i < ii; i += 2) {
              points[i] -= blX;
              points[i + 1] = trY - points[i + 1];
            }
            break;
          case 90:
            for (var _i27 = 0, _ii5 = points.length; _i27 < _ii5; _i27 += 2) {
              var x = points[_i27];
              points[_i27] = points[_i27 + 1] - blY;
              points[_i27 + 1] = x - blX;
            }
            break;
          case 180:
            for (var _i28 = 0, _ii6 = points.length; _i28 < _ii6; _i28 += 2) {
              points[_i28] = trX - points[_i28];
              points[_i28 + 1] -= blY;
            }
            break;
          case 270:
            for (var _i29 = 0, _ii7 = points.length; _i29 < _ii7; _i29 += 2) {
              var _x20 = points[_i29];
              points[_i29] = trY - points[_i29 + 1];
              points[_i29 + 1] = trX - _x20;
            }
            break;
          default:
            throw new Error("Invalid rotation");
        }
        return points;
      }
      function _serializePaths(s, tx, ty, rect) {
        var paths = [];
        var padding = this.thickness / 2;
        var shiftX = s * tx + padding;
        var shiftY = s * ty + padding;
        var _iterator150 = _createForOfIteratorHelper(this.paths),
          _step150;
        try {
          for (_iterator150.s(); !(_step150 = _iterator150.n()).done;) {
            var bezier = _step150.value;
            var buffer = [];
            var points = [];
            for (var j = 0, jj = bezier.length; j < jj; j++) {
              var _bezier$j = _slicedToArray(bezier[j], 4),
                first = _bezier$j[0],
                control1 = _bezier$j[1],
                control2 = _bezier$j[2],
                second = _bezier$j[3];
              var p10 = s * first[0] + shiftX;
              var p11 = s * first[1] + shiftY;
              var p20 = s * control1[0] + shiftX;
              var p21 = s * control1[1] + shiftY;
              var p30 = s * control2[0] + shiftX;
              var p31 = s * control2[1] + shiftY;
              var p40 = s * second[0] + shiftX;
              var p41 = s * second[1] + shiftY;
              if (j === 0) {
                buffer.push(p10, p11);
                points.push(p10, p11);
              }
              buffer.push(p20, p21, p30, p31, p40, p41);
              points.push(p20, p21);
              if (j === jj - 1) {
                points.push(p40, p41);
              }
            }
            paths.push({
              bezier: _toPDFCoordinates.call(_InkEditor, buffer, rect, this.rotation),
              points: _toPDFCoordinates.call(_InkEditor, points, rect, this.rotation)
            });
          }
        } catch (err) {
          _iterator150.e(err);
        } finally {
          _iterator150.f();
        }
        return paths;
      }
      function _getBbox() {
        var xMin = Infinity;
        var xMax = -Infinity;
        var yMin = Infinity;
        var yMax = -Infinity;
        var _iterator151 = _createForOfIteratorHelper(this.paths),
          _step151;
        try {
          for (_iterator151.s(); !(_step151 = _iterator151.n()).done;) {
            var path = _step151.value;
            var _iterator152 = _createForOfIteratorHelper(path),
              _step152;
            try {
              for (_iterator152.s(); !(_step152 = _iterator152.n()).done;) {
                var _util$Util9;
                var _step152$value = _slicedToArray(_step152.value, 4),
                  first = _step152$value[0],
                  control1 = _step152$value[1],
                  control2 = _step152$value[2],
                  second = _step152$value[3];
                var bbox = (_util$Util9 = _util.Util).bezierBoundingBox.apply(_util$Util9, _toConsumableArray(first).concat(_toConsumableArray(control1), _toConsumableArray(control2), _toConsumableArray(second)));
                xMin = Math.min(xMin, bbox[0]);
                yMin = Math.min(yMin, bbox[1]);
                xMax = Math.max(xMax, bbox[2]);
                yMax = Math.max(yMax, bbox[3]);
              }
            } catch (err) {
              _iterator152.e(err);
            } finally {
              _iterator152.f();
            }
          }
        } catch (err) {
          _iterator151.e(err);
        } finally {
          _iterator151.f();
        }
        return [xMin, yMin, xMax, yMax];
      }
      function _getPadding() {
        return _classPrivateFieldGet(_disableEditing, this) ? Math.ceil(this.thickness * this.parentScale) : 0;
      }
      function _fitToContent() {
        var firstTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (this.isEmpty()) {
          return;
        }
        if (!_classPrivateFieldGet(_disableEditing, this)) {
          _assertClassBrand(_InkEditor_brand, this, _redraw).call(this);
          return;
        }
        var bbox = _assertClassBrand(_InkEditor_brand, this, _getBbox).call(this);
        var padding = _assertClassBrand(_InkEditor_brand, this, _getPadding).call(this);
        _classPrivateFieldSet(_baseWidth, this, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]));
        _classPrivateFieldSet(_baseHeight, this, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]));
        var width = Math.ceil(padding + _classPrivateFieldGet(_baseWidth, this) * this.scaleFactor);
        var height = Math.ceil(padding + _classPrivateFieldGet(_baseHeight, this) * this.scaleFactor);
        var _this$parentDimension16 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension16[0],
          parentHeight = _this$parentDimension16[1];
        this.width = width / parentWidth;
        this.height = height / parentHeight;
        this.setAspectRatio(width, height);
        var prevTranslationX = this.translationX;
        var prevTranslationY = this.translationY;
        this.translationX = -bbox[0];
        this.translationY = -bbox[1];
        _assertClassBrand(_InkEditor_brand, this, _setCanvasDims).call(this);
        _assertClassBrand(_InkEditor_brand, this, _redraw).call(this);
        _classPrivateFieldSet(_realWidth, this, width);
        _classPrivateFieldSet(_realHeight, this, height);
        this.setDims(width, height);
        var unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
        this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
      }
      _defineProperty(InkEditor, "_defaultColor", null);
      _defineProperty(InkEditor, "_defaultOpacity", 1);
      _defineProperty(InkEditor, "_defaultThickness", 1);
      _defineProperty(InkEditor, "_type", "ink");
      exports.InkEditor = InkEditor;

      /***/
    }), (/* 34 */
    /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {
      var _StampEditor;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StampEditor = void 0;
      var _util = __w_pdfjs_require__(1);
      var _editor = __w_pdfjs_require__(4);
      var _display_utils = __w_pdfjs_require__(6);
      var _annotation_layer = __w_pdfjs_require__(29);
      var _bitmap = /*#__PURE__*/new WeakMap();
      var _bitmapId = /*#__PURE__*/new WeakMap();
      var _bitmapPromise = /*#__PURE__*/new WeakMap();
      var _bitmapUrl = /*#__PURE__*/new WeakMap();
      var _bitmapFile = /*#__PURE__*/new WeakMap();
      var _canvas2 = /*#__PURE__*/new WeakMap();
      var _observer2 = /*#__PURE__*/new WeakMap();
      var _resizeTimeoutId = /*#__PURE__*/new WeakMap();
      var _isSvg = /*#__PURE__*/new WeakMap();
      var _hasBeenAddedInUndoStack = /*#__PURE__*/new WeakMap();
      var _StampEditor_brand = /*#__PURE__*/new WeakSet();
      var StampEditor = /*#__PURE__*/function (_editor$AnnotationEdi3) {
        function StampEditor(params) {
          var _this101;
          _classCallCheck(this, StampEditor);
          _this101 = _callSuper(this, StampEditor, [_objectSpread(_objectSpread({}, params), {}, {
            name: "stampEditor"
          })]);
          _classPrivateMethodInitSpec(_this101, _StampEditor_brand);
          _classPrivateFieldInitSpec(_this101, _bitmap, null);
          _classPrivateFieldInitSpec(_this101, _bitmapId, null);
          _classPrivateFieldInitSpec(_this101, _bitmapPromise, null);
          _classPrivateFieldInitSpec(_this101, _bitmapUrl, null);
          _classPrivateFieldInitSpec(_this101, _bitmapFile, null);
          _classPrivateFieldInitSpec(_this101, _canvas2, null);
          _classPrivateFieldInitSpec(_this101, _observer2, null);
          _classPrivateFieldInitSpec(_this101, _resizeTimeoutId, null);
          _classPrivateFieldInitSpec(_this101, _isSvg, false);
          _classPrivateFieldInitSpec(_this101, _hasBeenAddedInUndoStack, false);
          _classPrivateFieldSet(_bitmapUrl, _this101, params.bitmapUrl);
          _classPrivateFieldSet(_bitmapFile, _this101, params.bitmapFile);
          return _this101;
        }
        _inherits(StampEditor, _editor$AnnotationEdi3);
        return _createClass(StampEditor, [{
          key: "remove",
          value: function remove() {
            if (_classPrivateFieldGet(_bitmapId, this)) {
              var _classPrivateFieldGet34, _classPrivateFieldGet35;
              _classPrivateFieldSet(_bitmap, this, null);
              this._uiManager.imageManager.deleteId(_classPrivateFieldGet(_bitmapId, this));
              (_classPrivateFieldGet34 = _classPrivateFieldGet(_canvas2, this)) === null || _classPrivateFieldGet34 === void 0 || _classPrivateFieldGet34.remove();
              _classPrivateFieldSet(_canvas2, this, null);
              (_classPrivateFieldGet35 = _classPrivateFieldGet(_observer2, this)) === null || _classPrivateFieldGet35 === void 0 || _classPrivateFieldGet35.disconnect();
              _classPrivateFieldSet(_observer2, this, null);
            }
            _superPropGet(StampEditor, "remove", this, 3)([]);
          }
        }, {
          key: "rebuild",
          value: function rebuild() {
            if (!this.parent) {
              if (_classPrivateFieldGet(_bitmapId, this)) {
                _assertClassBrand(_StampEditor_brand, this, _getBitmap).call(this);
              }
              return;
            }
            _superPropGet(StampEditor, "rebuild", this, 3)([]);
            if (this.div === null) {
              return;
            }
            if (_classPrivateFieldGet(_bitmapId, this)) {
              _assertClassBrand(_StampEditor_brand, this, _getBitmap).call(this);
            }
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
            }
          }
        }, {
          key: "onceAdded",
          value: function onceAdded() {
            this._isDraggable = true;
            this.div.focus();
          }
        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return !(_classPrivateFieldGet(_bitmapPromise, this) || _classPrivateFieldGet(_bitmap, this) || _classPrivateFieldGet(_bitmapUrl, this) || _classPrivateFieldGet(_bitmapFile, this));
          }
        }, {
          key: "isResizable",
          get: function get() {
            return true;
          }
        }, {
          key: "render",
          value: function render() {
            if (this.div) {
              return this.div;
            }
            var baseX, baseY;
            if (this.width) {
              baseX = this.x;
              baseY = this.y;
            }
            _superPropGet(StampEditor, "render", this, 3)([]);
            this.div.hidden = true;
            if (_classPrivateFieldGet(_bitmap, this)) {
              _assertClassBrand(_StampEditor_brand, this, _createCanvas3).call(this);
            } else {
              _assertClassBrand(_StampEditor_brand, this, _getBitmap).call(this);
            }
            if (this.width) {
              var _this$parentDimension17 = _slicedToArray(this.parentDimensions, 2),
                parentWidth = _this$parentDimension17[0],
                parentHeight = _this$parentDimension17[1];
              this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
            }
            return this.div;
          }
        }, {
          key: "serialize",
          value: function serialize() {
            var isForCopying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (this.isEmpty()) {
              return null;
            }
            var serialized = {
              annotationType: _util.AnnotationEditorType.STAMP,
              bitmapId: _classPrivateFieldGet(_bitmapId, this),
              pageIndex: this.pageIndex,
              rect: this.getRect(0, 0),
              rotation: this.rotation,
              isSvg: _classPrivateFieldGet(_isSvg, this),
              structTreeParentId: this._structTreeParentId
            };
            if (isForCopying) {
              serialized.bitmapUrl = _assertClassBrand(_StampEditor_brand, this, _serializeBitmap).call(this, true);
              serialized.accessibilityData = this.altTextData;
              return serialized;
            }
            var _this$altTextData = this.altTextData,
              decorative = _this$altTextData.decorative,
              altText = _this$altTextData.altText;
            if (!decorative && altText) {
              serialized.accessibilityData = {
                type: "Figure",
                alt: altText
              };
            }
            if (context === null) {
              return serialized;
            }
            context.stamps || (context.stamps = new Map());
            var area = _classPrivateFieldGet(_isSvg, this) ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
            if (!context.stamps.has(_classPrivateFieldGet(_bitmapId, this))) {
              context.stamps.set(_classPrivateFieldGet(_bitmapId, this), {
                area: area,
                serialized: serialized
              });
              serialized.bitmap = _assertClassBrand(_StampEditor_brand, this, _serializeBitmap).call(this, false);
            } else if (_classPrivateFieldGet(_isSvg, this)) {
              var prevData = context.stamps.get(_classPrivateFieldGet(_bitmapId, this));
              if (area > prevData.area) {
                prevData.area = area;
                prevData.serialized.bitmap.close();
                prevData.serialized.bitmap = _assertClassBrand(_StampEditor_brand, this, _serializeBitmap).call(this, false);
              }
            }
            return serialized;
          }
        }], [{
          key: "initialize",
          value: function initialize(l10n) {
            _editor.AnnotationEditor.initialize(l10n);
          }
        }, {
          key: "supportedTypes",
          get: function get() {
            var types = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
            return (0, _util.shadow)(this, "supportedTypes", types.map(function (type) {
              return "image/".concat(type);
            }));
          }
        }, {
          key: "supportedTypesStr",
          get: function get() {
            return (0, _util.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
          }
        }, {
          key: "isHandlingMimeForPasting",
          value: function isHandlingMimeForPasting(mime) {
            return this.supportedTypes.includes(mime);
          }
        }, {
          key: "paste",
          value: function paste(item, parent) {
            parent.pasteEditor(_util.AnnotationEditorType.STAMP, {
              bitmapFile: item.getAsFile()
            });
          }
        }, {
          key: "deserialize",
          value: function deserialize(data, parent, uiManager) {
            if (data instanceof _annotation_layer.StampAnnotationElement) {
              return null;
            }
            var editor = _superPropGet(StampEditor, "deserialize", this, 2)([data, parent, uiManager]);
            var rect = data.rect,
              bitmapUrl = data.bitmapUrl,
              bitmapId = data.bitmapId,
              isSvg = data.isSvg,
              accessibilityData = data.accessibilityData;
            if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
              _classPrivateFieldSet(_bitmapId, editor, bitmapId);
            } else {
              _classPrivateFieldSet(_bitmapUrl, editor, bitmapUrl);
            }
            _classPrivateFieldSet(_isSvg, editor, isSvg);
            var _editor$pageDimension3 = _slicedToArray(editor.pageDimensions, 2),
              parentWidth = _editor$pageDimension3[0],
              parentHeight = _editor$pageDimension3[1];
            editor.width = (rect[2] - rect[0]) / parentWidth;
            editor.height = (rect[3] - rect[1]) / parentHeight;
            if (accessibilityData) {
              editor.altTextData = accessibilityData;
            }
            return editor;
          }
        }]);
      }(_editor.AnnotationEditor);
      _StampEditor = StampEditor;
      function _getBitmapFetched(data) {
        var fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!data) {
          this.remove();
          return;
        }
        _classPrivateFieldSet(_bitmap, this, data.bitmap);
        if (!fromId) {
          _classPrivateFieldSet(_bitmapId, this, data.id);
          _classPrivateFieldSet(_isSvg, this, data.isSvg);
        }
        _assertClassBrand(_StampEditor_brand, this, _createCanvas3).call(this);
      }
      function _getBitmapDone() {
        _classPrivateFieldSet(_bitmapPromise, this, null);
        this._uiManager.enableWaiting(false);
        if (_classPrivateFieldGet(_canvas2, this)) {
          this.div.focus();
        }
      }
      function _getBitmap() {
        var _this102 = this;
        if (_classPrivateFieldGet(_bitmapId, this)) {
          this._uiManager.enableWaiting(true);
          this._uiManager.imageManager.getFromId(_classPrivateFieldGet(_bitmapId, this)).then(function (data) {
            return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapFetched).call(_this102, data, true);
          }).finally(function () {
            return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapDone).call(_this102);
          });
          return;
        }
        if (_classPrivateFieldGet(_bitmapUrl, this)) {
          var url = _classPrivateFieldGet(_bitmapUrl, this);
          _classPrivateFieldSet(_bitmapUrl, this, null);
          this._uiManager.enableWaiting(true);
          _classPrivateFieldSet(_bitmapPromise, this, this._uiManager.imageManager.getFromUrl(url).then(function (data) {
            return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapFetched).call(_this102, data);
          }).finally(function () {
            return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapDone).call(_this102);
          }));
          return;
        }
        if (_classPrivateFieldGet(_bitmapFile, this)) {
          var file = _classPrivateFieldGet(_bitmapFile, this);
          _classPrivateFieldSet(_bitmapFile, this, null);
          this._uiManager.enableWaiting(true);
          _classPrivateFieldSet(_bitmapPromise, this, this._uiManager.imageManager.getFromFile(file).then(function (data) {
            return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapFetched).call(_this102, data);
          }).finally(function () {
            return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapDone).call(_this102);
          }));
          return;
        }
        var input = document.createElement("input");
        input.type = "file";
        input.accept = _StampEditor.supportedTypesStr;
        _classPrivateFieldSet(_bitmapPromise, this, new Promise(function (resolve) {
          input.addEventListener("change", /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
            var data;
            return _regeneratorRuntime().wrap(function _callee33$(_context33) {
              while (1) switch (_context33.prev = _context33.next) {
                case 0:
                  if (!(!input.files || input.files.length === 0)) {
                    _context33.next = 4;
                    break;
                  }
                  _this102.remove();
                  _context33.next = 9;
                  break;
                case 4:
                  _this102._uiManager.enableWaiting(true);
                  _context33.next = 7;
                  return _this102._uiManager.imageManager.getFromFile(input.files[0]);
                case 7:
                  data = _context33.sent;
                  _assertClassBrand(_StampEditor_brand, _this102, _getBitmapFetched).call(_this102, data);
                case 9:
                  resolve();
                case 10:
                case "end":
                  return _context33.stop();
              }
            }, _callee33);
          })));
          input.addEventListener("cancel", function () {
            _this102.remove();
            resolve();
          });
        }).finally(function () {
          return _assertClassBrand(_StampEditor_brand, _this102, _getBitmapDone).call(_this102);
        }));
        input.click();
      }
      function _createCanvas3() {
        var div = this.div;
        var _classPrivateFieldGet36 = _classPrivateFieldGet(_bitmap, this),
          width = _classPrivateFieldGet36.width,
          height = _classPrivateFieldGet36.height;
        var _this$pageDimensions8 = _slicedToArray(this.pageDimensions, 2),
          pageWidth = _this$pageDimensions8[0],
          pageHeight = _this$pageDimensions8[1];
        var MAX_RATIO = 0.75;
        if (this.width) {
          width = this.width * pageWidth;
          height = this.height * pageHeight;
        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
          var factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
          width *= factor;
          height *= factor;
        }
        var _this$parentDimension18 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension18[0],
          parentHeight = _this$parentDimension18[1];
        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
        this._uiManager.enableWaiting(false);
        var canvas = _classPrivateFieldSet(_canvas2, this, document.createElement("canvas"));
        div.append(canvas);
        div.hidden = false;
        _assertClassBrand(_StampEditor_brand, this, _drawBitmap).call(this, width, height);
        _assertClassBrand(_StampEditor_brand, this, _createObserver2).call(this);
        if (!_classPrivateFieldGet(_hasBeenAddedInUndoStack, this)) {
          this.parent.addUndoableEditor(this);
          _classPrivateFieldSet(_hasBeenAddedInUndoStack, this, true);
        }
        this._uiManager._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            subtype: this.editorType,
            data: {
              action: "inserted_image"
            }
          }
        });
        this.addAltTextButton();
      }
      function _setDimensions(width, height) {
        var _this$_initialOptions2,
          _this103 = this;
        var _this$parentDimension19 = _slicedToArray(this.parentDimensions, 2),
          parentWidth = _this$parentDimension19[0],
          parentHeight = _this$parentDimension19[1];
        this.width = width / parentWidth;
        this.height = height / parentHeight;
        this.setDims(width, height);
        if ((_this$_initialOptions2 = this._initialOptions) !== null && _this$_initialOptions2 !== void 0 && _this$_initialOptions2.isCentered) {
          this.center();
        } else {
          this.fixAndSetPosition();
        }
        this._initialOptions = null;
        if (_classPrivateFieldGet(_resizeTimeoutId, this) !== null) {
          clearTimeout(_classPrivateFieldGet(_resizeTimeoutId, this));
        }
        var TIME_TO_WAIT = 200;
        _classPrivateFieldSet(_resizeTimeoutId, this, setTimeout(function () {
          _classPrivateFieldSet(_resizeTimeoutId, _this103, null);
          _assertClassBrand(_StampEditor_brand, _this103, _drawBitmap).call(_this103, width, height);
        }, TIME_TO_WAIT));
      }
      function _scaleBitmap(width, height) {
        var _classPrivateFieldGet37 = _classPrivateFieldGet(_bitmap, this),
          bitmapWidth = _classPrivateFieldGet37.width,
          bitmapHeight = _classPrivateFieldGet37.height;
        var newWidth = bitmapWidth;
        var newHeight = bitmapHeight;
        var bitmap = _classPrivateFieldGet(_bitmap, this);
        while (newWidth > 2 * width || newHeight > 2 * height) {
          var prevWidth = newWidth;
          var prevHeight = newHeight;
          if (newWidth > 2 * width) {
            newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
          }
          if (newHeight > 2 * height) {
            newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
          }
          var offscreen = new OffscreenCanvas(newWidth, newHeight);
          var ctx = offscreen.getContext("2d");
          ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
          bitmap = offscreen.transferToImageBitmap();
        }
        return bitmap;
      }
      function _drawBitmap(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        var canvas = _classPrivateFieldGet(_canvas2, this);
        if (!canvas || canvas.width === width && canvas.height === height) {
          return;
        }
        canvas.width = width;
        canvas.height = height;
        var bitmap = _classPrivateFieldGet(_isSvg, this) ? _classPrivateFieldGet(_bitmap, this) : _assertClassBrand(_StampEditor_brand, this, _scaleBitmap).call(this, width, height);
        var ctx = canvas.getContext("2d");
        ctx.filter = this._uiManager.hcmFilter;
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
      }
      function _serializeBitmap(toUrl) {
        if (toUrl) {
          if (_classPrivateFieldGet(_isSvg, this)) {
            var url = this._uiManager.imageManager.getSvgUrl(_classPrivateFieldGet(_bitmapId, this));
            if (url) {
              return url;
            }
          }
          var canvas = document.createElement("canvas");
          var _classPrivateFieldGet38 = _classPrivateFieldGet(_bitmap, this);
          canvas.width = _classPrivateFieldGet38.width;
          canvas.height = _classPrivateFieldGet38.height;
          var ctx = canvas.getContext("2d");
          ctx.drawImage(_classPrivateFieldGet(_bitmap, this), 0, 0);
          return canvas.toDataURL();
        }
        if (_classPrivateFieldGet(_isSvg, this)) {
          var _this$pageDimensions9 = _slicedToArray(this.pageDimensions, 2),
            pageWidth = _this$pageDimensions9[0],
            pageHeight = _this$pageDimensions9[1];
          var width = Math.round(this.width * pageWidth * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
          var height = Math.round(this.height * pageHeight * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
          var offscreen = new OffscreenCanvas(width, height);
          var _ctx = offscreen.getContext("2d");
          _ctx.drawImage(_classPrivateFieldGet(_bitmap, this), 0, 0, _classPrivateFieldGet(_bitmap, this).width, _classPrivateFieldGet(_bitmap, this).height, 0, 0, width, height);
          return offscreen.transferToImageBitmap();
        }
        return structuredClone(_classPrivateFieldGet(_bitmap, this));
      }
      function _createObserver2() {
        var _this104 = this;
        _classPrivateFieldSet(_observer2, this, new ResizeObserver(function (entries) {
          var rect = entries[0].contentRect;
          if (rect.width && rect.height) {
            _assertClassBrand(_StampEditor_brand, _this104, _setDimensions).call(_this104, rect.width, rect.height);
          }
        }));
        _classPrivateFieldGet(_observer2, this).observe(this.div);
      }
      _defineProperty(StampEditor, "_type", "stamp");
      exports.StampEditor = StampEditor;

      /***/
    }
    /******/)];
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __w_pdfjs_require__(moduleId) {
      /******/ // Check if module is in cache
      /******/var cachedModule = __webpack_module_cache__[moduleId];
      /******/
      if (cachedModule !== undefined) {
        /******/return cachedModule.exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = __webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
    (function () {
      var exports = __webpack_exports__;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AbortException", {
        enumerable: true,
        get: function get() {
          return _util.AbortException;
        }
      });
      Object.defineProperty(exports, "AnnotationEditorLayer", {
        enumerable: true,
        get: function get() {
          return _annotation_editor_layer.AnnotationEditorLayer;
        }
      });
      Object.defineProperty(exports, "AnnotationEditorParamsType", {
        enumerable: true,
        get: function get() {
          return _util.AnnotationEditorParamsType;
        }
      });
      Object.defineProperty(exports, "AnnotationEditorType", {
        enumerable: true,
        get: function get() {
          return _util.AnnotationEditorType;
        }
      });
      Object.defineProperty(exports, "AnnotationEditorUIManager", {
        enumerable: true,
        get: function get() {
          return _tools.AnnotationEditorUIManager;
        }
      });
      Object.defineProperty(exports, "AnnotationLayer", {
        enumerable: true,
        get: function get() {
          return _annotation_layer.AnnotationLayer;
        }
      });
      Object.defineProperty(exports, "AnnotationMode", {
        enumerable: true,
        get: function get() {
          return _util.AnnotationMode;
        }
      });
      Object.defineProperty(exports, "CMapCompressionType", {
        enumerable: true,
        get: function get() {
          return _util.CMapCompressionType;
        }
      });
      Object.defineProperty(exports, "DOMSVGFactory", {
        enumerable: true,
        get: function get() {
          return _display_utils.DOMSVGFactory;
        }
      });
      Object.defineProperty(exports, "FeatureTest", {
        enumerable: true,
        get: function get() {
          return _util.FeatureTest;
        }
      });
      Object.defineProperty(exports, "GlobalWorkerOptions", {
        enumerable: true,
        get: function get() {
          return _worker_options.GlobalWorkerOptions;
        }
      });
      Object.defineProperty(exports, "ImageKind", {
        enumerable: true,
        get: function get() {
          return _util.ImageKind;
        }
      });
      Object.defineProperty(exports, "InvalidPDFException", {
        enumerable: true,
        get: function get() {
          return _util.InvalidPDFException;
        }
      });
      Object.defineProperty(exports, "MissingPDFException", {
        enumerable: true,
        get: function get() {
          return _util.MissingPDFException;
        }
      });
      Object.defineProperty(exports, "OPS", {
        enumerable: true,
        get: function get() {
          return _util.OPS;
        }
      });
      Object.defineProperty(exports, "PDFDataRangeTransport", {
        enumerable: true,
        get: function get() {
          return _api.PDFDataRangeTransport;
        }
      });
      Object.defineProperty(exports, "PDFDateString", {
        enumerable: true,
        get: function get() {
          return _display_utils.PDFDateString;
        }
      });
      Object.defineProperty(exports, "PDFWorker", {
        enumerable: true,
        get: function get() {
          return _api.PDFWorker;
        }
      });
      Object.defineProperty(exports, "PasswordResponses", {
        enumerable: true,
        get: function get() {
          return _util.PasswordResponses;
        }
      });
      Object.defineProperty(exports, "PermissionFlag", {
        enumerable: true,
        get: function get() {
          return _util.PermissionFlag;
        }
      });
      Object.defineProperty(exports, "PixelsPerInch", {
        enumerable: true,
        get: function get() {
          return _display_utils.PixelsPerInch;
        }
      });
      Object.defineProperty(exports, "PromiseCapability", {
        enumerable: true,
        get: function get() {
          return _util.PromiseCapability;
        }
      });
      Object.defineProperty(exports, "RenderingCancelledException", {
        enumerable: true,
        get: function get() {
          return _display_utils.RenderingCancelledException;
        }
      });
      Object.defineProperty(exports, "SVGGraphics", {
        enumerable: true,
        get: function get() {
          return _api.SVGGraphics;
        }
      });
      Object.defineProperty(exports, "UnexpectedResponseException", {
        enumerable: true,
        get: function get() {
          return _util.UnexpectedResponseException;
        }
      });
      Object.defineProperty(exports, "Util", {
        enumerable: true,
        get: function get() {
          return _util.Util;
        }
      });
      Object.defineProperty(exports, "VerbosityLevel", {
        enumerable: true,
        get: function get() {
          return _util.VerbosityLevel;
        }
      });
      Object.defineProperty(exports, "XfaLayer", {
        enumerable: true,
        get: function get() {
          return _xfa_layer.XfaLayer;
        }
      });
      Object.defineProperty(exports, "build", {
        enumerable: true,
        get: function get() {
          return _api.build;
        }
      });
      Object.defineProperty(exports, "createValidAbsoluteUrl", {
        enumerable: true,
        get: function get() {
          return _util.createValidAbsoluteUrl;
        }
      });
      Object.defineProperty(exports, "getDocument", {
        enumerable: true,
        get: function get() {
          return _api.getDocument;
        }
      });
      Object.defineProperty(exports, "getFilenameFromUrl", {
        enumerable: true,
        get: function get() {
          return _display_utils.getFilenameFromUrl;
        }
      });
      Object.defineProperty(exports, "getPdfFilenameFromUrl", {
        enumerable: true,
        get: function get() {
          return _display_utils.getPdfFilenameFromUrl;
        }
      });
      Object.defineProperty(exports, "getXfaPageViewport", {
        enumerable: true,
        get: function get() {
          return _display_utils.getXfaPageViewport;
        }
      });
      Object.defineProperty(exports, "isDataScheme", {
        enumerable: true,
        get: function get() {
          return _display_utils.isDataScheme;
        }
      });
      Object.defineProperty(exports, "isPdfFile", {
        enumerable: true,
        get: function get() {
          return _display_utils.isPdfFile;
        }
      });
      Object.defineProperty(exports, "loadScript", {
        enumerable: true,
        get: function get() {
          return _display_utils.loadScript;
        }
      });
      Object.defineProperty(exports, "noContextMenu", {
        enumerable: true,
        get: function get() {
          return _display_utils.noContextMenu;
        }
      });
      Object.defineProperty(exports, "normalizeUnicode", {
        enumerable: true,
        get: function get() {
          return _util.normalizeUnicode;
        }
      });
      Object.defineProperty(exports, "renderTextLayer", {
        enumerable: true,
        get: function get() {
          return _text_layer.renderTextLayer;
        }
      });
      Object.defineProperty(exports, "setLayerDimensions", {
        enumerable: true,
        get: function get() {
          return _display_utils.setLayerDimensions;
        }
      });
      Object.defineProperty(exports, "shadow", {
        enumerable: true,
        get: function get() {
          return _util.shadow;
        }
      });
      Object.defineProperty(exports, "updateTextLayer", {
        enumerable: true,
        get: function get() {
          return _text_layer.updateTextLayer;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function get() {
          return _api.version;
        }
      });
      var _util = __w_pdfjs_require__(1);
      var _api = __w_pdfjs_require__(2);
      var _display_utils = __w_pdfjs_require__(6);
      var _text_layer = __w_pdfjs_require__(26);
      var _annotation_editor_layer = __w_pdfjs_require__(27);
      var _tools = __w_pdfjs_require__(5);
      var _annotation_layer = __w_pdfjs_require__(29);
      var _worker_options = __w_pdfjs_require__(14);
      var _xfa_layer = __w_pdfjs_require__(32);
      var pdfjsVersion = '3.11.174';
      var pdfjsBuild = 'ce8716743';
    })();

    /******/
    return __webpack_exports__;
    /******/
  }();
});
},{"fs":"../node_modules/parcel-bundler/src/builtins/_empty.js","canvas":"../node_modules/parcel-bundler/src/builtins/_empty.js","url":"../node_modules/parcel-bundler/src/builtins/_empty.js","http":"../node_modules/parcel-bundler/src/builtins/_empty.js","https":"../node_modules/parcel-bundler/src/builtins/_empty.js","zlib":"../node_modules/parcel-bundler/src/builtins/_empty.js","process":"../node_modules/process/browser.js","buffer":"../node_modules/node-libs-browser/node_modules/buffer/index.js"}],"../node_modules/axios/lib/helpers/bind.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bind;
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
},{}],"../node_modules/axios/lib/utils.js":[function(require,module,exports) {
var global = arguments[3];
var define;
var process = require("process");
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _bind = _interopRequireDefault(require("./helpers/bind.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// utils is a library of generic helper functions non-specific to axios

const {
  toString
} = Object.prototype;
const {
  getPrototypeOf
} = Object;
const kindOf = (cache => thing => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
const kindOfTest = type => {
  type = type.toLowerCase();
  return thing => kindOf(thing) === type;
};
const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {
  isArray
} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = thing => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = val => {
  if (kindOf(val) !== 'object') {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = val => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = thing => {
  let kind;
  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
  // detect form-data instance
  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');
const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {
  allOwnKeys = false
} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }
  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }
  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();
const isContextDefined = context => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */
) {
  const {
    caseless
  } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {
  allOwnKeys
} = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = (0, _bind.default)(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {
    allOwnKeys
  });
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = content => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};

/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = thing => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');
const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({
  hasOwnProperty
}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');
const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = obj => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = arr => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}
const toJSONObject = obj => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest('AsyncFunction');
const isThenable = thing => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({
      source,
      data
    }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return cb => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : cb => setTimeout(cb);
})(typeof setImmediate === 'function', isFunction(_global.postMessage));
const asap = typeof queueMicrotask !== 'undefined' ? queueMicrotask.bind(_global) : typeof process !== 'undefined' && process.nextTick || _setImmediate;

// *********************
var _default = exports.default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
},{"./helpers/bind.js":"../node_modules/axios/lib/helpers/bind.js","process":"../node_modules/process/browser.js"}],"../node_modules/axios/lib/core/AxiosError.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
_utils.default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils.default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype = AxiosError.prototype;
const descriptors = {};
['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {
  value: true
});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  _utils.default.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var _default = exports.default = AxiosError;
},{"../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/helpers/null.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// eslint-disable-next-line strict
var _default = exports.default = null;
},{}],"../node_modules/axios/lib/helpers/toFormData.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _FormData = _interopRequireDefault(require("../platform/node/classes/FormData.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils.default.isPlainObject(thing) || _utils.default.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return _utils.default.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils.default.isArray(arr) && !arr.some(isVisitable);
}
const predicates = _utils.default.toFlatObject(_utils.default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils.default.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_FormData.default || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils.default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils.default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && _utils.default.isSpecCompliantForm(formData);
  if (!_utils.default.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }
  function convertValue(value) {
    if (value === null) return '';
    if (_utils.default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && _utils.default.isBlob(value)) {
      throw new _AxiosError.default('Blob is not supported. Use a Buffer instead.');
    }
    if (_utils.default.isArrayBuffer(value) || _utils.default.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === 'object') {
      if (_utils.default.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (_utils.default.isArray(value) && isFlatArray(value) || (_utils.default.isFileList(value) || _utils.default.endsWith(key, '[]')) && (arr = _utils.default.toArray(value))) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(_utils.default.isUndefined(el) || el === null) && formData.append(
          // eslint-disable-next-line no-nested-ternary
          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (_utils.default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }
    stack.push(value);
    _utils.default.forEach(value, function each(el, key) {
      const result = !(_utils.default.isUndefined(el) || el === null) && visitor.call(formData, el, _utils.default.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!_utils.default.isObject(obj)) {
    throw new TypeError('data must be an object');
  }
  build(obj);
  return formData;
}
var _default = exports.default = toFormData;
},{"../utils.js":"../node_modules/axios/lib/utils.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","../platform/node/classes/FormData.js":"../node_modules/axios/lib/helpers/null.js","buffer":"../node_modules/node-libs-browser/node_modules/buffer/index.js"}],"../node_modules/axios/lib/helpers/AxiosURLSearchParams.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _toFormData = _interopRequireDefault(require("./toFormData.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && (0, _toFormData.default)(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function (value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};
var _default = exports.default = AxiosURLSearchParams;
},{"./toFormData.js":"../node_modules/axios/lib/helpers/toFormData.js"}],"../node_modules/axios/lib/helpers/buildURL.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildURL;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosURLSearchParams = _interopRequireDefault(require("../helpers/AxiosURLSearchParams.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (_utils.default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils.default.isURLSearchParams(params) ? params.toString() : new _AxiosURLSearchParams.default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }
  return url;
}
},{"../utils.js":"../node_modules/axios/lib/utils.js","../helpers/AxiosURLSearchParams.js":"../node_modules/axios/lib/helpers/AxiosURLSearchParams.js"}],"../node_modules/axios/lib/core/InterceptorManager.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    _utils.default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var _default = exports.default = InterceptorManager;
},{"./../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/defaults/transitional.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
},{}],"../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _AxiosURLSearchParams = _interopRequireDefault(require("../../../helpers/AxiosURLSearchParams.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = exports.default = typeof URLSearchParams !== 'undefined' ? URLSearchParams : _AxiosURLSearchParams.default;
},{"../../../helpers/AxiosURLSearchParams.js":"../node_modules/axios/lib/helpers/AxiosURLSearchParams.js"}],"../node_modules/axios/lib/platform/browser/classes/FormData.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = typeof FormData !== 'undefined' ? FormData : null;
},{}],"../node_modules/axios/lib/platform/browser/classes/Blob.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = typeof Blob !== 'undefined' ? Blob : null;
},{}],"../node_modules/axios/lib/platform/browser/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _URLSearchParams = _interopRequireDefault(require("./classes/URLSearchParams.js"));
var _FormData = _interopRequireDefault(require("./classes/FormData.js"));
var _Blob = _interopRequireDefault(require("./classes/Blob.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = exports.default = {
  isBrowser: true,
  classes: {
    URLSearchParams: _URLSearchParams.default,
    FormData: _FormData.default,
    Blob: _Blob.default
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};
},{"./classes/URLSearchParams.js":"../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js","./classes/FormData.js":"../node_modules/axios/lib/platform/browser/classes/FormData.js","./classes/Blob.js":"../node_modules/axios/lib/platform/browser/classes/Blob.js"}],"../node_modules/axios/lib/platform/common/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.origin = exports.navigator = exports.hasStandardBrowserWebWorkerEnv = exports.hasStandardBrowserEnv = exports.hasBrowserEnv = void 0;
const hasBrowserEnv = exports.hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
const _navigator = exports.navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = exports.hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = exports.hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== 'undefined' &&
  // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();
const origin = exports.origin = hasBrowserEnv && window.location.href || 'http://localhost';
},{}],"../node_modules/axios/lib/platform/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _index = _interopRequireDefault(require("./node/index.js"));
var utils = _interopRequireWildcard(require("./common/utils.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = exports.default = {
  ...utils,
  ..._index.default
};
},{"./node/index.js":"../node_modules/axios/lib/platform/browser/index.js","./common/utils.js":"../node_modules/axios/lib/platform/common/utils.js"}],"../node_modules/axios/lib/helpers/toURLEncodedForm.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toURLEncodedForm;
var _utils = _interopRequireDefault(require("../utils.js"));
var _toFormData = _interopRequireDefault(require("./toFormData.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function toURLEncodedForm(data, options) {
  return (0, _toFormData.default)(data, new _index.default.classes.URLSearchParams(), Object.assign({
    visitor: function (value, key, path, helpers) {
      if (_index.default.isNode && _utils.default.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
},{"../utils.js":"../node_modules/axios/lib/utils.js","./toFormData.js":"../node_modules/axios/lib/helpers/toFormData.js","../platform/index.js":"../node_modules/axios/lib/platform/index.js"}],"../node_modules/axios/lib/helpers/formDataToJSON.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils.default.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === '__proto__') return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && _utils.default.isArray(target) ? target.length : name;
    if (isLast) {
      if (_utils.default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !_utils.default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && _utils.default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (_utils.default.isFormData(formData) && _utils.default.isFunction(formData.entries)) {
    const obj = {};
    _utils.default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var _default = exports.default = formDataToJSON;
},{"../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/defaults/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _transitional = _interopRequireDefault(require("./transitional.js"));
var _toFormData = _interopRequireDefault(require("../helpers/toFormData.js"));
var _toURLEncodedForm = _interopRequireDefault(require("../helpers/toURLEncodedForm.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
var _formDataToJSON = _interopRequireDefault(require("../helpers/formDataToJSON.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils.default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils.default.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: _transitional.default,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = _utils.default.isObject(data);
    if (isObjectPayload && _utils.default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData = _utils.default.isFormData(data);
    if (isFormData) {
      return hasJSONContentType ? JSON.stringify((0, _formDataToJSON.default)(data)) : data;
    }
    if (_utils.default.isArrayBuffer(data) || _utils.default.isBuffer(data) || _utils.default.isStream(data) || _utils.default.isFile(data) || _utils.default.isBlob(data) || _utils.default.isReadableStream(data)) {
      return data;
    }
    if (_utils.default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils.default.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }
    let isFileList;
    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0, _toURLEncodedForm.default)(data, this.formSerializer).toString();
      }
      if ((isFileList = _utils.default.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;
        return (0, _toFormData.default)(isFileList ? {
          'files[]': data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';
    if (_utils.default.isResponse(data) || _utils.default.isReadableStream(data)) {
      return data;
    }
    if (data && _utils.default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _AxiosError.default.from(e, _AxiosError.default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: _index.default.classes.FormData,
    Blob: _index.default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};
_utils.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], method => {
  defaults.headers[method] = {};
});
var _default = exports.default = defaults;
},{"../utils.js":"../node_modules/axios/lib/utils.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","./transitional.js":"../node_modules/axios/lib/defaults/transitional.js","../helpers/toFormData.js":"../node_modules/axios/lib/helpers/toFormData.js","../helpers/toURLEncodedForm.js":"../node_modules/axios/lib/helpers/toURLEncodedForm.js","../platform/index.js":"../node_modules/axios/lib/platform/index.js","../helpers/formDataToJSON.js":"../node_modules/axios/lib/helpers/formDataToJSON.js"}],"../node_modules/axios/lib/helpers/parseHeaders.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utils.default.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var _default = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });
  return parsed;
};
exports.default = _default;
},{"./../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/core/AxiosHeaders.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _parseHeaders = _interopRequireDefault(require("../helpers/parseHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const $internals = Symbol('internals');
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return _utils.default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils.default.isFunction(filter)) {
    return filter.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!_utils.default.isString(value)) return;
  if (_utils.default.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }
  if (_utils.default.isRegExp(filter)) {
    return filter.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = _utils.default.toCamelCase(' ' + header);
  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }
      const key = _utils.default.findKey(self, lHeader);
      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
        self[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => _utils.default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (_utils.default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (_utils.default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders((0, _parseHeaders.default)(header), valueOrRewrite);
    } else if (_utils.default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = _utils.default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (_utils.default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (_utils.default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = _utils.default.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = _utils.default.findKey(self, _header);
        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];
          deleted = true;
        }
      }
    }
    if (_utils.default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self = this;
    const headers = {};
    _utils.default.forEach(this, (value, header) => {
      const key = _utils.default.findKey(headers, header);
      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self[header];
      }
      self[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    _utils.default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && _utils.default.isArray(value) ? value.join(', ') : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach(target => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }
    _utils.default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
_utils.default.reduceDescriptors(AxiosHeaders.prototype, ({
  value
}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
_utils.default.freezeMethods(AxiosHeaders);
var _default = exports.default = AxiosHeaders;
},{"../utils.js":"../node_modules/axios/lib/utils.js","../helpers/parseHeaders.js":"../node_modules/axios/lib/helpers/parseHeaders.js"}],"../node_modules/axios/lib/core/transformData.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transformData;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _index = _interopRequireDefault(require("../defaults/index.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || _index.default;
  const context = response || config;
  const headers = _AxiosHeaders.default.from(context.headers);
  let data = context.data;
  _utils.default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}
},{"./../utils.js":"../node_modules/axios/lib/utils.js","../defaults/index.js":"../node_modules/axios/lib/defaults/index.js","../core/AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js"}],"../node_modules/axios/lib/cancel/isCancel.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCancel;
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
},{}],"../node_modules/axios/lib/cancel/CanceledError.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _AxiosError.default.call(this, message == null ? 'canceled' : message, _AxiosError.default.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}
_utils.default.inherits(CanceledError, _AxiosError.default, {
  __CANCEL__: true
});
var _default = exports.default = CanceledError;
},{"../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/core/settle.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = settle;
var _AxiosError = _interopRequireDefault(require("./AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError.default('Request failed with status code ' + response.status, [_AxiosError.default.ERR_BAD_REQUEST, _AxiosError.default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
},{"./AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js"}],"../node_modules/axios/lib/helpers/parseProtocol.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseProtocol;
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}
},{}],"../node_modules/axios/lib/helpers/speedometer.js":[function(require,module,exports) {
'use strict';

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
var _default = exports.default = speedometer;
},{}],"../node_modules/axios/lib/helpers/throttle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var _default = exports.default = throttle;
},{}],"../node_modules/axios/lib/helpers/progressEventReducer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.progressEventReducer = exports.progressEventDecorator = exports.asyncDecorator = void 0;
var _speedometer2 = _interopRequireDefault(require("./speedometer.js"));
var _throttle = _interopRequireDefault(require("./throttle.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = (0, _speedometer2.default)(50, 250);
  return (0, _throttle.default)(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };
    listener(data);
  }, freq);
};
exports.progressEventReducer = progressEventReducer;
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [loaded => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
exports.progressEventDecorator = progressEventDecorator;
const asyncDecorator = fn => (...args) => _utils.default.asap(() => fn(...args));
exports.asyncDecorator = asyncDecorator;
},{"./speedometer.js":"../node_modules/axios/lib/helpers/speedometer.js","./throttle.js":"../node_modules/axios/lib/helpers/throttle.js","../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/helpers/isURLSameOrigin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _index = _interopRequireDefault(require("../platform/index.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = exports.default = _index.default.hasStandardBrowserEnv ? ((origin, isMSIE) => url => {
  url = new URL(url, _index.default.origin);
  return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);
})(new URL(_index.default.origin), _index.default.navigator && /(msie|trident)/i.test(_index.default.navigator.userAgent)) : () => true;
},{"../platform/index.js":"../node_modules/axios/lib/platform/index.js"}],"../node_modules/axios/lib/helpers/cookies.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = exports.default = _index.default.hasStandardBrowserEnv ?
// Standard browser envs support document.cookie
{
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + '=' + encodeURIComponent(value)];
    _utils.default.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
    _utils.default.isString(path) && cookie.push('path=' + path);
    _utils.default.isString(domain) && cookie.push('domain=' + domain);
    secure === true && cookie.push('secure');
    document.cookie = cookie.join('; ');
  },
  read(name) {
    const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, '', Date.now() - 86400000);
  }
} :
// Non-standard browser env (web workers, react-native) lack needed support.
{
  write() {},
  read() {
    return null;
  },
  remove() {}
};
},{"./../utils.js":"../node_modules/axios/lib/utils.js","../platform/index.js":"../node_modules/axios/lib/platform/index.js"}],"../node_modules/axios/lib/helpers/isAbsoluteURL.js":[function(require,module,exports) {
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isAbsoluteURL;
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
},{}],"../node_modules/axios/lib/helpers/combineURLs.js":[function(require,module,exports) {
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = combineURLs;
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}
},{}],"../node_modules/axios/lib/core/buildFullPath.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildFullPath;
var _isAbsoluteURL = _interopRequireDefault(require("../helpers/isAbsoluteURL.js"));
var _combineURLs = _interopRequireDefault(require("../helpers/combineURLs.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !(0, _isAbsoluteURL.default)(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return (0, _combineURLs.default)(baseURL, requestedURL);
  }
  return requestedURL;
}
},{"../helpers/isAbsoluteURL.js":"../node_modules/axios/lib/helpers/isAbsoluteURL.js","../helpers/combineURLs.js":"../node_modules/axios/lib/helpers/combineURLs.js"}],"../node_modules/axios/lib/core/mergeConfig.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeConfig;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosHeaders = _interopRequireDefault(require("./AxiosHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const headersToObject = thing => thing instanceof _AxiosHeaders.default ? {
  ...thing
} : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (_utils.default.isPlainObject(target) && _utils.default.isPlainObject(source)) {
      return _utils.default.merge.call({
        caseless
      }, target, source);
    } else if (_utils.default.isPlainObject(source)) {
      return _utils.default.merge({}, source);
    } else if (_utils.default.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!_utils.default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!_utils.default.isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils.default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils.default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils.default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  _utils.default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    _utils.default.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
},{"../utils.js":"../node_modules/axios/lib/utils.js","./AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js"}],"../node_modules/axios/lib/helpers/resolveConfig.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _index = _interopRequireDefault(require("../platform/index.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
var _isURLSameOrigin = _interopRequireDefault(require("./isURLSameOrigin.js"));
var _cookies = _interopRequireDefault(require("./cookies.js"));
var _buildFullPath = _interopRequireDefault(require("../core/buildFullPath.js"));
var _mergeConfig = _interopRequireDefault(require("../core/mergeConfig.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _buildURL = _interopRequireDefault(require("./buildURL.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = config => {
  const newConfig = (0, _mergeConfig.default)({}, config);
  let {
    data,
    withXSRFToken,
    xsrfHeaderName,
    xsrfCookieName,
    headers,
    auth
  } = newConfig;
  newConfig.headers = headers = _AxiosHeaders.default.from(headers);
  newConfig.url = (0, _buildURL.default)((0, _buildFullPath.default)(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
  }
  let contentType;
  if (_utils.default.isFormData(data)) {
    if (_index.default.hasStandardBrowserEnv || _index.default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (_index.default.hasStandardBrowserEnv) {
    withXSRFToken && _utils.default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOrigin.default)(newConfig.url)) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies.default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
exports.default = _default;
},{"../platform/index.js":"../node_modules/axios/lib/platform/index.js","../utils.js":"../node_modules/axios/lib/utils.js","./isURLSameOrigin.js":"../node_modules/axios/lib/helpers/isURLSameOrigin.js","./cookies.js":"../node_modules/axios/lib/helpers/cookies.js","../core/buildFullPath.js":"../node_modules/axios/lib/core/buildFullPath.js","../core/mergeConfig.js":"../node_modules/axios/lib/core/mergeConfig.js","../core/AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js","./buildURL.js":"../node_modules/axios/lib/helpers/buildURL.js"}],"../node_modules/axios/lib/adapters/xhr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _settle = _interopRequireDefault(require("./../core/settle.js"));
var _transitional = _interopRequireDefault(require("../defaults/transitional.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));
var _parseProtocol = _interopRequireDefault(require("../helpers/parseProtocol.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _progressEventReducer = require("../helpers/progressEventReducer.js");
var _resolveConfig = _interopRequireDefault(require("../helpers/resolveConfig.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
var _default = exports.default = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = (0, _resolveConfig.default)(config);
    let requestData = _config.data;
    const requestHeaders = _AxiosHeaders.default.from(_config.headers).normalize();
    let {
      responseType,
      onUploadProgress,
      onDownloadProgress
    } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _AxiosHeaders.default.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      (0, _settle.default)(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }
    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new _AxiosError.default('Request aborted', _AxiosError.default.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _AxiosError.default('Network Error', _AxiosError.default.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || _transitional.default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new _AxiosError.default(timeoutErrorMessage, transitional.clarifyTimeoutError ? _AxiosError.default.ETIMEDOUT : _AxiosError.default.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils.default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils.default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = (0, _progressEventReducer.progressEventReducer)(onDownloadProgress, true);
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = (0, _progressEventReducer.progressEventReducer)(onUploadProgress);
      request.upload.addEventListener('progress', uploadThrottled);
      request.upload.addEventListener('loadend', flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _CanceledError.default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }
    const protocol = (0, _parseProtocol.default)(_config.url);
    if (protocol && _index.default.protocols.indexOf(protocol) === -1) {
      reject(new _AxiosError.default('Unsupported protocol ' + protocol + ':', _AxiosError.default.ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData || null);
  });
};
},{"./../utils.js":"../node_modules/axios/lib/utils.js","./../core/settle.js":"../node_modules/axios/lib/core/settle.js","../defaults/transitional.js":"../node_modules/axios/lib/defaults/transitional.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","../cancel/CanceledError.js":"../node_modules/axios/lib/cancel/CanceledError.js","../helpers/parseProtocol.js":"../node_modules/axios/lib/helpers/parseProtocol.js","../platform/index.js":"../node_modules/axios/lib/platform/index.js","../core/AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js","../helpers/progressEventReducer.js":"../node_modules/axios/lib/helpers/progressEventReducer.js","../helpers/resolveConfig.js":"../node_modules/axios/lib/helpers/resolveConfig.js"}],"../node_modules/axios/lib/helpers/composeSignals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const composeSignals = (signals, timeout) => {
  const {
    length
  } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof _AxiosError.default ? err : new _CanceledError.default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new _AxiosError.default(`timeout ${timeout} of ms exceeded`, _AxiosError.default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };
    signals.forEach(signal => signal.addEventListener('abort', onabort));
    const {
      signal
    } = controller;
    signal.unsubscribe = () => _utils.default.asap(unsubscribe);
    return signal;
  }
};
var _default = exports.default = composeSignals;
},{"../cancel/CanceledError.js":"../node_modules/axios/lib/cancel/CanceledError.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/helpers/trackStream.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackStream = exports.streamChunk = exports.readBytes = void 0;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
exports.streamChunk = streamChunk;
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
exports.readBytes = readBytes;
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (;;) {
      const {
        done,
        value
      } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = e => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const {
          done,
          value
        } = await iterator.next();
        if (done) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
exports.trackStream = trackStream;
},{}],"../node_modules/axios/lib/adapters/fetch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _index = _interopRequireDefault(require("../platform/index.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _composeSignals = _interopRequireDefault(require("../helpers/composeSignals.js"));
var _trackStream = require("../helpers/trackStream.js");
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _progressEventReducer = require("../helpers/progressEventReducer.js");
var _resolveConfig = _interopRequireDefault(require("../helpers/resolveConfig.js"));
var _settle = _interopRequireDefault(require("../core/settle.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(_index.default.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    }
  }).headers.has('Content-Type');
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => _utils.default.isReadableStream(new Response('').body));
const resolvers = {
  stream: supportsResponseStream && (res => res.body)
};
isFetchSupported && (res => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = _utils.default.isFunction(res[type]) ? res => res[type]() : (_, config) => {
      throw new _AxiosError.default(`Response type '${type}' is not supported`, _AxiosError.default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async body => {
  if (body == null) {
    return 0;
  }
  if (_utils.default.isBlob(body)) {
    return body.size;
  }
  if (_utils.default.isSpecCompliantForm(body)) {
    const _request = new Request(_index.default.origin, {
      method: 'POST',
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (_utils.default.isArrayBufferView(body) || _utils.default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (_utils.default.isURLSearchParams(body)) {
    body = body + '';
  }
  if (_utils.default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = _utils.default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var _default = exports.default = isFetchSupported && (async config => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = (0, _resolveConfig.default)(config);
  responseType = responseType ? (responseType + '').toLowerCase() : 'text';
  let composedSignal = (0, _composeSignals.default)([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (_utils.default.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = (0, _progressEventReducer.progressEventDecorator)(requestContentLength, (0, _progressEventReducer.progressEventReducer)((0, _progressEventReducer.asyncDecorator)(onUploadProgress)));
        data = (0, _trackStream.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!_utils.default.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });
      const responseContentLength = _utils.default.toFiniteNumber(response.headers.get('content-length'));
      const [onProgress, flush] = onDownloadProgress && (0, _progressEventReducer.progressEventDecorator)(responseContentLength, (0, _progressEventReducer.progressEventReducer)((0, _progressEventReducer.asyncDecorator)(onDownloadProgress), true)) || [];
      response = new Response((0, _trackStream.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
        flush && flush();
        unsubscribe && unsubscribe();
      }), options);
    }
    responseType = responseType || 'text';
    let responseData = await resolvers[_utils.default.findKey(resolvers, responseType) || 'text'](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      (0, _settle.default)(resolve, reject, {
        data: responseData,
        headers: _AxiosHeaders.default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(new _AxiosError.default('Network Error', _AxiosError.default.ERR_NETWORK, config, request), {
        cause: err.cause || err
      });
    }
    throw _AxiosError.default.from(err, err && err.code, config, request);
  }
});
},{"../platform/index.js":"../node_modules/axios/lib/platform/index.js","../utils.js":"../node_modules/axios/lib/utils.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","../helpers/composeSignals.js":"../node_modules/axios/lib/helpers/composeSignals.js","../helpers/trackStream.js":"../node_modules/axios/lib/helpers/trackStream.js","../core/AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js","../helpers/progressEventReducer.js":"../node_modules/axios/lib/helpers/progressEventReducer.js","../helpers/resolveConfig.js":"../node_modules/axios/lib/helpers/resolveConfig.js","../core/settle.js":"../node_modules/axios/lib/core/settle.js"}],"../node_modules/axios/lib/adapters/adapters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _http = _interopRequireDefault(require("./http.js"));
var _xhr = _interopRequireDefault(require("./xhr.js"));
var _fetch = _interopRequireDefault(require("./fetch.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const knownAdapters = {
  http: _http.default,
  xhr: _xhr.default,
  fetch: _fetch.default
};
_utils.default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {
        value
      });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {
      value
    });
  }
});
const renderReason = reason => `- ${reason}`;
const isResolvedHandle = adapter => _utils.default.isFunction(adapter) || adapter === null || adapter === false;
var _default = exports.default = {
  getAdapter: adapters => {
    adapters = _utils.default.isArray(adapters) ? adapters : [adapters];
    const {
      length
    } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new _AxiosError.default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || '#' + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
      let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
      throw new _AxiosError.default(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
    }
    return adapter;
  },
  adapters: knownAdapters
};
},{"../utils.js":"../node_modules/axios/lib/utils.js","./http.js":"../node_modules/axios/lib/helpers/null.js","./xhr.js":"../node_modules/axios/lib/adapters/xhr.js","./fetch.js":"../node_modules/axios/lib/adapters/fetch.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js"}],"../node_modules/axios/lib/core/dispatchRequest.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dispatchRequest;
var _transformData = _interopRequireDefault(require("./transformData.js"));
var _isCancel = _interopRequireDefault(require("../cancel/isCancel.js"));
var _index = _interopRequireDefault(require("../defaults/index.js"));
var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _adapters = _interopRequireDefault(require("../adapters/adapters.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new _CanceledError.default(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = _AxiosHeaders.default.from(config.headers);

  // Transform request data
  config.data = _transformData.default.call(config, config.transformRequest);
  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }
  const adapter = _adapters.default.getAdapter(config.adapter || _index.default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData.default.call(config, config.transformResponse, response);
    response.headers = _AxiosHeaders.default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!(0, _isCancel.default)(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData.default.call(config, config.transformResponse, reason.response);
        reason.response.headers = _AxiosHeaders.default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
},{"./transformData.js":"../node_modules/axios/lib/core/transformData.js","../cancel/isCancel.js":"../node_modules/axios/lib/cancel/isCancel.js","../defaults/index.js":"../node_modules/axios/lib/defaults/index.js","../cancel/CanceledError.js":"../node_modules/axios/lib/cancel/CanceledError.js","../core/AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js","../adapters/adapters.js":"../node_modules/axios/lib/adapters/adapters.js"}],"../node_modules/axios/lib/env/data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const VERSION = exports.VERSION = "1.8.4";
},{}],"../node_modules/axios/lib/helpers/validator.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _data = require("../env/data.js");
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _data.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _AxiosError.default(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), _AxiosError.default.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _AxiosError.default('options must be an object', _AxiosError.default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _AxiosError.default('option ' + opt + ' must be ' + result, _AxiosError.default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _AxiosError.default('Unknown option ' + opt, _AxiosError.default.ERR_BAD_OPTION);
    }
  }
}
var _default = exports.default = {
  assertOptions,
  validators
};
},{"../env/data.js":"../node_modules/axios/lib/env/data.js","../core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js"}],"../node_modules/axios/lib/core/Axios.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _buildURL = _interopRequireDefault(require("../helpers/buildURL.js"));
var _InterceptorManager = _interopRequireDefault(require("./InterceptorManager.js"));
var _dispatchRequest = _interopRequireDefault(require("./dispatchRequest.js"));
var _mergeConfig = _interopRequireDefault(require("./mergeConfig.js"));
var _buildFullPath = _interopRequireDefault(require("./buildFullPath.js"));
var _validator = _interopRequireDefault(require("../helpers/validator.js"));
var _AxiosHeaders = _interopRequireDefault(require("./AxiosHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const validators = _validator.default.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new _InterceptorManager.default(),
      response: new _InterceptorManager.default()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = (0, _mergeConfig.default)(this.defaults, config);
    const {
      transitional,
      paramsSerializer,
      headers
    } = config;
    if (transitional !== undefined) {
      _validator.default.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (_utils.default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        _validator.default.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    _validator.default.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && _utils.default.merge(headers.common, headers[config.method]);
    headers && _utils.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
      delete headers[method];
    });
    config.headers = _AxiosHeaders.default.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequest.default.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = _dispatchRequest.default.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = (0, _mergeConfig.default)(this.defaults, config);
    const fullPath = (0, _buildFullPath.default)(config.baseURL, config.url, config.allowAbsoluteUrls);
    return (0, _buildURL.default)(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
_utils.default.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request((0, _mergeConfig.default)(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
_utils.default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0, _mergeConfig.default)(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
var _default = exports.default = Axios;
},{"./../utils.js":"../node_modules/axios/lib/utils.js","../helpers/buildURL.js":"../node_modules/axios/lib/helpers/buildURL.js","./InterceptorManager.js":"../node_modules/axios/lib/core/InterceptorManager.js","./dispatchRequest.js":"../node_modules/axios/lib/core/dispatchRequest.js","./mergeConfig.js":"../node_modules/axios/lib/core/mergeConfig.js","./buildFullPath.js":"../node_modules/axios/lib/core/buildFullPath.js","../helpers/validator.js":"../node_modules/axios/lib/helpers/validator.js","./AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js"}],"../node_modules/axios/lib/cancel/CancelToken.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _CanceledError = _interopRequireDefault(require("./CanceledError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }
      token.reason = new _CanceledError.default(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = err => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var _default = exports.default = CancelToken;
},{"./CanceledError.js":"../node_modules/axios/lib/cancel/CanceledError.js"}],"../node_modules/axios/lib/helpers/spread.js":[function(require,module,exports) {
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = spread;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
},{}],"../node_modules/axios/lib/helpers/isAxiosError.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isAxiosError;
var _utils = _interopRequireDefault(require("./../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils.default.isObject(payload) && payload.isAxiosError === true;
}
},{"./../utils.js":"../node_modules/axios/lib/utils.js"}],"../node_modules/axios/lib/helpers/HttpStatusCode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var _default = exports.default = HttpStatusCode;
},{}],"../node_modules/axios/lib/axios.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = _interopRequireDefault(require("./utils.js"));
var _bind = _interopRequireDefault(require("./helpers/bind.js"));
var _Axios = _interopRequireDefault(require("./core/Axios.js"));
var _mergeConfig = _interopRequireDefault(require("./core/mergeConfig.js"));
var _index = _interopRequireDefault(require("./defaults/index.js"));
var _formDataToJSON = _interopRequireDefault(require("./helpers/formDataToJSON.js"));
var _CanceledError = _interopRequireDefault(require("./cancel/CanceledError.js"));
var _CancelToken = _interopRequireDefault(require("./cancel/CancelToken.js"));
var _isCancel = _interopRequireDefault(require("./cancel/isCancel.js"));
var _data = require("./env/data.js");
var _toFormData = _interopRequireDefault(require("./helpers/toFormData.js"));
var _AxiosError = _interopRequireDefault(require("./core/AxiosError.js"));
var _spread = _interopRequireDefault(require("./helpers/spread.js"));
var _isAxiosError = _interopRequireDefault(require("./helpers/isAxiosError.js"));
var _AxiosHeaders = _interopRequireDefault(require("./core/AxiosHeaders.js"));
var _adapters = _interopRequireDefault(require("./adapters/adapters.js"));
var _HttpStatusCode = _interopRequireDefault(require("./helpers/HttpStatusCode.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new _Axios.default(defaultConfig);
  const instance = (0, _bind.default)(_Axios.default.prototype.request, context);

  // Copy axios.prototype to instance
  _utils.default.extend(instance, _Axios.default.prototype, context, {
    allOwnKeys: true
  });

  // Copy context to instance
  _utils.default.extend(instance, context, null, {
    allOwnKeys: true
  });

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0, _mergeConfig.default)(defaultConfig, instanceConfig));
  };
  return instance;
}

// Create the default instance to be exported
const axios = createInstance(_index.default);

// Expose Axios class to allow class inheritance
axios.Axios = _Axios.default;

// Expose Cancel & CancelToken
axios.CanceledError = _CanceledError.default;
axios.CancelToken = _CancelToken.default;
axios.isCancel = _isCancel.default;
axios.VERSION = _data.VERSION;
axios.toFormData = _toFormData.default;

// Expose AxiosError class
axios.AxiosError = _AxiosError.default;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = _spread.default;

// Expose isAxiosError
axios.isAxiosError = _isAxiosError.default;

// Expose mergeConfig
axios.mergeConfig = _mergeConfig.default;
axios.AxiosHeaders = _AxiosHeaders.default;
axios.formToJSON = thing => (0, _formDataToJSON.default)(_utils.default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = _adapters.default.getAdapter;
axios.HttpStatusCode = _HttpStatusCode.default;
axios.default = axios;

// this module should only have a default export
var _default = exports.default = axios;
},{"./utils.js":"../node_modules/axios/lib/utils.js","./helpers/bind.js":"../node_modules/axios/lib/helpers/bind.js","./core/Axios.js":"../node_modules/axios/lib/core/Axios.js","./core/mergeConfig.js":"../node_modules/axios/lib/core/mergeConfig.js","./defaults/index.js":"../node_modules/axios/lib/defaults/index.js","./helpers/formDataToJSON.js":"../node_modules/axios/lib/helpers/formDataToJSON.js","./cancel/CanceledError.js":"../node_modules/axios/lib/cancel/CanceledError.js","./cancel/CancelToken.js":"../node_modules/axios/lib/cancel/CancelToken.js","./cancel/isCancel.js":"../node_modules/axios/lib/cancel/isCancel.js","./env/data.js":"../node_modules/axios/lib/env/data.js","./helpers/toFormData.js":"../node_modules/axios/lib/helpers/toFormData.js","./core/AxiosError.js":"../node_modules/axios/lib/core/AxiosError.js","./helpers/spread.js":"../node_modules/axios/lib/helpers/spread.js","./helpers/isAxiosError.js":"../node_modules/axios/lib/helpers/isAxiosError.js","./core/AxiosHeaders.js":"../node_modules/axios/lib/core/AxiosHeaders.js","./adapters/adapters.js":"../node_modules/axios/lib/adapters/adapters.js","./helpers/HttpStatusCode.js":"../node_modules/axios/lib/helpers/HttpStatusCode.js"}],"../node_modules/axios/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = exports.VERSION = exports.HttpStatusCode = exports.CanceledError = exports.CancelToken = exports.Cancel = exports.AxiosHeaders = exports.AxiosError = exports.Axios = void 0;
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _axios.default;
  }
});
exports.toFormData = exports.spread = exports.mergeConfig = exports.isCancel = exports.isAxiosError = exports.getAdapter = exports.formToJSON = void 0;
var _axios = _interopRequireDefault(require("./lib/axios.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = _axios.default;
exports.mergeConfig = mergeConfig;
exports.getAdapter = getAdapter;
exports.formToJSON = formToJSON;
exports.HttpStatusCode = HttpStatusCode;
exports.AxiosHeaders = AxiosHeaders;
exports.toFormData = toFormData;
exports.spread = spread;
exports.isAxiosError = isAxiosError;
exports.Cancel = Cancel;
exports.all = all;
exports.VERSION = VERSION;
exports.CancelToken = CancelToken;
exports.isCancel = isCancel;
exports.CanceledError = CanceledError;
exports.AxiosError = AxiosError;
exports.Axios = Axios;
},{"./lib/axios.js":"../node_modules/axios/lib/axios.js"}],"index.js":[function(require,module,exports) {
var define;
"use strict";

var _child_process = require("child_process");
var pdfjsLib = _interopRequireWildcard(require("pdfjs-dist"));
var _axios = _interopRequireDefault(require("axios"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } // Importar las librerías
//Python
// Librería para trabajar con documentos PDF
// Para hacer peticiones HTTP

// Configuración del trabajador (worker) de PDF.js para procesar los PDFs en segundo plano
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/".concat(pdfjsLib.version, "/pdf.worker.min.js");

// Variable global para almacenar el texto extraído del PDF
var currentText = '';

// Función para anonimizar texto utilizando la API Flask de Google Colab
function anonymizeTextWithPython(_x) {
  return _anonymizeTextWithPython.apply(this, arguments);
} // Evento que se activa al hacer clic en el botón para abrir un archivo PDF
function _anonymizeTextWithPython() {
  _anonymizeTextWithPython = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(text) {
    var response;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          _context4.next = 3;
          return _axios.default.post('http://localhost:5000/anonymize', {
            text: text
          });
        case 3:
          response = _context4.sent;
          if (!(response.status === 200)) {
            _context4.next = 12;
            break;
          }
          if (!(response.data && response.data.anonymizedText)) {
            _context4.next = 9;
            break;
          }
          return _context4.abrupt("return", response.data.anonymizedText);
        case 9:
          throw new Error('Respuesta inesperada del servidor Flask.');
        case 10:
          _context4.next = 14;
          break;
        case 12:
          console.error('Error en la respuesta de Flask: Status', response.status);
          throw new Error('Error al recibir la respuesta de Flask');
        case 14:
          _context4.next = 31;
          break;
        case 16:
          _context4.prev = 16;
          _context4.t0 = _context4["catch"](0);
          console.error('Error en la petición a Flask:', _context4.t0);

          // Diferenciar entre un error de red y un error interno
          if (!_context4.t0.response) {
            _context4.next = 24;
            break;
          }
          // Errores provenientes de la respuesta (ej. código de estado 4xx o 5xx)
          console.error('Error de respuesta de Flask:', _context4.t0.response.data);
          throw new Error("Error de respuesta: ".concat(_context4.t0.response.status, " - ").concat(_context4.t0.response.statusText));
        case 24:
          if (!_context4.t0.request) {
            _context4.next = 29;
            break;
          }
          // Errores cuando no se recibe respuesta
          console.error('No se recibió respuesta de Flask:', _context4.t0.request);
          throw new Error('No se recibió respuesta del servidor Flask');
        case 29:
          // Errores inesperados en la solicitud
          console.error('Error inesperado:', _context4.t0.message);
          throw new Error('Error inesperado al hacer la solicitud');
        case 31:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[0, 16]]);
  }));
  return _anonymizeTextWithPython.apply(this, arguments);
}
document.getElementById('open-pdf').addEventListener('click', function () {
  document.getElementById('file-input').click();
});

// Evento que se activa al hacer clic en el botón de búsqueda
document.getElementById('search-text').addEventListener('click', function () {
  var searchInput = document.getElementById('search-input');
  searchInput.style.display = searchInput.style.display === 'none' ? 'block' : 'none';
  if (searchInput.style.display === 'block') {
    searchInput.focus();
  }
});

// Evento que se activa al escribir en el campo de búsqueda
document.getElementById('search-input').addEventListener('input', function (e) {
  var searchTerm = e.target.value.toLowerCase();
  var textArea = document.getElementById('extracted-text');
  var text = textArea.value;
  if (!searchTerm) {
    textArea.value = currentText;
    return;
  }
  var regex = new RegExp(searchTerm, 'gi');
  var highlightedText = text.replace(regex, function (match) {
    return "[".concat(match, "]");
  });
  textArea.value = highlightedText;
});
document.getElementById('anonymize-text').addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  var textArea, text, response, errorData, data;
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        textArea = document.getElementById('extracted-text');
        text = textArea.value.trim();
        if (text) {
          _context.next = 5;
          break;
        }
        alert("Por favor, ingresa un texto antes de anonimizar.");
        return _context.abrupt("return");
      case 5:
        _context.prev = 5;
        // Mostrar mensaje de carga
        Swal.fire({
          title: 'Anonimizando texto...',
          text: 'Por favor, espera mientras procesamos el texto.',
          icon: 'info',
          allowOutsideClick: false,
          didOpen: function didOpen() {
            Swal.showLoading();
          }
        });

        // Hacer la petición a Flask
        _context.next = 9;
        return fetch('http://localhost:5000/anonymize', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text
          }) // Enviar el texto extraído
        });
      case 9:
        response = _context.sent;
        if (response.ok) {
          _context.next = 15;
          break;
        }
        _context.next = 13;
        return response.json();
      case 13:
        errorData = _context.sent;
        throw new Error(errorData.error || "Error desconocido: ".concat(response.status, " ").concat(response.statusText));
      case 15:
        _context.next = 17;
        return response.json();
      case 17:
        data = _context.sent;
        // La respuesta contiene el texto anonimizado
        textArea.value = data.anonymizedText; // Actualiza el texto anonimizado

        // Cierra el mensaje de carga y muestra éxito
        Swal.close();
        Swal.fire({
          title: 'Texto Anonimizado',
          text: 'El texto ha sido anonimizado exitosamente.',
          icon: 'success',
          timer: 2000,
          showConfirmButton: false
        });
        _context.next = 27;
        break;
      case 23:
        _context.prev = 23;
        _context.t0 = _context["catch"](5);
        // Cierra el mensaje de carga
        Swal.close();

        // Muestra un alert con el error específico
        alert("No se pudo anonimizar el texto: ".concat(_context.t0.message));
      case 27:
      case "end":
        return _context.stop();
    }
  }, _callee, null, [[5, 23]]);
})));

// Evento que se activa cuando el usuario selecciona un archivo PDF
document.getElementById('file-input').addEventListener('change', /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {
    var file, fileReader;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          file = event.target.files[0];
          if (file && file.type === 'application/pdf') {
            fileReader = new FileReader();
            fileReader.onload = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
              var pdfData, pdfUrl, pdf, text, i, page, textContent;
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    pdfData = new Uint8Array(this.result);
                    pdfUrl = URL.createObjectURL(new Blob([pdfData], {
                      type: 'application/pdf'
                    }));
                    document.getElementById('pdf-iframe').src = pdfUrl;
                    _context2.prev = 3;
                    Swal.fire({
                      title: 'Extrayendo texto del PDF...',
                      text: 'Por favor, espera.',
                      icon: 'info',
                      allowOutsideClick: false,
                      didOpen: function didOpen() {
                        Swal.showLoading();
                      }
                    });
                    _context2.next = 7;
                    return pdfjsLib.getDocument({
                      data: pdfData
                    }).promise;
                  case 7:
                    pdf = _context2.sent;
                    text = '';
                    i = 1;
                  case 10:
                    if (!(i <= pdf.numPages)) {
                      _context2.next = 21;
                      break;
                    }
                    _context2.next = 13;
                    return pdf.getPage(i);
                  case 13:
                    page = _context2.sent;
                    _context2.next = 16;
                    return page.getTextContent();
                  case 16:
                    textContent = _context2.sent;
                    textContent.items.forEach(function (item) {
                      text += item.str + ' ';
                    });
                  case 18:
                    i++;
                    _context2.next = 10;
                    break;
                  case 21:
                    currentText = text;
                    document.getElementById('extracted-text').value = text;
                    Swal.close();
                    _context2.next = 30;
                    break;
                  case 26:
                    _context2.prev = 26;
                    _context2.t0 = _context2["catch"](3);
                    Swal.fire({
                      title: 'Error',
                      text: "No se puede extraer el texto del PDF: ".concat(_context2.t0.message),
                      icon: 'error'
                    });
                    console.error('Error extrayendo texto del PDF:', _context2.t0);
                  case 30:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, this, [[3, 26]]);
            }));
            fileReader.readAsArrayBuffer(file);
          } else {
            Swal.fire({
              title: 'Error',
              text: 'Por favor, selecciona un archivo PDF válido.',
              icon: 'error'
            });
          }
        case 2:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());

// Función para mostrar un mensaje en la interfaz
function showMessage(message, type) {
  var messageElement = document.getElementById('message');
  messageElement.textContent = message;
  messageElement.className = type;
}
},{"child_process":"../node_modules/parcel-bundler/src/builtins/_empty.js","pdfjs-dist":"../node_modules/pdfjs-dist/build/pdf.js","axios":"../node_modules/axios/index.js"}],"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "53904" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/src.e31bb0bc.js.map